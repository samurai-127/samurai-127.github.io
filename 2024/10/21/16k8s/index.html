<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>k8s：自动部署、扩缩和管理容器化应用程序系统 | 颓废市民黄先生</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/avatar.ico"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=1.13.3"><!-- inject head--><link rel="canonical" href="https://samurai-127.github.io/2024/10/21/16k8s/"><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><!-- aplayer--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/11.0.5/swiper-bundle.min.css"><!-- fancybox ui--><!-- katex--><!-- Open Graph--><meta name="description" content="1. k8s架构整体架构图官方提供的整体架构图如下： 主节点既可以做主节点，也可以做从节点，最小要求一主一从作为学习要求。 下边是对官方的结构图进行解释后的架构图： 通过kubectl或者可视化ui操作k8s对外开放的api-server，即从节点的kubelet去管理从节点或pod。"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="颓废市民黄先生"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/avatar.ico"><link rel="apple-touch-icon" href="/img/avatar.ico" sizes="180x180"><script>console.log(' %c Solitude %c ' + '1.13.3' + ' %c https://github.com/everfu/hexo-theme-solitude',
    'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',
    'background:#ff9a9a ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff',
    'background:unset ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff')
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":false,"path":"/search.xml"},
    runtime: 'false',
    lazyload: {
        enable: false,
        error: '/img/error_load.avif'
    },
    copyright: {"limit":50,"author":"作者: 颓废市民黄先生","link":"链接: ","source":"来源: 颓废市民黄先生","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {"limit":200,"expand":true,"copy":true,"syntax":"highlight.js"},
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"day":" 天","f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。"},"barrage":{"title":"热评"}},
    aside: {
        sayhello: {
            morning: '起那么早看博客？',
            noon: '中午休息一下呗',
            afternoon: '下午好像在犯困',
            night: '晚上洗个澡爽一下呗',
            goodnight: '睡个好觉，保证精力充沛',
        },
        sayhello2: [],
        sayhello3: {
            prefix: '好久不见，',
            back: '欢迎再次回来，',
        },
    },
    covercolor: {
        enable: false
    },
    comment: {"avatar":"https://cravatar.cn","commentBarrage":true},
    lightbox: 'null',
    post_ai: {"key":"449aa72132adf73ef7084ef83c46792af1edab","talk":null,"randomPost":false},
    right_menu: {"mode":{"dark":"深色模式","light":"浅色模式"},"img_error":"此图片无法复制与下载","music":{"start":"播放音乐","stop":"暂停音乐"},"barrage":{"open":"显示热评","close":"关闭热评"},"translate":{"translateDelay":0,"defaultEncoding":2}},
    lure: {"jump":"404 Not Found","back":"被骗了吧（），网页没有404"},
    expire: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: 'string',
    toc: true,
    comment: true,
    ai_text: false
}</script><meta name="generator" content="Hexo 7.2.0"></head><body id="body" data-type="string"><!-- universe--><canvas id="universe"></canvas><!-- background img--><div id="global_bg"></div><!-- loading--><!-- console--><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span>显示模式</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的歌单</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message"><span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/recentcomments"><span>最近留言</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/mysql/">mysql<sup>6</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/">面试<sup>23</sup></a><a href="/tags/redis/">redis<sup>3</sup></a><a href="/tags/MQ/">MQ<sup>2</sup></a><a href="/tags/springcloud/">springcloud<sup>4</sup></a><a href="/tags/Java/">Java<sup>2</sup></a><a href="/tags/seata/">seata<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/">后端<sup>1</sup></a><a href="/tags/sentinel/">sentinel<sup>2</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程<sup>5</sup></a><a href="/tags/docker/">docker<sup>3</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/">软件技术<sup>8</sup></a><a href="/tags/kubernetes/">kubernetes<sup>2</sup></a><a href="/tags/JDBC/">JDBC<sup>1</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/git/">git<sup>1</sup></a><a href="/tags/mybatis/">mybatis<sup>1</sup></a><a href="/tags/spring/">spring<sup>1</sup></a><a href="/tags/hexo/">hexo<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<sup>2</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/">算法<sup>4</sup></a></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/" title="返回博客主页"><span class="title">颓废市民黄先生</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">k8s：自动部署、扩缩和管理容器化应用程序系统</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的歌单</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message"><span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/recentcomments"><span>最近留言</span></a></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机一篇文章" href="javascript:void(0);"><i class="solitude st-dice-line"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude st-search-line"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude st-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude st-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="/img/cover/16k8s.avif" alt="k8s：自动部署、扩缩和管理容器化应用程序系统"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/">软件技术</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"><span class="tags-name tags-punctuation">软件技术</span></a><a class="post-meta__tags" href="/tags/kubernetes/"><span class="tags-name tags-punctuation">kubernetes</span></a></div></div></div></div><h1 class="post-title">k8s：自动部署、扩缩和管理容器化应用程序系统</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2024-10-21 14:50:48"><i class="post-meta-icon solitude st-calendar-todo-fill"></i><time datetime="2024-10-21T06:50:48.000Z">2024-10-21T06:50:48.000Z</time></span><span class="post-meta-date" title="最后更新于 2024-10-30 10:10:28"><i class="post-meta-icon solitude st-refresh-line"></i><time datetime="2024-10-30T02:10:28.654Z">2024-10-30T02:10:28.654Z</time></span><span class="post-meta-position" title="作者IP归属地为广西"><i class="post-meta-icon solitude st-map-pin-fill"></i><span>广西</span></span><a class="post-meta-pv" href="/2024/10/21/16k8s/" title="文章热度"><i class="post-meta-icon solitude st-fire-fill"></i><span id="twikoo_visitors"><i class="solitude st-loading-line"></i></span></a><span class="post-meta-commentcount" title="评论数" onclick="sco.scrollTo('post-comment')"><i class="solitude st-chat-fill"></i><a href="/2024/10/21/16k8s/#post-comment"><span class="twikoo-count"><i class="solitude st-loading-line"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="post-ai"><div class="ai-title"><div class="ai-title-left"><i class="ai-title-icon solitude st-robot-fill"></i><div class="ai-title-text">文章摘要</div></div><div class="ai-tag" id="ai-tag">GPT 4</div></div><div class="ai-explanation" style="display: block;"></div><div class="ai-suggestions"></div><div class="ai-bottom"><div class="ai-tips">此内容根据文章生成，仅用于文章内容的解释与总结</div><a class="ai-report" title="投诉" href="https://samurai-127.github.io">投诉</a></div></div><h1 id="1-k8s架构"><a href="#1-k8s架构" class="headerlink" title="1. k8s架构"></a>1. k8s架构</h1><h2 id="整体架构图"><a href="#整体架构图" class="headerlink" title="整体架构图"></a>整体架构图</h2><p>官方提供的整体架构图如下：</p>
<img src="85a22c87c5324f8e54df46f32c8080c1.png" alt="架构图" style="zoom:150%;">



<p>主节点既可以做主节点，也可以做从节点，最小要求一主一从作为学习要求。</p>
<p><strong>下边是对官方的结构图进行解释后的架构图：</strong></p>
<p>通过kubectl或者可视化ui操作k8s对外开放的api-server，即从节点的kubelet去管理从节点或pod。</p>
<img src="image-20241021145758104.png" alt="具体组件" style="zoom:150%;">



<p><strong>核心组件（主节点，或者叫控制面板）：</strong></p>
<ul>
<li><p>api-server 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；</p>
</li>
<li><p>etcd 保存了整个集群的状态；</p>
<blockquote>
<p>etcd是构建一个高可用的分布式键值(key-value)数据库。etcd内部采用<code>raft</code>协议作为一致性算法，etcd基于Go语言实现 ;主要用于共享配置和服务发现 ;</p>
<p>原理动画演示：<a target="_blank" rel="noopener" href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
</blockquote>
</li>
<li><p>controller manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</p>
</li>
<li><p>scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</p>
</li>
</ul>
<p><strong>从节点的组件：</strong></p>
<ul>
<li>kubelet 负责维护容器的生命周期，同时也负责 Volume（CSI）和网络（CNI）的管理；</li>
<li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）；</li>
<li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡，ISO提出的OSI参考模型（Open System Interconnection Reference Model）将网络通信的复杂过程分解成7层活动，这通常被称为网络通信的七层模型，而此处为4层负载；</li>
</ul>
<h2 id="组件间协议-分层架构图"><a href="#组件间协议-分层架构图" class="headerlink" title="组件间协议&amp;分层架构图"></a>组件间协议&amp;分层架构图</h2><p><img src="c1cdf54e23b1b85f53b4e32f88a3f7ad.jpeg" alt="组件间协议"></p>
<p><img src="f0cbf6a3c599f618631faae58c337654.jpeg" alt="分层架构图"></p>
<ul>
<li><p>CNI: CNI是Container Network Interface的是一个标准的，通用的接口 ;用于连接容器管理系统和网络插件。提供一个容器所在的network namespace，将network interface插入该network namespace中（比如veth的一端），并且在宿主机做一些必要的配置（例如将veth的另一端加入bridge中），最后对namespace中的interface进行IP和路由的配置。现有解决方案：flannel，calico，weave。</p>
<p><strong>在架构中有看到，kubelet通过api-server操作从节点，即通过网络接口来实现。</strong></p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zhonglinzhang/article/details/82697524">https://blog.csdn.net/zhonglinzhang/article/details/82697524</a></p>
</li>
<li><p>CRI： 容器运行时接口(Container Runtime Interface)；CRI包含了一组protocol buffers，gRPC API，相关的库; 提供可插拔的容器运行时 ;k8s节点的底层由一个叫做“容器运行时”的软件进行支撑，它负责比如启停容器这样的事情；Docker是K8s中最常用的容器运行时。</p>
<p><strong>docker是容器管理中较好的使用方案，而容器运行时不一定只能使用docker。</strong></p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.kubernetes.org.cn/1079.html">https://www.kubernetes.org.cn/1079.html</a></p>
</li>
<li><p>CSI：CSI（Container Storage Interface）是一个用于为Kubernetes集群提供持久化存储的标准接口。它允许第三方存储供应商（如云提供商和存储厂商）创建和管理持久化存储的插件，使得这些存储解决方案能够无缝集成到Kubernetes集群中，为Pod提供持久化存储服务。</p>
</li>
<li><p>OCI： 围绕容器的格式和运行时制定一个开放的工业化标准,并推动这个标准,保持容器的灵活性和开放性,容器能运行在任何的硬件和系统上，容器不应该绑定到特定的客户机或编排堆栈,不应该与任何特定的供应商紧密关联,并且可以跨多种操作系统；</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c7748893ab00">https://www.jianshu.com/p/c7748893ab00</a></p>
<p>官网：<a target="_blank" rel="noopener" href="https://opencontainers.org/">https://opencontainers.org/</a></p>
</li>
</ul>
<h2 id="视频介绍：什么是K8S？"><a href="#视频介绍：什么是K8S？" class="headerlink" title="视频介绍：什么是K8S？"></a>视频介绍：什么是K8S？</h2><p>参考链接1：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Du4m137pK/?spm_id_from=333.337.search-card.all.click&vd_source=c97fb1b65102f7ab46e3da7760d19cd0">Kubernetes(k8s)是什么？架构是怎么样的？</a></p>
<p>参考链接2：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aA4m1w7Ew?spm_id_from=333.788.videopod.sections&vd_source=c97fb1b65102f7ab46e3da7760d19cd0">docker是什么？和kubernetes(k8s)是什么关系？_</a></p>
<h1 id="2-k8s技术概念"><a href="#2-k8s技术概念" class="headerlink" title="2. k8s技术概念"></a>2. k8s技术概念</h1><h2 id="无状态应用与有状态应用"><a href="#无状态应用与有状态应用" class="headerlink" title="无状态应用与有状态应用"></a>无状态应用与有状态应用</h2><p>无状态应用不能具备存储数据的组件，由于再部署后会缺乏数据，因此只能是有状态应用。</p>
<img src="image-20241021172124992.png" alt="无状态应用与有状态应用" style="zoom:150%;">





<h2 id="资源分类：集群级、命名空间级、元数据级"><a href="#资源分类：集群级、命名空间级、元数据级" class="headerlink" title="资源分类：集群级、命名空间级、元数据级"></a>资源分类：集群级、命名空间级、元数据级</h2><p><img src="image-20241022093051261.png" alt="思维导图"></p>
<p><img src="image-20241022091645153.png"></p>
<h3 id="元数据类型"><a href="#元数据类型" class="headerlink" title="元数据类型"></a>元数据类型</h3><h4 id="Horizontal-Pod-Autoscaler（HPA）"><a href="#Horizontal-Pod-Autoscaler（HPA）" class="headerlink" title="Horizontal Pod Autoscaler（HPA）"></a>Horizontal Pod Autoscaler（HPA）</h4><p>Pod 自动扩容：可以根据 CPU 使用率或自定义指标（metrics）自动对 Pod 进行扩&#x2F;缩容。</p>
<ul>
<li>控制管理器每隔30s（可以通过–horizontal-pod-autoscaler-sync-period修改）查询metrics的资源使用情况</li>
<li>支持三种metrics类型<ul>
<li>预定义metrics（比如Pod的CPU）以利用率的方式计算</li>
<li>自定义的Pod metrics，以原始值（raw value）的方式计算</li>
<li>自定义的object metrics</li>
</ul>
</li>
<li>支持两种metrics查询方式：Heapster和自定义的REST API</li>
<li>支持多metrics</li>
</ul>
<h4 id="PodTemplate"><a href="#PodTemplate" class="headerlink" title="PodTemplate"></a>PodTemplate</h4><p>Pod Template 是关于 Pod 的定义，但是被包含在其他的 Kubernetes 对象中（例如 Deployment、StatefulSet、DaemonSet 等控制器）。控制器通过 Pod Template 信息来创建 Pod。</p>
<h4 id="LimitRange"><a href="#LimitRange" class="headerlink" title="LimitRange"></a>LimitRange</h4><p>可以对集群内 Request 和 Limits 的配置做一个全局的统一的限制，相当于批量设置了某一个范围内（某个命名空间）的 Pod 的资源使用限制。</p>
<h3 id="pod（命名空间级）"><a href="#pod（命名空间级）" class="headerlink" title="pod（命名空间级）"></a>pod（命名空间级）</h3><h4 id="pod介绍"><a href="#pod介绍" class="headerlink" title="pod介绍"></a>pod介绍</h4><p>pod属于命名空间级别的资源，为什么是要有pod参照上一节架构的内容。</p>
<p><img src="image-20241022094206720.png" alt="组成图"></p>
<p>Pod（容器组）是 Kubernetes 中最小的可部署单元。一个 Pod（容器组）包含了一个应用程序容器（某些情况下是多个容器）、存储资源、一个唯一的网络 IP 地址、以及一些确定容器该如何运行的选项。Pod 容器组代表了 Kubernetes 中一个独立的应用程序运行实例，该实例可能由单个容器或者几个紧耦合在一起的容器组成。</p>
<p>Docker 是 Kubernetes Pod 中使用最广泛的容器引擎；Kubernetes Pod 同时也支持其他类型的容器引擎。</p>
<p>Kubernetes 集群中的 Pod 存在如下两种使用途径：</p>
<ul>
<li><p>一个 Pod 中只运行一个容器。”one-container-per-pod” 是 Kubernetes 中最常见的使用方式。此时，您可以认为 Pod 容器组是该容器的 wrapper，Kubernetes 通过 Pod 管理容器，而不是直接管理容器。</p>
</li>
<li><p>一个 Pod 中运行多个需要互相协作的容器。您可以将多个紧密耦合、共享资源且始终在一起运行的容器编排在同一个 Pod 中。</p>
</li>
</ul>
<h4 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h4><p>先引入“副本”的概念——一个 Pod 可以被复制成多份，每一份可被称之为一个“副本”，这些“副本”除了一些描述性的信息（Pod 的名字、uid 等）不一样以外，其它信息都是一样的，譬如 Pod 内部的容器、容器数量、容器里面运行的应用等的这些信息都是一样的，这些副本提供同样的功能。</p>
<h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h4><p><strong>控制器就是在第一节整体架构中提到的controller manager 。</strong>controller manager 负责维护集群的状态，比如故障检测、自动扩展、滚动更新等，在本节的组成图中又有更细的划分。</p>
<p>Pod 的<strong>“控制器”</strong>通常包含一个名为 “replicas” 的属性。“replicas”属性则指定了特定 Pod 的副本的数量，当当前集群中该 Pod 的数量与该属性指定的值不一致时，k8s 会采取一些策略去使得当前状态满足配置的要求。</p>
<h5 id="RC"><a href="#RC" class="headerlink" title="RC"></a>RC</h5><p>Replication Controller 简称 RC，RC 是 Kubernetes 系统中的核心概念之一，简单来说，RC 可以保证在任意时间运行 Pod 的副本数量，能够保证 Pod 总是可用的。如果实际 Pod 数量比指定的多那就结束掉多余的，如果实际数量比指定的少就新启动一些Pod，当 Pod 失败、被删除或者挂掉后，RC 都会去自动创建新的 Pod 来保证副本数量，所以即使只有一个 Pod，我们也应该使用 RC 来管理我们的 Pod。可以说，通过 ReplicationController，Kubernetes 实现了 Pod 的高可用性。</p>
<p>RC （ReplicationController ）主要的作用就是用来确保容器应用的副本数始终保持在用户定义的副本数 。即如果有容器异常退出，会自动创建新的 Pod 来替代；而如果异常多出来的容器也会自动回收（已经成为过去时），在 v1.11 版本废弃。</p>
<p><img src="image-20241022101501201.png" alt="RC：基于系统资源动态创建pod副本"></p>
<h5 id="RS（学习）"><a href="#RS（学习）" class="headerlink" title="RS（学习）"></a>RS（学习）</h5><p><strong>Kubernetes 官方建议使用 RS（ReplicaSet ） 替代 RC （ReplicationController ） 进行部署，RS 跟 RC 没有本质的不同，只是名字不一样，并且 RS 支持集合式的 selector。</strong></p>
<p>label （标签）是附加到 Kubernetes 对象（比如 Pods）上的键值对，用于区分对象（比如Pod、Service）。 label 旨在用于指定对用户有意义且相关的对象的标识属性，但不直接对核心系统有语义含义。 label 可以用于组织和选择对象的子集。label 可以在创建时附加到对象，随后可以随时添加和修改。可以像 namespace 一样，使用 label 来获取某类对象，但 label 可以与 selector 一起配合使用，用表达式对条件加以限制，实现更精确、更灵活的资源查找。</p>
<p>label 与 selector 配合，可以实现对象的“关联”，“Pod 控制器” 与 Pod 是相关联的 —— “Pod 控制器”依赖于 Pod，可以给 Pod 设置 label，然后给“控制器”设置对应的 selector，这就实现了对象的关联。</p>
<p><strong>总结为RS在RC的基础上进行灵活性的匹配pod。</strong></p>
<h5 id="Deployment（无状态、工作最常用）"><a href="#Deployment（无状态、工作最常用）" class="headerlink" title="Deployment（无状态、工作最常用）"></a>Deployment（无状态、工作最常用）</h5><p>Deployment 为 Pod 和 Replica Set 提供声明式更新。</p>
<p>你只需要在 Deployment 中描述你想要的目标状态是什么，Deployment controller 就会帮你将 Pod 和 Replica Set 的实际状态改变到你的目标状态。你可以定义一个全新的 Deployment，也可以创建一个新的替换旧的 Deployment。</p>
<p><img src="image-20241022102414572.png" alt="Deployment改进RS"></p>
<p>同时Deployment采用灰度发布，在新的pod中逐一复制同一容器，一直处于高可用状态。</p>
<p><img src="image-20241022102858292.png" alt="灰度发布"></p>
<h5 id="StatefulSet（有状态应用）"><a href="#StatefulSet（有状态应用）" class="headerlink" title="StatefulSet（有状态应用）"></a>StatefulSet（有状态应用）</h5><p><img src="image-20241025153130367.png"></p>
<blockquote>
<p>Headless Service</p>
</blockquote>
<ol>
<li><strong>没有Cluster IP</strong>：Headless Service在创建时，通过将<code>spec.clusterIP</code>设置为<code>None</code>，来表明它不需要一个集群内部的固定IP地址。</li>
<li><strong>为Pod提供稳定的网络标识</strong>：在StatefulSet中，Headless Service为每个Pod提供一个基于其序号索引的稳定DNS名称。例如，如果StatefulSet名称为<code>my-service</code>，Pod的序号为0，那么Pod的DNS名称将是<code>my-service-0.my-service.namespace.svc.cluster.local</code>。</li>
<li><strong>支持DNS解析</strong>：Kubernetes的DNS服务会为Headless Service中的每个Pod返回一个DNS A记录（Address Record），这些记录指向Pod的实际IP地址。这样，即使Pod的IP地址发生变化，通过DNS名称仍然可以访问到正确的Pod。</li>
<li><strong>支持负载均衡</strong>：虽然Headless Service不提供像Cluster IP那样的内置负载均衡，但它可以通过DNS返回多个A记录，客户端可以自行实现负载均衡逻辑。</li>
<li><strong>适用于有状态服务</strong>：Headless Service通常与StatefulSet一起使用，因为StatefulSet需要为每个Pod提供稳定的网络标识，而Headless Service正好满足这一需求。</li>
<li><strong>支持端口映射</strong>：就像常规的Service一样，Headless Service也可以定义端口映射，将服务的端口映射到Pod的端口。</li>
</ol>
<blockquote>
<p>volumeClaimTemplate</p>
</blockquote>
<p><strong>持久化存储</strong>：通过<code>volumeClaimTemplates</code>，StatefulSet为每个Pod创建独立的PersistentVolumeClaim（PVC），确保每个Pod都有自己的存储空间，数据不会因为Pod的重启而丢失。</p>
<h5 id="DaemonSet（守护进程）"><a href="#DaemonSet（守护进程）" class="headerlink" title="DaemonSet（守护进程）"></a>DaemonSet（守护进程）</h5><p>DaemonSet 保证在每个 Node 上都运行一个容器副本，常用来部署一些集群的日志、监控或者其他系统管理应用。典型的应用包括：</p>
<ul>
<li>日志收集，比如 fluentd，logstash 等</li>
<li>系统监控，比如 Prometheus Node Exporter，collectd，New Relic agent，Ganglia gmond 等</li>
<li>系统程序，比如 kube-proxy, kube-dns, glusterd, ceph 等</li>
<li><img src="image-20241022110230919.png" alt="守护进程的应用"></li>
</ul>
<h4 id="pod与docker间的对比"><a href="#pod与docker间的对比" class="headerlink" title="pod与docker间的对比"></a>pod与docker间的对比</h4><p><img src="image-20241022093706078.png" alt="pod与docker容器对比"></p>
<p>在pod中，pause是pod的初始容器，访问其他具体的容器都是通过pause容器进行访问的。</p>
<h2 id="为什么需要pod？"><a href="#为什么需要pod？" class="headerlink" title="为什么需要pod？"></a>为什么需要pod？</h2><p>视频中提到的Pod包含多个容器，那么为什么需要使用多个容器？为何需要pod这种容器？为何不直接使用容器？为何甚至需要同时运行多个容器？难道不能简单地把所有进程都放在一个单独的容器中吗？</p>
<p><img src="image-20241021161014090.png" alt="为什么需要pod"></p>
<blockquote>
<p>为什么多个容器比单个容器中包含多个进程要好？</p>
</blockquote>
<p>想象一个由多个进程组成的应用程序，无论是通过ipc（进程间通信）还是本地存储文件进行通信，都要求它们运行于同一台机器上。在Kubernetes中，我们经常在容器中运行进程，由于每一个容器都非常像一台独立的机器，此时你可能认为在单个容器中运行多个进程是合乎逻辑的，然而在实践中这种做法并不合理。</p>
<p><strong>容器被设计为每个容器只运行一个进程（除非进程本身产生子进程）。</strong>如果在单个容器中运行多个不相关的进程，那么保持所有进程运行、管理它们的日志等将会是我们的责任。例如，我们需要包含一种在进程崩溃时能够自动重启的机制。同时这些进程都将记录到相同的标准输出中，而此时我们将很难确定每个进程分别记录了什么。</p>
<p><strong>pod设计为多个容器的集合。</strong>由于不能将多个进程聚集在一个单独的容器中，我们需要另一种更高级的结构来将容器绑定在一起，并将它们作为一个单元进行管理，这就是pod背后的根本原理。</p>
<p>在包含容器的pod下，我们可以同时运行一些密切相关的进程，并为它们提供（几乎）相同的环境，此时这些进程就好像全部运行于单个容器中一样，同时又保持着一定的隔离。这样一来，我们便能全面地利用容器所提供的特性，同时对这些进程来说它们就像运行在一起一样，实现两全其美。</p>
<p>pod实际在docker中是docker compose的概念，参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aA4m1w7Ew?spm_id_from=333.788.videopod.sections&vd_source=c97fb1b65102f7ab46e3da7760d19cd0">docker是什么？和kubernetes(k8s)是什么关系？_</a></p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>“Service” 简写 “svc”。Pod 不能直接提供给外网访问，而是应该使用 service。Service 就是把 Pod 暴露出来提供服务，Service 才是真正的“服务”，它的中文名就叫“服务”。</p>
<p>可以说 Service 是一个应用服务的抽象，定义了 Pod 逻辑集合和访问这个 Pod 集合的策略。Service 代理 Pod 集合，对外表现为一个访问入口，访问该入口的请求将经过负载均衡，转发到后端 Pod 中的容器。</p>
<p><strong>类似微服务的eureka和nacos的概念。</strong>nacos负责微服务之间的调用，而service负责k8s集群内节点之间的调用，是横向流量。</p>
<h4 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h4><p>Ingress 是 Kubernetes 的一种管理外部访问应用的资源对象，它允许用户通过一组规则来管理进入集群的 HTTP 和 HTTPS 流量。</p>
<p>Ingress 可以提供外网访问 Service 的能力。可以把某个请求地址映射、路由到特定的 service（ingress-nginx进行路由）。</p>
<p>ingress 需要配合 ingress controller 一起使用才能发挥作用，ingress 只是相当于路由规则的集合而已，真正实现路由功能的，是 Ingress Controller，ingress controller 和其它 k8s 组件一样，也是在 Pod 中运行。</p>
<p>ingress类似nginx进行路由和负载均衡，从用户访问具体服务的时候进行代理、负载均衡、路由跳转等，是纵向流量。</p>
<img src="image-20241022111232484.png" alt="service和ingress" style="zoom:120%;">





<img src="image-20241022113426063.png" style="zoom:150%;">





<h1 id="3-搭建k8s集群"><a href="#3-搭建k8s集群" class="headerlink" title="3. 搭建k8s集群"></a>3. 搭建k8s集群</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>使用centos7.6版本部署k8s。</p>
<table>
<thead>
<tr>
<th>主机名</th>
<th>ip</th>
<th>安装工具</th>
</tr>
</thead>
<tbody><tr>
<td>master（cpu核心数要求大于2）</td>
<td>192.168.88.101</td>
<td>docker、kubeadm、kubelet、kubectl、flannel</td>
</tr>
<tr>
<td>node1</td>
<td>192.168.88.129</td>
<td>docker、kubeadm、kubelet、kubectl、flannel</td>
</tr>
<tr>
<td>node2</td>
<td>192.168.88.103</td>
<td>docker、kubeadm、kubelet、kubectl、flannel</td>
</tr>
</tbody></table>
<p><strong>如果虚拟机是克隆的，ip会一样，需要修改ip地址。</strong></p>
<h3 id="master节点"><a href="#master节点" class="headerlink" title="master节点"></a>master节点</h3><p><strong>关闭防火墙、关闭swap分区，加载 ip_vs 模块，直接全部复制</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久关闭selinux</span></span><br><span class="line">sed -i <span class="string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久关闭swap</span></span><br><span class="line">sed -ri <span class="string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab  </span><br><span class="line"></span><br><span class="line">iptables -F &amp;&amp; iptables -t nat -F &amp;&amp; iptables -t mangle -F &amp;&amp; iptables -X</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(<span class="built_in">ls</span> /usr/lib/modules/$(<span class="built_in">uname</span> -r)/kernel/net/netfilter/ipvs|grep -o <span class="string">&quot;^[^.]*&quot;</span>);<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>; /sbin/modinfo -F filename <span class="variable">$i</span> &gt;/dev/null 2&gt;&amp;1 &amp;&amp; /sbin/modprobe <span class="variable">$i</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p><strong>修改节点ip</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure>

<p>文件添加的内容，此处设置master的ip为192.168.88.101。</p>
<p>子网掩码参考vmware的虚拟网络编辑器（编辑页面打开，选择VMent8后找到NAT设置），想要统一的话可以设置此处的子网掩码和网关，或者用自己的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IPADDR=<span class="string">&quot;192.168.88.101&quot;</span></span><br><span class="line">NETMASK=<span class="string">&quot;255.255.255.0&quot;</span></span><br><span class="line">GATEWAY=<span class="string">&quot;192.168.88.2&quot;</span></span><br><span class="line">DNS1=<span class="string">&quot;192.168.88.2&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src="image-20241022170410255.png"></p>
<p><strong>重启网卡</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>

<p>可以看到ip已经更新了</p>
<p><img src="image-20241022170816212.png"></p>
<p><strong>修改主机名</strong></p>
<p>切换root用户才有修改主机名的权限，su root修改即可，然后执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname k8s-master</span><br></pre></td></tr></table></figure>

<p>执行后使用bash命令刷新一下就行了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br></pre></td></tr></table></figure>



<h3 id="node从节点"><a href="#node从节点" class="headerlink" title="node从节点"></a>node从节点</h3><p>和master同理操作，需要完成主从节点的配置再往下做</p>
<h3 id="所有节点修改hosts文件"><a href="#所有节点修改hosts文件" class="headerlink" title="所有节点修改hosts文件"></a>所有节点修改hosts文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>

<p>打开后添加内容，k8s-master，node1，node2是我给主节点和从节点取的主机名，改成自己取的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.88.101 k8s-master</span><br><span class="line">192.168.88.129 k8s-node1</span><br><span class="line">192.168.88.103 k8s-node2</span><br></pre></td></tr></table></figure>



<h3 id="调整内核参数"><a href="#调整内核参数" class="headerlink" title="调整内核参数"></a>调整内核参数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">#开启网桥模式，可将网桥的流量传递给iptables链</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables=1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables=1</span></span><br><span class="line"><span class="string">#关闭ipv6协议</span></span><br><span class="line"><span class="string">net.ipv6.conf.all.disable_ipv6=1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward=1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sysctl --system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间同步</span></span><br><span class="line">yum install ntpdate -y</span><br><span class="line">ntpte time.windows.comda</span><br></pre></td></tr></table></figure>





<h3 id="其他问题（finalshell无法远程连接VMware）"><a href="#其他问题（finalshell无法远程连接VMware）" class="headerlink" title="其他问题（finalshell无法远程连接VMware）"></a>其他问题（finalshell无法远程连接VMware）</h3><h4 id="VMware中VMnet1或VMnet8-都无法勾选下方的”将主机虚拟适配器连接到此网络“"><a href="#VMware中VMnet1或VMnet8-都无法勾选下方的”将主机虚拟适配器连接到此网络“" class="headerlink" title="VMware中VMnet1或VMnet8 都无法勾选下方的”将主机虚拟适配器连接到此网络“"></a>VMware中VMnet1或VMnet8 都无法勾选下方的”将主机虚拟适配器连接到此网络“</h4><p><img src="image-20241022173548644.png" alt="VMware配置"></p>
<p>参考文档：<a target="_blank" rel="noopener" href="https://blog.csdn.net/MerryMaking7946/article/details/120555787">解决！！！VMware中VMnet1或VMnet8 都无法勾选下方的–” 将主机虚拟适配器连接到此网络“或 勾选成功却安装主机虚拟适配器失败等问题_将主机虚拟适配器连接到此网络无法勾选-CSDN博客</a></p>
<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><p>需要先装docker，后续配置kubeadm、kubelet和kubectl时还需要修改docker的配置文件</p>
<p>这里建议即使装过了也重新装，不用担心镜像丢失</p>
<p>参考博客：<a target="_blank" rel="noopener" href="https://rengoku.top/2024/07/06/centOS%E9%83%A8%E7%BD%B2docker/">CentOS7部署docker</a></p>
<h2 id="所有节点安装kubeadm、kubelet和kubectl"><a href="#所有节点安装kubeadm、kubelet和kubectl" class="headerlink" title="所有节点安装kubeadm、kubelet和kubectl"></a>所有节点安装kubeadm、kubelet和kubectl</h2><h3 id="使用阿里云镜像定义kubernetes源安装镜像"><a href="#使用阿里云镜像定义kubernetes源安装镜像" class="headerlink" title="使用阿里云镜像定义kubernetes源安装镜像"></a>使用阿里云镜像定义kubernetes源安装镜像</h3><p>运行命令前要切换root用户</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义kubernetes源</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum install -y kubelet-1.23.6 kubeadm-1.23.6 kubectl-1.23.6</span><br><span class="line"></span><br><span class="line"><span class="comment">#开机自启kubelet</span></span><br><span class="line"><span class="comment">#K8S通过kubeadm安装出来以后都是以Pod方式存在，即底层是以容器方式运行，所以kubelet必须设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置关闭 Docker 的 cgroups，修改 /etc/docker/daemon.json，加入以下内容。另外请看下文注意事项。</span></span><br><span class="line"><span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 docker</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><p><strong>如果漏掉了docker是无法启动的</strong></p>
<p><img src="image-20241022195939641.png"></p>
<h2 id="部署k8s-master（搭建k8s集群）"><a href="#部署k8s-master（搭建k8s集群）" class="headerlink" title="部署k8s-master（搭建k8s集群）"></a>部署k8s-master（搭建k8s集群）</h2><h3 id="正常部署流程"><a href="#正常部署流程" class="headerlink" title="正常部署流程"></a>正常部署流程</h3><p><strong>注意这里不要清屏，要记录token！！</strong></p>
<p><strong>注意这里不要清屏，要记录token！！</strong></p>
<p><strong>注意这里不要清屏，要记录token！！</strong></p>
<p>master节点运行，注意修改地址为master节点的ip，我的master的ip是<code>192.168.88.101</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">      --apiserver-advertise-address=192.168.88.101 \</span><br><span class="line">      --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">      --kubernetes-version v1.23.6 \</span><br><span class="line">      --service-cidr=10.96.0.0/12 \</span><br><span class="line">      --pod-network-cidr=10.244.0.0/16</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 安装成功后，复制如下配置并执行</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">kubectl get nodes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>1）下载页面</strong></p>
<p><img src="image-20241023102802542.png" alt="下载页面"></p>
<p>安装成功后应该有如下提示：</p>
<p><img src="image-20241023105723531.png" alt="安装成功"></p>
<p><strong>可以看到下载成功后有如下信息，此处需要记录</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.88.101:6443 --token gq4f07.hob8gno3h21g6cr7 \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:2925810701eed275ed43c451336301336be5b435b495a95d145cc5c016ef8be5 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是我第二次初始化的内容，可忽略</span></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.88.101:6443 --token fql59f.yy70z80u0foym5xq \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:e1c6fa61ea4281fe0b57c0b3b740ee90a8a1c2d699c7c168d266b7763a6a5d88</span><br></pre></td></tr></table></figure>

<p><strong>2）运行界面</strong></p>
<p><img src="image-20241023104141122.png" alt="运行界面"></p>
<h3 id="下载失败的解决方案"><a href="#下载失败的解决方案" class="headerlink" title="下载失败的解决方案"></a>下载失败的解决方案</h3><p>类似于如下报错信息：阿里源拉取镜像失败（总之都是由于镜像仓库的问题拉取失败，下边的报错信息并非我亲自遇到的，因为虚拟机的报错信息被刷掉了）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[preflight] Pulling images required <span class="keyword">for</span> setting up a Kubernetes cluster</span><br><span class="line">[preflight] This might take a minute or two, depending on the speed of your internet connection</span><br><span class="line">[preflight] You can also perform this action <span class="keyword">in</span> beforehand using <span class="string">&#x27;kubeadm config images pull&#x27;</span></span><br><span class="line">error execution phase preflight: [preflight] Some fatal errors occurred:</span><br><span class="line">        [ERROR ImagePull]: failed to pull image registry.aliyuncs.com/google_containers/coredns:v1.8.0: output: Error response from daemon: manifest <span class="keyword">for</span> registry.aliyuncs.com/google_containers/coredns:v1.8.0 not found: manifest unknown: manifest unknown</span><br><span class="line">, error: <span class="built_in">exit</span> status 1</span><br><span class="line">[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`</span><br><span class="line">To see the stack trace of this error execute with --v=5 or higher</span><br></pre></td></tr></table></figure>

<p><strong>如果下载失败，这里提供两个解决方案：</strong></p>
<p>第一种，复制命令一直重试，直到下载成功。我用的是这个方案，可能阿里的镜像不稳定。</p>
<p>第二种，失败后查看docker的镜像和kubeadm的镜像，可以看到还差了什么</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看kubeadm所需要镜像</span></span><br><span class="line">kubeadm config images list --kubernetes-version 1.23.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="image-20241023103433741.png" alt="失败"></p>
<p>后续可参考博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a749227859/article/details/118732605">初始化 Kubernetes 主节点 failed to pull image registry.aliyuncs.com&#x2F;google_containers&#x2F;coredns:v1.8.0-CSDN博客</a></p>
<p>主要是使用dokcer再拉取一下缺少的镜像。</p>
<h2 id="加入-Kubernetes-Node（从节点操作）"><a href="#加入-Kubernetes-Node（从节点操作）" class="headerlink" title="加入 Kubernetes Node（从节点操作）"></a>加入 Kubernetes Node（从节点操作）</h2><p>在master安装成功后我们都会有一个token，比如我的是<code>gq4f07.hob8gno3h21g6cr</code>，此处需要修改成自己的token和master的IP。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.88.101:6443 --token gq4f07.hob8gno3h21g6cr7 \</span><br><span class="line">	--discovery-token-ca-cert-hash sha256:2925810701eed275ed43c451336301336be5b435b495a95d145cc5c016ef8be5 </span><br></pre></td></tr></table></figure>

<h3 id="获取Master节点的token和证书"><a href="#获取Master节点的token和证书" class="headerlink" title="获取Master节点的token和证书"></a>获取Master节点的token和证书</h3><p> 如果初始化的 token 不小心清空了，可以通过如下命令获取或者重新申请</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 token 已经过期，就重新申请</span></span><br><span class="line">kubeadm token create</span><br><span class="line"></span><br><span class="line"><span class="comment"># token 没有过期可以通过如下命令获取</span></span><br><span class="line">kubeadm token list</span><br></pre></td></tr></table></figure>

<p>获取 –discovery-token-ca-cert-hash 值，得到值后需要在前面拼接上 sha256</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -pubkey -<span class="keyword">in</span> /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | \</span><br><span class="line">openssl dgst -sha256 -hex | sed <span class="string">&#x27;s/^.* //&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="正常流程"><a href="#正常流程" class="headerlink" title="正常流程"></a>正常流程</h3><p>执行命令：</p>
<p><img src="image-20241023111518529.png"></p>
<p>master节点执行命令<code>kubectl get nodes</code>可以看到node1已经添加成功了</p>
<p><img src="image-20241023111555058.png"></p>
<h2 id="部署-CNI-网络插件（k8s部署flannel）"><a href="#部署-CNI-网络插件（k8s部署flannel）" class="headerlink" title="部署 CNI 网络插件（k8s部署flannel）"></a>部署 CNI 网络插件（k8s部署flannel）</h2><p><img src="image-20241023112331110.png"></p>
<p>为了让三个节点ready起来，三个东西不可少。</p>
<p>文件可以找我要，或者用网盘下载。flannel.tar包解压后用docker把镜像拿到手，解压出来有这些</p>
<p>通过百度网盘分享的文件：k8s部署flannel<br>链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1A_A57YeyTL_mDjQe0ffQOw?pwd=1234">https://pan.baidu.com/s/1A_A57YeyTL_mDjQe0ffQOw?pwd=1234</a><br>提取码：1234</p>
<p><img src="image-20241024135620085.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压文件，解压得到的东西如上图，一个flannel.tar包含flannel.tar,flannel-cni-plugin.tar文件，yml文件不在里面</span></span><br><span class="line">tar -zxvf flannel.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker获取镜像</span></span><br><span class="line">docker load -i flannel.tar</span><br><span class="line">docker load -i flannel-cni-plungin.tar</span><br></pre></td></tr></table></figure>

<p><img src="image-20241024135921585.png"></p>
<p>弄出来以后运行yml文件即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f kube-flannel.yml</span><br></pre></td></tr></table></figure>

<p>三个节点重复上述工作，正常结果如图：</p>
<p><img src="image-20241024140200256.png" alt="flannel部署成功"></p>
<h2 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 两个节点操作</span></span><br><span class="line"><span class="comment"># 1. 将 master 节点中 /etc/kubernetes/admin.conf 拷贝到需要运行的服务器的 /etc/kubernetes 目录中</span></span><br><span class="line">scp /etc/kubernetes/admin.conf root@k8s-node1:/etc/kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 在对应的服务器上配置环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export KUBECONFIG=/etc/kubernetes/admin.conf&quot;</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建部署</span></span><br><span class="line">kubectl create deployment nginx --image=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line">kubectl expose deployment nginx --port=80 --<span class="built_in">type</span>=NodePort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 pod 以及服务信息，如果镜像不是running，需要配镜像</span></span><br><span class="line">kubectl get pod,svc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后续访问虚拟机ip和暴露端口测试nginx是否可以访问，如果不能访问通过命令排查</span></span><br><span class="line"><span class="comment"># 由于docker被墙的原因，我测试基本都是拉取不下来的，如果本地有镜像，可以结合yml文件和镜像创建部署（deploy）</span></span><br><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure>





<h1 id="4-Kubectl命令行工具常用命令"><a href="#4-Kubectl命令行工具常用命令" class="headerlink" title="4. Kubectl命令行工具常用命令"></a>4. Kubectl命令行工具常用命令</h1><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2405730">Kubernetes（K8s）常用命令大全：熟练编排更完美-腾讯云开发者社区-腾讯云</a></p>
<h1 id="5-Pod"><a href="#5-Pod" class="headerlink" title="5. Pod"></a>5. Pod</h1><h2 id="pod配置文件"><a href="#pod配置文件" class="headerlink" title="pod配置文件"></a>pod配置文件</h2><p>基本思路：</p>
<ol>
<li>通过<code>kubectl create  deployment &lt;具体镜像&gt;</code>实现自动创建部署，<strong>deploy部署成功后会自动创建对应pod</strong>。在进行暴露端口后可以根据ip+端口号访问对应服务，这里说的就是上一节进行集群测试的方式；</li>
<li>采用创建yml文件+<code>kubectl apply -f xxx.yml</code>进行创建pod。</li>
</ol>
<p>方式二针对方式一的国内当前无法拉取镜像的问题，yml文件的写法参考第二篇k8s博客。</p>
<p>关于yml文件是否需要手写：在VSCode中提供一个插件kubernetes support，可生成yml文件。</p>
<p>这里提供一份参考的nginx的yml文件：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment"># api 文档版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span>  <span class="comment"># 资源对象类型，也可以配置为像Deployment、StatefulSet这一类的对象</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># Pod 相关的元数据，用于描述 Pod 的数据</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-demo</span> <span class="comment"># Pod 的名称</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment"># 定义 Pod 的标签</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">app</span> <span class="comment"># 自定义 label 标签，名字为 type，值为 app</span></span><br><span class="line">    <span class="attr">test:</span> <span class="number">1.0</span><span class="number">.0</span> <span class="comment"># 自定义 label 标签，描述 Pod 版本号</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">&#x27;default&#x27;</span> <span class="comment"># 命名空间的配置</span></span><br><span class="line"><span class="attr">spec:</span> <span class="comment"># 期望 Pod 按照这里面的描述进行创建</span></span><br><span class="line">  <span class="attr">containers:</span> <span class="comment"># 对于 Pod 中的容器描述</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器的名称</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx:1.18.0</span> <span class="comment"># 指定容器的镜像</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 镜像拉取策略，指定如果本地有就用本地的，如果没有就拉取远程的</span></span><br><span class="line">    <span class="attr">command:</span> <span class="comment"># 指定容器启动时执行的命令</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">-g</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&#x27;daemon off;&#x27;</span> <span class="comment"># nginx -g &#x27;daemon off;&#x27;</span></span><br><span class="line">    <span class="attr">workingDir:</span> <span class="string">/usr/share/nginx/html</span> <span class="comment"># 定义容器启动后的工作目录</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span> <span class="comment"># 端口名称</span></span><br><span class="line">      <span class="attr">containerPort:</span> <span class="number">80</span> <span class="comment"># 描述容器内要暴露什么端口</span></span><br><span class="line">      <span class="attr">protocol:</span> <span class="string">TCP</span> <span class="comment"># 描述该端口是基于哪种协议通信的</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">env:</span> <span class="comment"># 环境变量</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">JVM_OPTS</span> <span class="comment"># 环境变量名称</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&#x27;-Xms128m -Xmx128m&#x27;</span> <span class="comment"># 环境变量的值</span></span><br><span class="line">    <span class="attr">reousrces:</span></span><br><span class="line">      <span class="attr">requests:</span> <span class="comment"># 最少需要多少资源</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">100m</span> <span class="comment"># 限制 cpu 最少使用 0.1 个核心</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">128Mi</span> <span class="comment"># 限制内存最少使用 128兆</span></span><br><span class="line">      <span class="attr">limits:</span> <span class="comment"># 最多可以用多少资源</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">200m</span> <span class="comment"># 限制 cpu 最多使用 0.2 个核心</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">256Mi</span> <span class="comment"># 限制 最多使用 256兆</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span> <span class="comment"># 重启策略，只有失败的情况才会重启</span></span><br></pre></td></tr></table></figure>



<h2 id="探针技术"><a href="#探针技术" class="headerlink" title="探针技术"></a>探针技术</h2><h3 id="StartupProbe（容器启动前）"><a href="#StartupProbe（容器启动前）" class="headerlink" title="StartupProbe（容器启动前）"></a>StartupProbe（容器启动前）</h3><p>k8s 1.16 版本新增的探针，用于判断应用程序是否已经启动了。</p>
<p>当配置了 startupProbe 后，会先禁用其他探针，直到 startupProbe 成功后，其他探针才会继续。</p>
<p>作用：由于有时候不能准确预估应用一定是多长时间启动成功，因此配置另外两种方式不方便配置初始化时长来检测，而配置了 statupProbe 后，只有在应用启动成功了，才会执行另外两种探针，可以更加方便的结合使用另外两种探针使用。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">startupProbe:</span></span><br><span class="line"> <span class="attr">httpGet:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/api/startup</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<h3 id="LivenessProbe（容器启动后）"><a href="#LivenessProbe（容器启动后）" class="headerlink" title="LivenessProbe（容器启动后）"></a>LivenessProbe（容器启动后）</h3><p>用于去探测容器运行时是否挂掉，挂掉则进行重启操作，即：如果探测失败，kubelet 会根据配置的重启策略进行重启，若没有配置，默认就认为容器启动成功，不会执行重启策略。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line"> <span class="attr">failureThreshold:</span> <span class="number">5</span></span><br><span class="line"> <span class="attr">httpGet:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/health</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line"> <span class="attr">initialDelaySeconds:</span> <span class="number">60</span></span><br><span class="line"> <span class="attr">periodSeconds:</span> <span class="number">10</span></span><br><span class="line"> <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line"> <span class="attr">timeoutSeconds:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>



<h3 id="ReadinessProbe（容器启动后）"><a href="#ReadinessProbe（容器启动后）" class="headerlink" title="ReadinessProbe（容器启动后）"></a>ReadinessProbe（容器启动后）</h3><p>用于探测容器内的程序是否健康，它的返回值如果返回 success，那么就认为该容器已经完全启动，并且该容器是可以接收外部流量的（成功后才允许外部发送请求）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">readinessProbe:</span></span><br><span class="line"> <span class="attr">failureThreshold:</span> <span class="number">3</span> <span class="comment"># 错误次数</span></span><br><span class="line"> <span class="attr">httpGet:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">/ready</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8181</span></span><br><span class="line">  <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line"> <span class="attr">periodSeconds:</span> <span class="number">10</span> <span class="comment"># 间隔时间</span></span><br><span class="line"> <span class="attr">successThreshold:</span> <span class="number">1</span></span><br><span class="line"> <span class="attr">timeoutSeconds:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>





<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lifecycle:</span><br><span class="line"> postStart: <span class="comment"># 容器创建完成后执行的动作，不能保证该操作一定在容器的 command 之前执行，一般不使用</span></span><br><span class="line">  <span class="built_in">exec</span>: <span class="comment"># 可以是 exec / httpGet / tcpSocket</span></span><br><span class="line">   <span class="built_in">command</span>:</span><br><span class="line">    - sh</span><br><span class="line">    - -c</span><br><span class="line">    - <span class="string">&#x27;mkdir /data&#x27;</span></span><br><span class="line"> preStop: <span class="comment"># 在容器停止前执行的动作</span></span><br><span class="line">  httpGet: <span class="comment"># 发送一个 http 请求</span></span><br><span class="line">   path: /</span><br><span class="line">   port: 80</span><br><span class="line">  <span class="built_in">exec</span>: <span class="comment"># 执行一个命令</span></span><br><span class="line">   <span class="built_in">command</span>:</span><br><span class="line">    - sh</span><br><span class="line">    - -c</span><br><span class="line">    - <span class="built_in">sleep</span> 9</span><br></pre></td></tr></table></figure>



<h1 id="6-资源调度"><a href="#6-资源调度" class="headerlink" title="6. 资源调度"></a>6. 资源调度</h1><h2 id="label和selector"><a href="#label和selector" class="headerlink" title="label和selector"></a>label和selector</h2><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><p>当我们给一组对象，比如有10个pod，打上了不同的标签之后，当我们要选择其中的部分，或者全部作为使用目标的时候，就可以使用label selector来实现这个操作，标签选择器中指定具体的过滤的条件，然后，就能在10个pod中过滤出满足我们要求的这些po</p>
<p>在yml文件中可以设置label（往上翻），临时添加也可以通过kubectl命令实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看pods的label</span></span><br><span class="line">kubectl get po --show-labels</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加临时的label</span></span><br><span class="line">kubectl label po &lt;资源名称&gt; app=hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重写添加临时的label</span></span><br><span class="line">kubectl label po &lt;资源名称&gt; app=hello --overwrite</span><br></pre></td></tr></table></figure>

<h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><p>在各对象的配置 spec.selector 或其他可以写 selector 的属性中编写，应用于selector匹配label</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配单个值，查找 app=hello 的 pod</span></span><br><span class="line">kubectl get po -A -l app=hello</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配多个值</span></span><br><span class="line">kubectl get po -A -l <span class="string">&#x27;k8s-app in (metrics-server, kubernetes-dashboard)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 version!=1 and app=nginx 的 pod 信息，条件是and的关系而不是or的关系</span></span><br><span class="line">kubectl get po -l version!=1,app=nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不等值 + 语句</span></span><br><span class="line">kubectl get po -A -l version!=1,<span class="string">&#x27;app in (busybox, nginx)&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="deployment"><a href="#deployment" class="headerlink" title="deployment"></a>deployment</h2><p>deployment &#x3D;&gt; ReplicaSet &#x3D;&gt; Pod，一个部署存在一个副本管理和多个pod</p>
<p>创建、更新、回滚、暂停更新略</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span> <span class="comment"># deployment api 版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span> <span class="comment"># 资源类型为 deployment</span></span><br><span class="line"><span class="attr">metadata:</span> <span class="comment"># 元信息</span></span><br><span class="line">  <span class="attr">labels:</span> <span class="comment"># 标签</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-deploy</span> <span class="comment"># 具体的 key: value 配置形式</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span> <span class="comment"># deployment 的名字</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span> <span class="comment"># 所在的命名空间</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span> <span class="comment"># 期望副本数</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span> <span class="comment"># 进行滚动更新后，保留的历史版本数</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选择器，用于找到匹配的 RS</span></span><br><span class="line">    <span class="attr">matchLabels:</span> <span class="comment"># 按照标签匹配</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx-deploy</span> <span class="comment"># 匹配的标签key/value</span></span><br><span class="line">  <span class="attr">strategy:</span> <span class="comment"># 更新策略</span></span><br><span class="line">    <span class="attr">rollingUpdate:</span> <span class="comment"># 滚动更新配置</span></span><br><span class="line">      <span class="attr">maxSurge:</span> <span class="number">25</span><span class="string">%</span> <span class="comment"># &quot;max Surge&quot; 设置为 25%，表示可以同时启动最多 25% 的新实例；</span></span><br><span class="line">      <span class="attr">maxUnavailable:</span> <span class="number">25</span><span class="string">%</span> <span class="comment"># &quot;max Unavailable&quot; 设置为 25%，表示可以同时停止最多 25% 的旧实例</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">RollingUpdate</span> <span class="comment"># 更新类型，采用滚动更新</span></span><br><span class="line">  <span class="attr">template:</span> <span class="comment"># pod 模板</span></span><br><span class="line">    <span class="attr">metadata:</span> <span class="comment"># pod 的元信息</span></span><br><span class="line">      <span class="attr">labels:</span> <span class="comment"># pod 的标签</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx-deploy</span></span><br><span class="line">    <span class="attr">spec:</span> <span class="comment"># pod 期望信息</span></span><br><span class="line">      <span class="attr">containers:</span> <span class="comment"># pod 的容器</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.7.9</span> <span class="comment"># 镜像</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 拉取策略</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span> <span class="comment"># 容器名称</span></span><br><span class="line">      <span class="attr">restartPolicy:</span> <span class="string">Always</span> <span class="comment"># 重启策略</span></span><br><span class="line">      <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span> <span class="comment"># 删除操作最多宽限多长时间</span></span><br></pre></td></tr></table></figure>

<h2 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h2><p>pv：存储卷</p>
<p>pvc：pv和pod之间的组件，即：volumeClaimTemplate</p>
<p>sts：StatefulSet的缩写</p>
<p>svc：service，即：Headless Service</p>
<h3 id="创建于扩缩容"><a href="#创建于扩缩容" class="headerlink" title="创建于扩缩容"></a>创建于扩缩容</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">  <span class="attr">clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web</span> <span class="comment"># 使用哪个service管理dns，跳转服务发现</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">serviceName:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">          <span class="attr">name:</span> <span class="string">web</span></span><br><span class="line">        <span class="attr">volumeMounts:</span> <span class="comment"># 挂载的数据卷</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">          <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">  <span class="string">volumeClaimTemplates:#</span> <span class="string">pvc</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">volume.alpha.kubernetes.io/storage-class:</span> <span class="string">anything</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">accessModes:</span> [ <span class="string">&quot;ReadWriteOnce&quot;</span> ]</span><br><span class="line">      <span class="attr">resources:</span></span><br><span class="line">        <span class="attr">requests:</span></span><br><span class="line">          <span class="attr">storage:</span> <span class="string">1Gi</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 扩容</span></span><br><span class="line">kubectl scale statefulset web --replicas=5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩容</span></span><br><span class="line">kubectl patch statefulset web -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;replicas&quot;:3&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><p>选择一部分用户体验新版本，如果没问题再全量推。相当于打游戏的时候受邀参加新版本的体验服，如果体验服机制过于三体人设计或者莫名其妙的bug，就进行修复，修复完成至无bug或机制平衡后再上线正式服。</p>
<p>利用滚动更新中的 partition 属性，可以实现简易的灰度发布的效果</p>
<p>例如我们有 5 个 pod，如果当前 partition 设置为 3，那么此时滚动更新时，只会更新那些 序号 &gt;&#x3D; 3 的 pod</p>
<p>利用该机制，我们可以通过控制 partition 的值，来决定只更新其中一部分 pod，确认没有问题后再主键增大更新的 pod 数量，最终实现全部 pod 更新</p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 StatefulSet 和 Headless Service</span></span><br><span class="line"><span class="comment"># 级联删除：删除 statefulset 时会同时删除 pods</span></span><br><span class="line">kubectl delete statefulset web</span><br><span class="line"><span class="comment"># 非级联删除：删除 statefulset 时不会删除 pods，删除 sts 后，pods 就没人管了，此时再删除 pod 不会重建的</span></span><br><span class="line">kubectl deelte sts web --cascade=<span class="literal">false</span></span><br><span class="line"><span class="comment"># 删除 service</span></span><br><span class="line">kubectl delete service nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># StatefulSet删除后PVC还会保留着，数据不再使用的话也需要删除</span></span><br><span class="line">kubectl delete pvc www-web-0 www-web-1</span><br></pre></td></tr></table></figure>





<h2 id="HAP自动扩缩容"><a href="#HAP自动扩缩容" class="headerlink" title="HAP自动扩缩容"></a>HAP自动扩缩容</h2><p>略</p>
<h1 id="7-服务发布"><a href="#7-服务发布" class="headerlink" title="7. 服务发布"></a>7. 服务发布</h1><h2 id="service-1"><a href="#service-1" class="headerlink" title="service"></a>service</h2><h3 id="外部访问pod"><a href="#外部访问pod" class="headerlink" title="外部访问pod"></a>外部访问pod</h3><p>在使用<code>kubectl create deployment &lt;deploy-name&gt;</code>命令进行部署时，是可以看到deploy会自动创建pod和service，而service在自动创建出来的时候会自带一个endpoint。</p>
<p>参考内容：<a target="_blank" rel="noopener" href="https://blog.csdn.net/AZNwangmou/article/details/130686686">k8s四层负载均衡之Service_kubectl service与node负载均-CSDN博客</a></p>
<p>大致流程：service &#x3D;&gt; endpoint &#x3D;&gt; pod，service找到对应的endpoint后，endpoint通过记录ip和Kube-proxy路由到pod进行提供pod中记录的服务。</p>
<p><img src="image-20241028115407594.png"></p>
<blockquote>
<p>为什么可以通过虚拟机ip+端口号访问到pod提供的服务？</p>
</blockquote>
<p><strong>在k8s中存在的ip类型有三种：</strong></p>
<ol>
<li>节点网络，即虚拟机ip；</li>
<li>pod的ip；</li>
<li>service的ip。</li>
</ol>
<p><strong>service的类型：</strong></p>
<ol>
<li><strong>ClusterIP 类型</strong>：<ul>
<li>如果 Service 是 <code>ClusterIP</code> 类型，你只能在集群内部访问它。尝试从集群外部访问会失败，因为 <code>ClusterIP</code> 不会路由到集群外部的流量。</li>
</ul>
</li>
<li><strong>NodePort 类型</strong>：<ul>
<li>如果 Service 是 <code>NodePort</code> 类型，你可以从集群外部通过任意节点的 IP 地址加上指定的 NodePort 端口号来访问 Service。例如，如果 NodePort 是 30001，你可以访问 <code>&lt;NodeIP&gt;:30001</code> 来访问 Service。</li>
</ul>
</li>
<li><strong>LoadBalancer 类型</strong>：<ul>
<li>如果 Service 是 <code>LoadBalancer</code> 类型，并且你正在云服务提供商的环境中运行 Kubernetes 集群，那么通常会有一个外部负载均衡器被创建并分配一个公共 IP 地址。你可以通过这个公共 IP 地址加上 Service 的端口号从集群外部访问 Service。</li>
</ul>
</li>
<li><strong>ExternalName 类型</strong>：<ul>
<li>如果 Service 是 <code>ExternalName</code> 类型，直接访问 Service 的 IP 和端口可能不会按预期工作，因为 <code>ExternalName</code> 类型的 Service 主要是通过 DNS CNAME 记录来将请求转发到一个外部的服务。没有相应的 DNS 配置，直接访问 IP 和端口可能不会有任何响应。</li>
</ul>
</li>
</ol>
<p>当我们使用<code>kubectl create deployment &lt;deploy-name&gt;</code>的时候，还需要向外暴露一个端口，才能访问到service或者是k8s集群内部。除了在yml文件中指定service的类型，也可以使用expose命令进行向外暴露端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kubectl expose deployment &lt;deployment-name&gt; --port=80 --target-port=9376 --<span class="built_in">type</span>=NodePort</span><br></pre></td></tr></table></figure>

<p>由于是向外暴露端口，所以必须指定类型为NodePort。如果不指定类型，则默认采用的是clusterIP，此时不会向外提供服务，也就是说，NodePort类型可以采用虚拟机ip+向外暴露的端口进行访问pod，而后者则无法通过外部进行访问。</p>
<p>假设我的虚拟机ip为192.168.88.101，则此时访问192.168.88.101:9376是可以拿到对应服务的。</p>
<p>上边提到的是使用kubectl进行向外暴露的方式，第二种也可以通过给deployment指定service进行向外暴露。此时labels.app的标签需要对应上deployment的标签。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-svc</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx-svc</span> <span class="comment"># service自己的标签</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span> <span class="comment"># 指定service的类型</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">web</span> <span class="comment"># service 端口配置的名称</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">TCP</span> <span class="comment"># 端口绑定的协议，支持 TCP、UDP、SCTP，默认为 TCP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">80</span> <span class="comment"># service 自己的端口,只能通过内网的ip加此端口才能访问到service服务</span></span><br><span class="line">    <span class="attr">targetPort:</span> <span class="number">9527</span> <span class="comment"># 目标 pod 的端口</span></span><br><span class="line">  <span class="attr">selector:</span> <span class="comment"># 选中当前 service 匹配哪些 pod，对哪些 pod 的东西流量进行代理</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>



<h3 id="pod访问外部服务"><a href="#pod访问外部服务" class="headerlink" title="pod访问外部服务"></a>pod访问外部服务</h3><p>为什么需要pod访问外部服务？</p>
<p>在 Kubernetes 集群中，Pod 访问外部服务是一个常见的需求，尤其是在需要连接到集群外部的数据库或 API 服务时。</p>
<p><strong>实现方式：</strong></p>
<p>编写 service 配置文件时，不指定 selector 属性，此时不会自动生成endpoint，自己创建 endpoint时指定需要访问的服务ip；或者是使用externalname指定访问的域名。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># endpoint 配置：</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">labels:</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">wolfcode-svc-external</span> <span class="comment"># 与 service 一致</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">wolfcode-svc-external</span> <span class="comment"># 与 service 一致</span></span><br><span class="line"> <span class="attr">namespace:</span> <span class="string">default</span> <span class="comment"># 与 service 一致</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">addresses:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">ip:</span> <span class="string">&lt;target</span> <span class="string">ip&gt;</span> <span class="comment"># 目标 ip 地址</span></span><br><span class="line"> <span class="attr">ports:</span> <span class="comment"># 与 service 一致</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">  <span class="attr">protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure>



<h2 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h2><h3 id="部署ingress-nginx"><a href="#部署ingress-nginx" class="headerlink" title="部署ingress-nginx"></a>部署ingress-nginx</h3><p>参考文档：<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">Ingress | Kubernetes</a></p>
<p><strong>首先安装ingress：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 任意目录下载helm，用魔法</span></span><br><span class="line">wget https://get.helm.sh/helm-v3.2.3-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf helm-v3.2.3-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> linux-amd64/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制文件到所需目录下</span></span><br><span class="line"><span class="built_in">cp</span> helm /usr/local/bin/helm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本，显示版本代表成功</span></span><br><span class="line">helm version</span><br></pre></td></tr></table></figure>

<p><strong>安装nginx-ingress：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加仓库</span></span><br><span class="line">helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看仓库列表</span></span><br><span class="line">helm repo list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索 ingress-nginx，这是k8s可下载的软件</span></span><br><span class="line">helm search repo ingress-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载安装包，注意ingress nginx和k8s要求有版本对应，此处k8s版本为1.23.6，ingress nginx版本为4.4.2</span></span><br><span class="line">helm pull ingress-nginx/ingress-nginx --version=4.4.2</span><br></pre></td></tr></table></figure>

<p>下载包时如果安装失败可以尝试直接在浏览器下载，然后再用finalshell上传文件</p>
<p><img src="image-20241028151815655.png"></p>
<p>浏览器访问：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/kubernetes/ingress-nginx/releases/download/helm-chart-4.4.2/ingress-nginx-4.4.2.tgz">https://github.com/kubernetes/ingress-nginx/releases/download/helm-chart-4.4.2/ingress-nginx-4.4.2.tgz</a></p>
<p><img src="image-20241028152422365.png"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf ingress-nginx-4.4.2.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> ingress-nginx</span><br></pre></td></tr></table></figure>

<p>ingress-nginx目录下有values.yaml文件，打开它修改配置</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改 values.yaml</span></span><br><span class="line"><span class="comment"># 镜像地址：修改为国内镜像</span></span><br><span class="line"><span class="comment"># nginx-ingress修改：</span></span><br><span class="line"><span class="attr">registry:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">google_containers/nginx-ingress-controller</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释掉nginx-ingress下的digest校验和digestChroot</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># kube-webhook修改</span></span><br><span class="line"><span class="attr">registry:</span> <span class="string">registry.cn-hangzhou.aliyuncs.com</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">google_containers/kube-webhook-certgen</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释掉kube-webhook下的digest校验</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改kube-webhook版本</span></span><br><span class="line"><span class="attr">tag:</span> <span class="string">v1.5.1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">hostNetwork:</span> <span class="literal">true</span> <span class="comment"># 文档89行</span></span><br><span class="line"><span class="attr">dnsPolicy:</span> <span class="string">ClusterFirstWithHostNet</span> <span class="comment"># 文档66行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改部署配置的 kind: DaemonSet，文档194行</span></span><br><span class="line"><span class="comment"># 添加配置</span></span><br><span class="line"><span class="attr">nodeSelector:</span></span><br><span class="line">  <span class="attr">ingress:</span> <span class="string">&quot;true&quot;</span> <span class="comment"># 增加选择器，如果 node 上有 ingress=true 就部署，文档877行</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 将admissionWebhooks.enabled 修改为 false，607行</span></span><br><span class="line"><span class="comment"># 将service 中的 type 由 LoadBalancer 修改为 ClusterIP（508行），如果服务器是云平台才用 LoadBalancer</span></span><br></pre></td></tr></table></figure>

<p>打开bash控制台，假设在master节点配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为 ingress 专门创建一个 namespace</span></span><br><span class="line">kubectl create ns ingress-nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为需要部署 ingress 的节点上加标签</span></span><br><span class="line">kubectl label node k8s-master ingress=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行命令</span></span><br><span class="line">helm repo update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 ingress-nginx，需要进入有values.yml文件的目录下执行</span></span><br><span class="line">helm install ingress-nginx -n ingress-nginx .</span><br></pre></td></tr></table></figure>



<h1 id="8-配置管理、持久化存储"><a href="#8-配置管理、持久化存储" class="headerlink" title="8. 配置管理、持久化存储"></a>8. 配置管理、持久化存储</h1><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><h3 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h3><p><strong>为什么deployment还需要configmap进行配置管理</strong></p>
<ol>
<li>进行配置与代码分离</li>
<li>在配置经常需要修改的情况下，修改configmap可以避免重新部署deployment</li>
<li>减少构建镜像的次数</li>
<li>支持动态更新，无需停止pod进行配置更新</li>
</ol>
<p><strong>创建ConfigMap</strong></p>
<p>通过<code>kubectl create cm -h</code> 查看创建方式</p>
<p><img src="image-20241028172214555.png"></p>
<p><strong>使用configmap：</strong></p>
<p>假设存在cm的配置如下：此处已经配置db.properties和redis.properties的账号密码</p>
<p><img src="image-20241029115139290.png" alt="configmap"></p>
<p>然后再编写pod.yml文件</p>
<p><img src="image-20241029114708124.png" alt="pod的yml配置"></p>
<p>执行命令apply命令去创建pod</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kubectl apply -f pod.yml</span><br></pre></td></tr></table></figure>

<p>此时进入容器内查看后挂载的数据卷，可以看到确实有内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kucectl <span class="built_in">exec</span> -it &lt;pod容器名&gt; --sh</span><br></pre></td></tr></table></figure>

<p><img src="image-20241029114836936.png" alt="进入容器内部后查看文件"></p>
<h3 id="加密（软加密）配置secret"><a href="#加密（软加密）配置secret" class="headerlink" title="加密（软加密）配置secret"></a>加密（软加密）配置secret</h3><p><strong>创建secret</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看创建方式</span></span><br><span class="line">kubectl create secret -h</span><br></pre></td></tr></table></figure>

<p><strong>使用secret：</strong></p>
<p>基于服务器的harbor去创建secret</p>
<p><img src="image-20241029114219142.png"></p>
<p>pod通过使用secret连接harbor，从harbor拉取镜像</p>
<p><img src="image-20241029114047848.png"></p>
<h4 id="SubPath"><a href="#SubPath" class="headerlink" title="SubPath"></a>SubPath</h4><p>使用 ConfigMap 或 Secret 挂载到目录的时候，会将容器中源目录给覆盖掉，此时我们可能只想覆盖目录中的某一个文件，但是这样的操作会覆盖整个文件，因此需要使用到 SubPath</p>
<p>配置方式：</p>
<ol>
<li>定义 volumes 时需要增加 items 属性，配置 key 和 path，且 path 的值不能从 &#x2F; 开始</li>
<li>在容器内的 volumeMounts 中增加 subPath 属性，该值与 volumes 中 items.path 的值相同</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"> <span class="string">......</span></span><br><span class="line"> <span class="attr">volumeMounts:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/nginx/nginx.conf</span> <span class="comment"># 挂载到哪里</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">config-volume</span> <span class="comment"># 使用哪个 configmap 或 secret</span></span><br><span class="line">  <span class="attr">subPath:</span> <span class="string">etc/nginx/nginx.conf</span> <span class="comment"># 指定了要从 ConfigMap 中挂载的具体文件或子路径。这里的 subPath 表示将 ConfigMap 中的文件内容挂载到容器的指定路径，而不是整个 ConfigMap。</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">nginx-conf</span> <span class="comment"># configMap 名字</span></span><br><span class="line"> <span class="attr">items:</span> <span class="comment"># subPath 配置</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">nginx.conf</span> <span class="comment"># configMap 中的文件名</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">etc/nginx/nginx.conf</span> <span class="comment"># 指定了卷内的路径，这个路径与 subPath 相匹配。这意味着 ConfigMap 中的 nginx.conf 键对应的数据将被挂载到容器的 /etc/nginx/nginx.conf 路径下。</span></span><br></pre></td></tr></table></figure>



<h2 id="持久化存储"><a href="#持久化存储" class="headerlink" title="持久化存储"></a>持久化存储</h2><h3 id="HostPath"><a href="#HostPath" class="headerlink" title="HostPath"></a>HostPath</h3><p>将节点上的文件或目录挂载到 Pod 上，此时该目录会变成持久化存储目录，即使 Pod 被删除后重启，也可以重新加载到该目录，该目录下的文件不会丢失；之前的configmap是k8s内集群文件挂载到容器内部的目录，而现在是直接关联宿主机的文件。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-volume</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 镜像拉取策略，指定如果本地有就用本地的，如果没有就拉取远程的</span></span><br><span class="line">  <span class="attr">volumeMounts:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/test-pd</span> <span class="comment"># 挂载到容器的哪个目录</span></span><br><span class="line">   <span class="attr">name:</span> <span class="string">test-volume</span> <span class="comment"># 挂载哪个 volume</span></span><br><span class="line"> <span class="attr">volumes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">   <span class="attr">path:</span> <span class="string">/data</span> <span class="comment"># 节点中的目录</span></span><br><span class="line">   <span class="attr">type:</span> <span class="string">Directory</span> <span class="comment"># 检查类型，在挂载前对挂载目录做什么检查操作，有多种选项，默认为空字符串，不做任何检查</span></span><br></pre></td></tr></table></figure>

<p>在configmap中，volumes指定名字后接下来写的是 “-configmap”的配置，而这里是hostpath。</p>
<p><strong>检查类型</strong>：</p>
<ol>
<li>空字符串：默认类型，不做任何检查</li>
<li>DirectoryOrCreate：如果给定的 path 不存在，就创建一个 755 的空目录</li>
<li>Directory：这个目录必须存在</li>
<li>FileOrCreate：如果给定的文件不存在，则创建一个空文件，权限为 644</li>
<li>File：这个文件必须存在</li>
<li>Socket：UNIX 套接字，必须存在</li>
<li>CharDevice：字符设备，必须存在</li>
<li>BlockDevice：块设备，必须存在</li>
</ol>
<h3 id="EmptyDir"><a href="#EmptyDir" class="headerlink" title="EmptyDir"></a>EmptyDir</h3><p>EmptyDir应用于一个pod中有多个容器运行时的时候，做容器运行时之间的文件共享，在yaml文件中指定“emptyDir: {}”即可，因为不需要添加任何数据进目录或文件中，只需要达到一个文件共享的目的。当 Pod 被删除时， emptyDir 也会被删除。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-container</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">my-image</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-emptydir</span></span><br><span class="line">      <span class="attr">mountPath:</span> <span class="string">/data</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-emptydir</span></span><br><span class="line">    <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="NFS"><a href="#NFS" class="headerlink" title="NFS"></a>NFS</h3><p>作用于不在同一个pod中的容器运行时共享数据（可以用HostPath）或是不同服务器的容器运行时共享数据。</p>
<h4 id="安装NFS"><a href="#安装NFS" class="headerlink" title="安装NFS"></a>安装NFS</h4><p><strong>Node1安装NFS：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 nfs</span></span><br><span class="line">yum install nfs-utils -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 nfs</span></span><br><span class="line">systemctl start nfs-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 nfs 版本</span></span><br><span class="line"><span class="built_in">cat</span> /proc/fs/nfsd/versions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建共享目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/k8s/nfs</span><br><span class="line"><span class="built_in">cd</span> /opt/k8s/nfs</span><br><span class="line"><span class="built_in">mkdir</span> rw</span><br><span class="line"><span class="built_in">mkdir</span> ro</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置共享目录 export，限制在88网段内可连接。</span></span><br><span class="line">vim /etc/exports</span><br><span class="line">/opt/k8s/nfs/rw 192.168.88.0/24(rw,<span class="built_in">sync</span>,no_subtree_check,no_root_squash)</span><br><span class="line">/opt/k8s/nfs/ro 192.168.88.0/24(ro,<span class="built_in">sync</span>,no_subtree_check,no_root_squash)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载</span></span><br><span class="line">exportfs -f</span><br><span class="line">systemctl reload nfs-server</span><br></pre></td></tr></table></figure>

<p>此时在只读文件中添加一个文件：</p>
<p><img src="image-20241029160721723.png" alt="只读文件Readme.md"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 到其他测试节点安装 nfs-utils 并加载测试</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mnt/nfs/rw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将192.168.88.129节点（本篇博客的node1对应的ip地址）下的/opt/k8s/nfs/rw挂载当前节点（我用的是master）的/mnt/nfs/rw目录下</span></span><br><span class="line">mount -t nfs 192.168.88.129:/opt/k8s/nfs/rw /mnt/nfs/rw</span><br></pre></td></tr></table></figure>

<p>在node1里面创建一个文件，然后输入内容：after nfs , node1 and master get connetion.</p>
<p><img src="image-20241029161544982.png"></p>
<p>返回master节点后发现已经自动添加文件，说明建立连接成功</p>
<p><img src="image-20241029161655677.png"></p>
<p>同理可以挂载只读目录ro</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs 192.168.88.129:/opt/k8s/nfs/ro /mnt/nfs/ro</span><br></pre></td></tr></table></figure>

<p><img src="image-20241029162405548.png"></p>
<h4 id="NFS配置文件"><a href="#NFS配置文件" class="headerlink" title="NFS配置文件"></a>NFS配置文件</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">test-pd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx:1.18.0</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">test-container</span></span><br><span class="line">    <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span> <span class="comment"># 镜像拉取策略，指定如果本地有就用本地的，如果没有就拉取远程的</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/usr/share/nginx/html</span> <span class="comment"># pod容器内的存储目录</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test-volume</span></span><br><span class="line">    <span class="attr">nfs:</span></span><br><span class="line">      <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.129</span> <span class="comment"># 网络存储服务地址</span></span><br><span class="line">      <span class="attr">path:</span> <span class="string">/opt/k8s/nfs/rw</span> <span class="comment"># 网络存储路径</span></span><br><span class="line">      <span class="attr">readOnly:</span> <span class="literal">false</span> <span class="comment"># 是否只读</span></span><br></pre></td></tr></table></figure>



<h3 id="PV与PVC"><a href="#PV与PVC" class="headerlink" title="PV与PVC"></a>PV与PVC</h3><h4 id="PV与PVC-1"><a href="#PV与PVC-1" class="headerlink" title="PV与PVC"></a>PV与PVC</h4><p><strong>持久卷（PersistentVolume，PV）</strong> 是集群中的一块存储，可以由管理员事先制备， 或者使用<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/">存储类（Storage Class）</a>来动态制备。 持久卷是集群资源，就像节点也是集群资源一样。PV 持久卷和普通的 Volume 一样， 也是使用卷插件来实现的，只是它们拥有独立于任何使用 PV 的 Pod 的生命周期。 此 API 对象中记述了存储的实现细节，无论其背后是 NFS、iSCSI 还是特定于云平台的存储系统。</p>
<p><strong>持久卷申领（PersistentVolumeClaim，PVC）</strong> 表达的是用户对存储的请求。概念上与 Pod 类似。 Pod 会耗用节点资源，而 PVC 申领会耗用 PV 资源。Pod 可以请求特定数量的资源（CPU 和内存）；同样 PVC 申领也可以请求特定的大小和访问模式 （例如，可以要求 PV 卷能够以 ReadWriteOnce、ReadOnlyMany 或 ReadWriteMany 模式之一来挂载，参见<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/#access-modes">访问模式</a>）。</p>
<p>参考内容：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/347526819">k8s之PV、PVC、StorageClass详解</a>、<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/">存储类 | Kubernetes</a></p>
<p><img src="image-20241029174539077.png"></p>
<blockquote>
<p>为什么需要pv和pvc</p>
</blockquote>
<ol>
<li>存储持久化，在pod销毁或重建后不希望数据被销毁，而pv和pvc独立于pod，因此可以实现持久化；</li>
<li>通过定义回收策略可以定义数据资源的生命周期；</li>
<li>动态存储供应，可以设置特定大小供pv访问pvc；</li>
<li>提供多种存储类型的支持，如本地磁盘、NFS、云存储</li>
</ol>
<blockquote>
<p>实现pv和pvc</p>
</blockquote>
<p><strong>创建pv，pv的yaml文件：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">pv0001</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span> <span class="comment"># pv 的容量</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span> <span class="comment"># 存储类型为文件系统</span></span><br><span class="line">  <span class="attr">accessModes:</span> <span class="comment"># 访问模式：ReadWriteOnce、ReadWriteMany、ReadOnlyMany</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span> <span class="comment"># 可被单节点独写</span></span><br><span class="line">  <span class="attr">persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span> <span class="comment"># 回收策略</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">slow</span> <span class="comment"># 创建 PV 的存储类名，需要与 pvc 的相同</span></span><br><span class="line">  <span class="attr">mountOptions:</span> <span class="comment"># 加载配置</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">hard</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">nfsvers=4.1</span></span><br><span class="line">  <span class="attr">nfs:</span> <span class="comment"># 连接到 nfs</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/opt/k8s/nfs/rw/test-pv</span> <span class="comment"># 存储路径</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">192.168</span><span class="number">.88</span><span class="number">.129</span> <span class="comment"># nfs 服务地址</span></span><br></pre></td></tr></table></figure>



<p><strong>创建pvc，pvc的yaml文件：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nfs-pvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span> <span class="comment"># 权限需要与对应的 pv 相同</span></span><br><span class="line">  <span class="attr">volumeMode:</span> <span class="string">Filesystem</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">8Gi</span> <span class="comment"># 资源可以小于 pv 的，但是不能大于，如果大于就会匹配不到 pv</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">slow</span> <span class="comment"># 名字需要与对应的 pv 相同</span></span><br><span class="line"><span class="comment">#  selector: # 使用选择器选择对应的 pv</span></span><br><span class="line"><span class="comment">#    matchLabels:</span></span><br><span class="line"><span class="comment">#      release: &quot;stable&quot;</span></span><br><span class="line"><span class="comment">#    matchExpressions:</span></span><br><span class="line"><span class="comment">#      - &#123;key: environment, operator: In, values: [dev]&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>kubectl apply -f  pvc.yml</code>和<code>kubectl apply -f  pv.yml</code>创建对应资源，由于storageClassName是一致的，此时pv和pvc已经完成绑定</p>
<p><strong>绑定pod和pvc</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 pod 的挂载容器配置中，增加 pvc 挂载</span></span><br><span class="line"><span class="attr">containers:</span></span><br><span class="line">  <span class="string">......</span></span><br><span class="line">  <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp/pvc</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">nfs-pvc-test</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nfs-pvc-test</span></span><br><span class="line">    <span class="attr">persistentVolumeClaim:</span></span><br><span class="line">      <span class="attr">claimName:</span> <span class="string">nfs-pvc</span> <span class="comment"># pvc 的名称</span></span><br></pre></td></tr></table></figure>



<h4 id="动态申领"><a href="#动态申领" class="headerlink" title="动态申领"></a>动态申领</h4><p>k8s 中提供了一套自动创建 PV 的机制，就是基于 StorageClass 进行的，通过 StorageClass 可以实现仅仅配置 PVC，然后交由 StorageClass 根据 PVC 的需求动态创建 PV。</p>
<p><img src="image-20241029195620107.png"></p>
<p>实操太麻烦了这里就不写了，参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1MT411x7GH?spm_id_from=333.788.videopod.episodes&p=67">3.5.14 配置与存储-存储类：动态创建NFS-PV案例 哔哩哔哩_bilibili</a></p>
<h1 id="9-高级调度"><a href="#9-高级调度" class="headerlink" title="9. 高级调度"></a>9. 高级调度</h1><h2 id="cronjob任务调度"><a href="#cronjob任务调度" class="headerlink" title="cronjob任务调度"></a>cronjob任务调度</h2><p>在 k8s 中周期性运行计划任务，与 linux 中的 crontab 相同</p>
<p>注意点：CronJob 执行的时间是 controller-manager 的时间，所以一定要确保 controller-manager 时间是准确的，另外 cronjob</p>
<p>参考内容：<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-crontab.html">Linux crontab 命令 | 菜鸟教程</a></p>
<p><strong>配置文件</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">concurrencyPolicy:</span> <span class="string">Allow</span> </span><br><span class="line">  <span class="comment"># 并发调度策略：Allow 允许并发调度，Forbid：不允许并发执行，Replace：如果之前的任务还没执行完，就直接执行新的，放弃上一个任务</span></span><br><span class="line">  <span class="attr">failedJobsHistoryLimit:</span> <span class="number">1</span> <span class="comment"># 保留多少个失败的任务</span></span><br><span class="line">  <span class="attr">successfulJobsHistoryLimit:</span> <span class="number">3</span> <span class="comment"># 保留多少个成功的任务</span></span><br><span class="line">  <span class="attr">suspend:</span> <span class="literal">false</span> <span class="comment"># 是否挂起任务，若为 true 则该任务不会执行</span></span><br><span class="line"><span class="comment">#  startingDeadlineSeconds: 30 # 间隔多长时间检测失败的任务并重新执行，时间不能小于 10</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;* * * * *&quot;</span> <span class="comment"># 调度策略</span></span><br><span class="line">  <span class="attr">jobTemplate:</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">spec:</span></span><br><span class="line">          <span class="attr">containers:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hello</span></span><br><span class="line">            <span class="attr">image:</span> <span class="string">busybox:1.28</span></span><br><span class="line">            <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">            <span class="attr">command:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">/bin/sh</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">-c</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">date;</span> <span class="string">echo</span> <span class="string">Hello</span> <span class="string">from</span> <span class="string">the</span> <span class="string">Kubernetes</span> <span class="string">cluster</span></span><br><span class="line">          <span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化容器initC"><a href="#初始化容器initC" class="headerlink" title="初始化容器initC"></a>初始化容器initC</h2><p>在真正的容器启动之前，先启动 InitContainer，在初始化容器中完成真实容器所需的初始化操作，完成后再启动真实的容器。</p>
<p>相对于 postStart 来说，首先 InitController 能够保证一定在 EntryPoint 之前执行，而 postStart 不能，其次 postStart 更适合去执行一些命令操作，而 InitController 实际就是一个容器，可以在其他基础容器环境下执行更复杂的初始化功能。</p>
<p>在 pod 创建的模板中配置 initContainers 参数：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">initContainers:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">command:</span> [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo &#x27;inited;&#x27; &gt;&gt; ~/.init&quot;</span>]</span><br><span class="line">  <span class="attr">name:</span> <span class="string">init-test</span> <span class="comment"># 在真正的容器启动之前，先启动 InitContainer，在初始化容器中完成真实容器所需的初始化操作，完成后再启动真实的容器。</span></span><br></pre></td></tr></table></figure>



<h2 id="污点与容忍度"><a href="#污点与容忍度" class="headerlink" title="污点与容忍度"></a>污点与容忍度</h2><p>参考内容：<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/">污点和容忍度 | Kubernetes</a></p>
<h2 id="亲和力"><a href="#亲和力" class="headerlink" title="亲和力"></a>亲和力</h2><p>参考内容：<a target="_blank" rel="noopener" href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity">将 Pod 指派给节点 | Kubernetes</a></p>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src="/img/avatar.ico"></a><div class="post-copyright__author_name">颓废市民黄先生</div><div class="post-copyright__author_desc">welcome 艾瑞巴蒂</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="social-share"><a class="social-share-ico icon-qq" target="_blank" rel="noopener" href="https://connect.qq.com/widget/shareqq/index.html?url=https%3A%2F%2Fsamurai-127.github.io%2F2024%2F10%2F21%2F16k8s%2F&amp;title=k8s%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E3%80%81%E6%89%A9%E7%BC%A9%E5%92%8C%E7%AE%A1%E7%90%86%E5%AE%B9%E5%99%A8%E5%8C%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F&amp;desc=undefined&amp;summary=undefined&amp;site=k8s%EF%BC%9A%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E3%80%81%E6%89%A9%E7%BC%A9%E5%92%8C%E7%AE%A1%E7%90%86%E5%AE%B9%E5%99%A8%E5%8C%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B3%BB%E7%BB%9F&amp;pics=%2Fimg%2Fcover%2F16k8s.avif" title="分享到QQ"><i class="solitude st-qq-fill"></i></a></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">颓废市民黄先生</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/"><span class="tags-punctuation"></span>软件技术<span class="tagsPageCount">8</span></a><a class="post-meta__tags" href="/tags/kubernetes/"><span class="tags-punctuation"></span>kubernetes<span class="tagsPageCount">2</span></a></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/24/17k8s%20%E7%9A%84%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">k8s：创建pod所需的资源清单</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/20/15%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">docker：容器化项目</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="solitude st-star-smile-fill"></i><span>喜欢这篇的人也看了</span><div class="relatedPosts-link"><a onclick="event.preventDefault(); toRandomPost();" href="javascript:void(0);" rel="external nofollow" data-pjax-state="">随便逛逛</a></div></div><div class="relatedPosts-list"><div><a href="/2024/10/24/17k8s%20%E7%9A%84%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95/" title="k8s：创建pod所需的资源清单"><img class="cover" src="/img/cover/16k8s.avif" alt="cover"><div class="content is-center"><div class="title">k8s：创建pod所需的资源清单</div></div></a></div><div><a href="/2024/09/20/15%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8/" title="docker：容器化项目"><img class="cover" src="/img/installdocker.png" alt="cover"><div class="content is-center"><div class="title">docker：容器化项目</div></div></a></div></div></div><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="solitude st-chat-fill"></i><span> 评论</span><span class="count"> (<span class="twikoo-count"><i class="solitude st-loading-line"></i></span>)</span></div></div><div class="comment-wrap"><div id="twikoo-wrap"></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="/img/avatar.jpg"></div><div class="author-info__description_group"><div class="author-info__description">大郞，你来看我的博客啦~</div><div class="author-info__description2">看看有没有对你有帮助的内容呗</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">颓废市民黄先生</div><div class="author-info__desc">welcome 艾瑞巴蒂</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://space.bilibili.com/314882691" title="Bilibili"><i class="solitude  st-bilibili-line"></i></a><a class="social-icon" target="_blank" rel="noopener" href="https://www.douyin.com/user/MS4wLjABAAAAy1FJN9CK4loLwbU-ngonlCdhB5ZT99fq4_Jdg3qJS7w" title="douyin"><i class="solitude  st-douyin-fill"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude st-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-k8s%E6%9E%B6%E6%9E%84"><span class="toc-text">1. k8s架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-text">整体架构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%97%B4%E5%8D%8F%E8%AE%AE-%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E5%9B%BE"><span class="toc-text">组件间协议&amp;分层架构图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E4%BB%8B%E7%BB%8D%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AFK8S%EF%BC%9F"><span class="toc-text">视频介绍：什么是K8S？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-k8s%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5"><span class="toc-text">2. k8s技术概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8%E4%B8%8E%E6%9C%89%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8"><span class="toc-text">无状态应用与有状态应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E7%B1%BB%EF%BC%9A%E9%9B%86%E7%BE%A4%E7%BA%A7%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%BA%A7%E3%80%81%E5%85%83%E6%95%B0%E6%8D%AE%E7%BA%A7"><span class="toc-text">资源分类：集群级、命名空间级、元数据级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">元数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Horizontal-Pod-Autoscaler%EF%BC%88HPA%EF%BC%89"><span class="toc-text">Horizontal Pod Autoscaler（HPA）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PodTemplate"><span class="toc-text">PodTemplate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LimitRange"><span class="toc-text">LimitRange</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pod%EF%BC%88%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%BA%A7%EF%BC%89"><span class="toc-text">pod（命名空间级）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pod%E4%BB%8B%E7%BB%8D"><span class="toc-text">pod介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%AF%E6%9C%AC"><span class="toc-text">副本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#RC"><span class="toc-text">RC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RS%EF%BC%88%E5%AD%A6%E4%B9%A0%EF%BC%89"><span class="toc-text">RS（学习）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Deployment%EF%BC%88%E6%97%A0%E7%8A%B6%E6%80%81%E3%80%81%E5%B7%A5%E4%BD%9C%E6%9C%80%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-text">Deployment（无状态、工作最常用）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StatefulSet%EF%BC%88%E6%9C%89%E7%8A%B6%E6%80%81%E5%BA%94%E7%94%A8%EF%BC%89"><span class="toc-text">StatefulSet（有状态应用）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DaemonSet%EF%BC%88%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="toc-text">DaemonSet（守护进程）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pod%E4%B8%8Edocker%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">pod与docker间的对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81pod%EF%BC%9F"><span class="toc-text">为什么需要pod？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-text">服务发现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#service"><span class="toc-text">service</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ingress"><span class="toc-text">Ingress</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4"><span class="toc-text">3. 搭建k8s集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">环境准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#master%E8%8A%82%E7%82%B9"><span class="toc-text">master节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node%E4%BB%8E%E8%8A%82%E7%82%B9"><span class="toc-text">node从节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6"><span class="toc-text">所有节点修改hosts文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0"><span class="toc-text">调整内核参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%EF%BC%88finalshell%E6%97%A0%E6%B3%95%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5VMware%EF%BC%89"><span class="toc-text">其他问题（finalshell无法远程连接VMware）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VMware%E4%B8%ADVMnet1%E6%88%96VMnet8-%E9%83%BD%E6%97%A0%E6%B3%95%E5%8B%BE%E9%80%89%E4%B8%8B%E6%96%B9%E7%9A%84%E2%80%9D%E5%B0%86%E4%B8%BB%E6%9C%BA%E8%99%9A%E6%8B%9F%E9%80%82%E9%85%8D%E5%99%A8%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%AD%A4%E7%BD%91%E7%BB%9C%E2%80%9C"><span class="toc-text">VMware中VMnet1或VMnet8 都无法勾选下方的”将主机虚拟适配器连接到此网络“</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85docker"><span class="toc-text">安装docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85kubeadm%E3%80%81kubelet%E5%92%8Ckubectl"><span class="toc-text">所有节点安装kubeadm、kubelet和kubectl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E9%95%9C%E5%83%8F%E5%AE%9A%E4%B9%89kubernetes%E6%BA%90%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F"><span class="toc-text">使用阿里云镜像定义kubernetes源安装镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2k8s-master%EF%BC%88%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4%EF%BC%89"><span class="toc-text">部署k8s-master（搭建k8s集群）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B"><span class="toc-text">正常部署流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">下载失败的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%85%A5-Kubernetes-Node%EF%BC%88%E4%BB%8E%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-text">加入 Kubernetes Node（从节点操作）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Master%E8%8A%82%E7%82%B9%E7%9A%84token%E5%92%8C%E8%AF%81%E4%B9%A6"><span class="toc-text">获取Master节点的token和证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E6%B5%81%E7%A8%8B"><span class="toc-text">正常流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2-CNI-%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6%EF%BC%88k8s%E9%83%A8%E7%BD%B2flannel%EF%BC%89"><span class="toc-text">部署 CNI 网络插件（k8s部署flannel）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%B5%8B%E8%AF%95"><span class="toc-text">集群测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Kubectl%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-text">4. Kubectl命令行工具常用命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Pod"><span class="toc-text">5. Pod</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#pod%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">pod配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A2%E9%92%88%E6%8A%80%E6%9C%AF"><span class="toc-text">探针技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#StartupProbe%EF%BC%88%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%89%8D%EF%BC%89"><span class="toc-text">StartupProbe（容器启动前）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LivenessProbe%EF%BC%88%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%90%8E%EF%BC%89"><span class="toc-text">LivenessProbe（容器启动后）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadinessProbe%EF%BC%88%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E5%90%8E%EF%BC%89"><span class="toc-text">ReadinessProbe（容器启动后）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">生命周期</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6"><span class="toc-text">6. 资源调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#label%E5%92%8Cselector"><span class="toc-text">label和selector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#label"><span class="toc-text">label</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selector"><span class="toc-text">selector</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deployment"><span class="toc-text">deployment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StatefulSet"><span class="toc-text">StatefulSet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8E%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="toc-text">创建于扩缩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83"><span class="toc-text">灰度发布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HAP%E8%87%AA%E5%8A%A8%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="toc-text">HAP自动扩缩容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%9C%8D%E5%8A%A1%E5%8F%91%E5%B8%83"><span class="toc-text">7. 服务发布</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#service-1"><span class="toc-text">service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AEpod"><span class="toc-text">外部访问pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pod%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E6%9C%8D%E5%8A%A1"><span class="toc-text">pod访问外部服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ingress"><span class="toc-text">ingress</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2ingress-nginx"><span class="toc-text">部署ingress-nginx</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E3%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8"><span class="toc-text">8. 配置管理、持久化存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-text">配置管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigMap"><span class="toc-text">ConfigMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%EF%BC%88%E8%BD%AF%E5%8A%A0%E5%AF%86%EF%BC%89%E9%85%8D%E7%BD%AEsecret"><span class="toc-text">加密（软加密）配置secret</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SubPath"><span class="toc-text">SubPath</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8"><span class="toc-text">持久化存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HostPath"><span class="toc-text">HostPath</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EmptyDir"><span class="toc-text">EmptyDir</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NFS"><span class="toc-text">NFS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85NFS"><span class="toc-text">安装NFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NFS%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">NFS配置文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PV%E4%B8%8EPVC"><span class="toc-text">PV与PVC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PV%E4%B8%8EPVC-1"><span class="toc-text">PV与PVC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%94%B3%E9%A2%86"><span class="toc-text">动态申领</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-text">9. 高级调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cronjob%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-text">cronjob任务调度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E5%99%A8initC"><span class="toc-text">初始化容器initC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%A1%E7%82%B9%E4%B8%8E%E5%AE%B9%E5%BF%8D%E5%BA%A6"><span class="toc-text">污点与容忍度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%B2%E5%92%8C%E5%8A%9B"><span class="toc-text">亲和力</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude st-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/24/17k8s%20%E7%9A%84%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95/" title="k8s：创建pod所需的资源清单"><img alt="k8s：创建pod所需的资源清单" src="/img/cover/16k8s.avif"></a><div class="content"><a class="title" href="/2024/10/24/17k8s%20%E7%9A%84%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95/" title="k8s：创建pod所需的资源清单">k8s：创建pod所需的资源清单</a><a class="article-recent_post_categories" href="/2024/10/24/17k8s%20%E7%9A%84%E8%B5%84%E6%BA%90%E6%B8%85%E5%8D%95/">软件技术</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/21/16k8s/" title="k8s：自动部署、扩缩和管理容器化应用程序系统"><img alt="k8s：自动部署、扩缩和管理容器化应用程序系统" src="/img/cover/16k8s.avif"></a><div class="content"><a class="title" href="/2024/10/21/16k8s/" title="k8s：自动部署、扩缩和管理容器化应用程序系统">k8s：自动部署、扩缩和管理容器化应用程序系统</a><a class="article-recent_post_categories" href="/2024/10/21/16k8s/">软件技术</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/20/15%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8/" title="docker：容器化项目"><img alt="docker：容器化项目" src="/img/installdocker.png"></a><div class="content"><a class="title" href="/2024/09/20/15%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8/" title="docker：容器化项目">docker：容器化项目</a><a class="article-recent_post_categories" href="/2024/09/20/15%E6%9E%84%E5%BB%BAdocker%E9%95%9C%E5%83%8F%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8/">软件技术</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/19/14Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B/" title="Java多线程：（五）线程安全、ThreadLocal"><img alt="Java多线程：（五）线程安全、ThreadLocal" src="/img/cover/14%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.png"></a><div class="content"><a class="title" href="/2024/09/19/14Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B/" title="Java多线程：（五）线程安全、ThreadLocal">Java多线程：（五）线程安全、ThreadLocal</a><a class="article-recent_post_categories" href="/2024/09/19/14Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E6%9C%AC%E5%9C%B0%E7%BA%BF%E7%A8%8B/">Java开发</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/17/13sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/" title="微服务保护：sentinel规则持久化"><img alt="微服务保护：sentinel规则持久化" src="/img/cover/11sentinel.png"></a><div class="content"><a class="title" href="/2024/09/17/13sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/" title="微服务保护：sentinel规则持久化">微服务保护：sentinel规则持久化</a><a class="article-recent_post_categories" href="/2024/09/17/13sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/">后端开发</a></div></div></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span>颓废市民黄先生</span></div><div class="footer-bar-description">来自 颓废市民黄先生 的文章</div><a class="footer-bar-link" href="/about/">了解更多</a></div><div id="footer_deal"></div><div id="st-footer"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 By&nbsp;<a class="footer-bar-link" href="/">颓废市民黄先生</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/everfu/hexo-theme-solitude" alt="主题">主题</a><a class="footer-bar-link cc" href="/null" aria-label="copyright"><i class="solitude st-copyright-line"></i><i class="solitude st-creative-commons-by-line"></i><i class="solitude st-creative-commons-nc-line"></i><i class="solitude st-creative-commons-nd-line"></i></a></div></div></div><div class="comment-barrage needEndHide"></div></footer></div><!-- right_menu--><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="solitude st-arrow-left-line"></i></div><div class="rightMenu-item" id="menu-forward"><i class="solitude st-arrow-right-line"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="solitude st-restart-line"></i></div><div class="rightMenu-item" id="menu-top"><i class="solitude st-arrow-up-line"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="solitude st-copy-fill"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="solitude st-clipboard-fill"></i><span>粘贴文本</span></div><div class="rightMenu-item" id="menu-commenttext"><i class="solitude st-chat-new-fill"></i><span>引用到评论</span></div><div class="rightMenu-item" id="menu-newwindow"><i class="solitude st-window-fill"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="solitude st-link-line"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="solitude st-copy-fill"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="solitude st-download-cloud-fill"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-search"><i class="solitude st-search-line"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="solitude st-play-fill"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="solitude st-skip-back-fill"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="solitude st-skip-forward-fill"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="solitude st-copy-fill"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><div class="rightMenu-item" id="menu-randomPost" onclick="toRandomPost()||rm.hideRightMenu()"><i class="solitude st-signal-tower-fill"></i><span>随机短文</span></div><div class="rightMenu-item" onclick="pjax.loadUrl('/categories/')||rm.hideRightMenu()"><i class="solitude st-checkbox-multiple-blank-fill"></i><span>全部分类</span></div><div class="rightMenu-item" onclick="pjax.loadUrl('/tags/')||rm.hideRightMenu()"><i class="solitude st-price-tag-fill"></i><span>全部标签</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><div class="rightMenu-item" id="menu-commentBarrage" onclick="sco.switchCommentBarrage()"><i class="solitude st-chat-fill"></i><span class="menu-commentBarrage-text">关闭热评</span></div><div class="rightMenu-item" id="menu-darkmode" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span class="menu-darkmode-text">深色模式</span></div><div class="rightMenu-item" id="menu-translate"><i class="solitude st-panben-line"></i><span>轉為繁體</span></div></div></div><div id="rightmenu-mask"></div><!-- inject body--><div><script src="/js/utils.js?v=1.13.3"></script><script src="/js/main.js?v=1.13.3"></script><script src="/js/third_party/waterfall.min.js?v=1.13.3"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/js/third_party/universe.min.js?v=1.13.3"></script><script>dark()
</script><script src="/js/tw_cn.js?v=1.13.3"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/11.0.5/swiper-bundle.min.js"></script><script src="/js/third_party/efu_ai.min.js?v=1.13.3"></script><script>var meting_api = 'https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r';</script><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/meting/2.0.1/Meting.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><script src="/js/right_menu.js?v=1.13.3"></script><script src="/js/custom.js"></script><div class="js-pjax"><script>(() => {
    const getCount = () => {
        const ele = document.querySelectorAll('.twikoo-count')
        if (!ele) return
        twikoo.getCommentsCount({
            envId: 'https://samurai127.cn',
            region: '',
            urls: [window.location.pathname],
            includeReply: false
        }).then(res => {
            ele.forEach(item => item.textContent = res[0].count)
        }).catch(err => {
            console.error(err)
        })
    }
    const init = () => {
        twikoo.init(Object.assign({
            el: '#twikoo-wrap',
            envId: 'https://samurai127.cn',
            region: '',
            path: window.location.pathname,
            onCommentLoaded: () => {
                GLOBAL_CONFIG.lightbox && utils.lightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
            }
        }, null))

         && getCount()
        sco.owoBig({
            body: '.OwO-body',
            item: '.OwO-items li'
        })

        true && barrageTwikoo()
    }

    const loadTwikoo = () => {
        if (typeof twikoo === 'object') setTimeout(init,0)
        else utils.getScript('https://cdnjs.cloudflare.com/ajax/libs/twikoo/1.6.36/twikoo.all.min.js').then(init)
    }

    if ('Twikoo' === 'Twikoo' || false) {
        if (false) utils.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
        else loadTwikoo()
    } else {
        window.loadTwoComment = loadTwikoo
    }
})()
</script><script>async function barrageTwikoo() {
    await fetch("https://samurai127.cn", {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            event: "COMMENT_GET",
            accessToken: "",
            url: window.location.pathname
        })
    }).then(async res => {
        if (!res.ok) throw new Error("HTTP error! status: " + res.status)
        const data = await res.json();
        const init = () => {
            initializeCommentBarrage((data.data).map(item => Object.assign({
                content: item.comment,
                nick: item.nick,
                mailMd5: item.mailMd5,
                id: item.id
            })))
        }
        if (typeof initializeCommentBarrage === "undefined") await utils.getScript('/js/third_party/barrage.min.js?v=1.13.3').then(init)
        else init()
    }).catch(error => console.error("An error occurred while fetching comments: ", error))
}</script><script defer pjax src="https://cdnjs.cloudflare.com/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js"></script></div></div><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    typeof rm === 'object' && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- google adsense--><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="solitude st-close-fill"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"><div id="search-hits"></div></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/search/local.js?v=1.13.3"></script><!-- Tianli-Talk--><span class="needEndHide" id="efuTalk" onclick="togglePostChatContainer(); return false;" title="问答ai"><i class="solitude st-robot-fill"></i><span class="efuTalkTitle">问答ai</span></span><script>var postChatConfig = {
backgroundColor: "var(--efu-main)",
bottom: "60px",
...{"defaultInput":false,"upLoadWeb":true,"userTitle":"小黄同学来也","userDesc":"有什么可以帮助你的？","showInviteLink":"https://ai.tianli0.top/?InviteID=OZ3Z0V2R","blackDom":[".aplayer"]}
};

let b = true;

document.getElementById('efuTalk').addEventListener('click', function () {
    this.classList.toggle('on');
    let efu = this
    b && setTimeout(() => {
        document.getElementById('close-button').addEventListener('click', function () {
            efu.classList.remove('on');
        })
    }, 0);
    b = false
});</script><script pjax data-postChat_key="449aa72132adf73ef7084ef83c46792af1edab" src="https://ai.tianli0.top/static/public/postChatUser.min.js"></script><!-- music--><div class="needEndHide" id="nav-music" onclick="sco.musicToggle()"><div id="nav-music-hoverTips">音乐已暂停</div><meting-js id="994057368" server="netease" type="playlist" mutex="true" preload="none" data-lrctype="0" order="random" theme="var(--efu-main)"></meting-js></div></body></html><script>const posts=["2024/10/24/17k8s 的资源清单/","2024/10/21/16k8s/","2024/09/20/15构建docker镜像与运行容器/","2024/09/19/14Java多线程：线程安全和本地线程/","2024/09/17/13sentinel规则持久化/","2024/09/14/11sentinel/","2024/09/14/12Resilience4J熔断、限流、重试/","2024/09/13/10seata/","2024/09/12/09动态代理和反射/","2024/09/11/08Nacos/","2024/09/11/07项目总结/","2024/09/09/06MQ进阶/","2024/09/04/05SpringAMQP/","2024/09/02/04Redis：（三）缓存设计/","2024/08/30/03Redis：（二）缓存问题/","2024/08/28/02Redis：（一）内存数据结构存储/","2024/08/23/01Mysql-sql优化/","2024/08/20/MySQL-分库分表/","2024/08/19/spring框架：面试知识/","2024/08/16/MySQL-MVCC/","2024/08/15/MySQL-锁/","2024/08/15/MySQL-存储引擎/","2024/08/15/MySQL-索引/","2024/08/13/JVM-gc/","2024/08/06/java：详解ConcurrentHashMap/","2024/08/05/java多线程：三、锁/","2024/08/04/java多线程：JMM/","2024/08/03/java-线程池/","2024/07/30/操作系统：（二）为什么0-1-0-2不等于0-3/","2024/07/14/搭建博客？本站搭建博客花费了多少精力？/","2024/07/09/算法：（四）递归/","2024/07/06/Java-JDK8函数式接口、lambda表达式、方法引用/","2024/07/06/算法：（三）链表/","2024/07/06/Docker实操/","2024/07/06/centOS部署docker/","2024/07/06/mybatis/","2024/07/06/JDBC 笔记/","2024/07/03/算法：（二）二分查找/","2024/07/03/操作系统：（一）快速学习存储器/","2024/07/03/算法：（一）排序算法/","2024/06/26/git速查/"];function toRandomPost(){ pjax.loadUrl(GLOBAL_CONFIG.root+posts[Math.floor(Math.random()*posts.length)]); }</script>