<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><title>JVM：详解GC | 颓废市民黄先生</title><noscript>开启JavaScript才能访问本站哦~</noscript><link rel="icon" href="/img/avatar.ico"><!-- index.css--><link rel="stylesheet" href="/css/index.css?v=1.13.3"><!-- inject head--><link rel="canonical" href="https://samurai-127.github.io/2024/08/13/JVM-gc/"><link rel="stylesheet" href="https://cdn2.codesign.qq.com/icons/7pOrz0WXB5ZWJPX/latest/iconfont.css"><!-- aplayer--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css"><!-- swiper--><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Swiper/11.0.5/swiper-bundle.min.css"><!-- fancybox ui--><!-- katex--><!-- Open Graph--><meta name="description" content="前言据我看到的面试题有：判断垃圾回收的算法有什么，以及是什么原理，垃圾收集算法有什么，常见的垃圾回收器有什么，什么是STW等，所以这篇博客基于GC给大家介绍，如果有其他面试题可以在评论区发言，博客可修改内容，可添加。 一、判断垃圾回收的算法先提前说两个算法，分别是： 引用标记算法 可达性分析算法"><!-- pwa--><meta name="apple-mobile-web-app-capable" content="颓废市民黄先生"><meta name="theme-color" content="var(--efu-main)"><meta name="apple-mobile-web-app-status-bar-style" content="var(--efu-main)"><link rel="bookmark" href="/img/avatar.ico"><link rel="apple-touch-icon" href="/img/avatar.ico" sizes="180x180"><script>console.log(' %c Solitude %c ' + '1.13.3' + ' %c https://github.com/everfu/hexo-theme-solitude',
    'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',
    'background:#ff9a9a ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff',
    'background:unset ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff')
</script><script>(()=>{
        const saveToLocal = {
            set: function setWithExpiry(key, value, ttl) {
                if (ttl === 0)
                    return
                const now = new Date()
                const expiryDay = ttl * 86400000
                const item = {
                    value: value,
                    expiry: now.getTime() + expiryDay
                }
                localStorage.setItem(key, JSON.stringify(item))
            },
            get: function getWithExpiry(key) {
                const itemStr = localStorage.getItem(key)
    
                if (!itemStr) {
                    return undefined
                }
                const item = JSON.parse(itemStr)
                const now = new Date()
    
                if (now.getTime() > item.expiry) {
                    localStorage.removeItem(key)
                    return undefined
                }
                return item.value
            }
        };
        window.utils = {
            saveToLocal: saveToLocal,
            getCSS: (url, id = false) => new Promise((resolve, reject) => {
              const link = document.createElement('link')
              link.rel = 'stylesheet'
              link.href = url
              if (id) link.id = id
              link.onerror = reject
              link.onload = link.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                link.onload = link.onreadystatechange = null
                resolve()
              }
              document.head.appendChild(link)
            }),
            getScript: (url, attr = {}) => new Promise((resolve, reject) => {
              const script = document.createElement('script')
              script.src = url
              script.async = true
              script.onerror = reject
              script.onload = script.onreadystatechange = function() {
                const loadState = this.readyState
                if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
                script.onload = script.onreadystatechange = null
                resolve()
              }
    
              Object.keys(attr).forEach(key => {
                script.setAttribute(key, attr[key])
              })
    
              document.head.appendChild(script)
            }),
            addGlobalFn: (key, fn, name = false, parent = window) => {
                const globalFn = parent.globalFn || {}
                const keyObj = globalFn[key] || {}
        
                if (name && keyObj[name]) return
        
                name = name || Object.keys(keyObj).length
                keyObj[name] = fn
                globalFn[key] = keyObj
                parent.globalFn = globalFn
            },
        }
    })()</script><!-- global head--><script>const GLOBAL_CONFIG = {
    root: '/',
    algolia: undefined,
    localsearch: {"preload":false,"path":"/search.xml"},
    runtime: 'false',
    lazyload: {
        enable: false,
        error: '/img/error_load.avif'
    },
    copyright: {"limit":50,"author":"作者: 颓废市民黄先生","link":"链接: ","source":"来源: 颓废市民黄先生","info":"著作权归作者所有。 商业转载请联系作者获得授权，非商业转载请注明出处。"},
    highlight: {"limit":200,"expand":true,"copy":true,"syntax":"highlight.js"},
    randomlink: false,
    lang: {"theme":{"dark":"已切换至深色模式","light":"已切换至浅色模式"},"copy":{"success":"复制成功","error":"复制失败"},"backtop":"返回顶部","time":{"day":"天前","hour":"小时前","just":"刚刚","min":"分钟前","month":"个月前"},"day":" 天","f12":"开发者模式已打开，请遵循GPL协议。","totalk":"无需删除空行，直接输入评论即可","search":{"empty":"找不到你查询的内容：${query}","hit":"找到 ${hits} 条结果，用时 ${time} 毫秒","placeholder":"输入关键词快速查找","count":"共 <b>${count}</b> 条结果。"},"barrage":{"title":"热评"}},
    aside: {
        sayhello: {
            morning: '起那么早看博客？',
            noon: '中午休息一下呗',
            afternoon: '下午好像在犯困',
            night: '晚上洗个澡爽一下呗',
            goodnight: '睡个好觉，保证精力充沛',
        },
        sayhello2: [],
        sayhello3: {
            prefix: '好久不见，',
            back: '欢迎再次回来，',
        },
    },
    covercolor: {
        enable: false
    },
    comment: {"avatar":"https://cravatar.cn","commentBarrage":true},
    lightbox: 'null',
    post_ai: {"key":"449aa72132adf73ef7084ef83c46792af1edab","talk":null,"randomPost":false},
    right_menu: {"mode":{"dark":"深色模式","light":"浅色模式"},"img_error":"此图片无法复制与下载","music":{"start":"播放音乐","stop":"暂停音乐"},"barrage":{"open":"显示热评","close":"关闭热评"},"translate":{"translateDelay":0,"defaultEncoding":2}},
    lure: {"jump":"404 Not Found","back":"被骗了吧（），网页没有404"},
    expire: false,
};</script><!-- page-config head--><script id="config-diff">var PAGE_CONFIG = {
    is_post: true,
    is_page: false,
    is_home: false,
    page: 'string',
    toc: true,
    comment: true,
    ai_text: false
}</script><meta name="generator" content="Hexo 7.2.0"></head><body id="body" data-type="string"><!-- universe--><canvas id="universe"></canvas><!-- background img--><div id="global_bg"></div><!-- loading--><!-- console--><!-- sidebar--><div id="sidebar" style="zoom: 1;"><div id="menu-mask" style="display: none;"></div><div id="sidebar-menus"><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a></div></div></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><span class="darkmode_switchbutton menu-child" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span>显示模式</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的歌单</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message"><span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/recentcomments"><span>最近留言</span></a></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-widget card-tags card-archives card-webinfo card-allinfo"><div class="card-tag-cloud"><a href="/tags/mysql/">mysql<sup>6</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/">面试<sup>22</sup></a><a href="/tags/redis/">redis<sup>3</sup></a><a href="/tags/MQ/">MQ<sup>2</sup></a><a href="/tags/springcloud/">springcloud<sup>3</sup></a><a href="/tags/docker/">docker<sup>2</sup></a><a href="/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E6%9C%AF/">软件技术<sup>5</sup></a><a href="/tags/JDBC/">JDBC<sup>1</sup></a><a href="/tags/Java/">Java<sup>2</sup></a><a href="/tags/JVM/">JVM<sup>1</sup></a><a href="/tags/spring/">spring<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/">后端<sup>1</sup></a><a href="/tags/git/">git<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程<sup>4</sup></a><a href="/tags/mybatis/">mybatis<sup>1</sup></a><a href="/tags/hexo/">hexo<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统<sup>2</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/">算法<sup>4</sup></a><a href="/tags/seata/">seata<sup>1</sup></a><a href="/tags/sentinel/">sentinel<sup>1</sup></a></div></div></div></div><!-- keyboard--><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav class="show" id="nav"><div id="nav-group"><div id="blog_name"><a id="site-name" href="/" title="返回博客主页"><span class="title">颓废市民黄先生</span></a></div><div id="page-name-mask"><div id="page-name"><a id="page-name-text" onclick="sco.toTop()">JVM：详解GC</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span>首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>文库</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="solitude  st-folder-fill"></i><span>文章列表</span></a></li><li><a class="site-page child" href="/categories/"><i class="solitude  st-checkbox-multiple-blank-fill"></i><span>全部分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="solitude  st-price-tag-fill"></i><span>全部标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>我的歌单</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="solitude  st-disc-fill"></i><span>音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span>关于</span></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="solitude  st-contacts-fill"></i><span>关于本站</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/message"><span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/recentcomments"><span>最近留言</span></a></div></div></div><div id="nav-left"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机一篇文章" href="javascript:void(0);"><i class="solitude st-dice-line"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索"><i class="solitude st-search-line"></i></a></div><div class="nav-button" id="nav-totop" onclick="sco.toTop()"><a class="totopbtn"><i class="solitude st-arrow-up-line"></i><span id="percent">0</span></a></div><div id="toggle-menu"><a class="site-page"><i class="solitude st-menu-line"></i></a></div></div></div></nav><div class="coverdiv" id="coverdiv"><img class="nolazyload" id="post-cover" src="/img/JVM.jpg" alt="JVM：详解GC"></div><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original" title="该文章为原创文章，注意版权协议">原创</a><span class="post-meta-categories"><a class="post-meta-categories" href="/categories/Java%E5%BC%80%E5%8F%91/">Java开发</a></span><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-name tags-punctuation">面试</span></a><a class="post-meta__tags" href="/tags/JVM/"><span class="tags-name tags-punctuation">JVM</span></a></div></div></div></div><h1 class="post-title">JVM：详解GC</h1><div id="post-meta"><div class="meta-secondline"><span class="post-meta-date" title="发布于 2024-08-13 10:03:12"><i class="post-meta-icon solitude st-calendar-todo-fill"></i><time datetime="2024-08-13T02:03:12.000Z">2024-08-13T02:03:12.000Z</time></span><span class="post-meta-date" title="最后更新于 2024-09-10 22:08:48"><i class="post-meta-icon solitude st-refresh-line"></i><time datetime="2024-09-10T14:08:48.829Z">2024-09-10T14:08:48.829Z</time></span><span class="post-meta-position" title="作者IP归属地为广西"><i class="post-meta-icon solitude st-map-pin-fill"></i><span>广西</span></span><a class="post-meta-pv" href="/2024/08/13/JVM-gc/" title="文章热度"><i class="post-meta-icon solitude st-fire-fill"></i><span id="twikoo_visitors"><i class="solitude st-loading-line"></i></span></a><span class="post-meta-commentcount" title="评论数" onclick="sco.scrollTo('post-comment')"><i class="solitude st-chat-fill"></i><a href="/2024/08/13/JVM-gc/#post-comment"><span class="twikoo-count"><i class="solitude st-loading-line"></i></span></a></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="post-ai"><div class="ai-title"><div class="ai-title-left"><i class="ai-title-icon solitude st-robot-fill"></i><div class="ai-title-text">文章摘要</div></div><div class="ai-tag" id="ai-tag">GPT 4</div></div><div class="ai-explanation" style="display: block;"></div><div class="ai-suggestions"></div><div class="ai-bottom"><div class="ai-tips">此内容根据文章生成，仅用于文章内容的解释与总结</div><a class="ai-report" title="投诉" href="https://samurai-127.github.io">投诉</a></div></div><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>据我看到的面试题有：判断垃圾回收的算法有什么，以及是什么原理，垃圾收集算法有什么，常见的垃圾回收器有什么，什么是STW等，所以这篇博客基于GC给大家介绍，如果有其他面试题可以在评论区发言，博客可修改内容，可添加。</p>
<h1 id="一、判断垃圾回收的算法"><a href="#一、判断垃圾回收的算法" class="headerlink" title="一、判断垃圾回收的算法"></a>一、判断垃圾回收的算法</h1><p>先提前说两个算法，分别是：</p>
<ol>
<li><p>引用标记算法</p>
</li>
<li><p>可达性分析算法</p>
</li>
</ol>
<h2 id="1-引用标记算法"><a href="#1-引用标记算法" class="headerlink" title="1.引用标记算法"></a>1.引用标记算法</h2><p>引用标记算法是在Java对象头（Java对象头在介绍多线程的时候有详细的解释，直达链接：<a target="_blank" rel="noopener" href="https://rengoku.top/2024/08/05/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E4%B8%89%E3%80%81%E9%94%81/">Java多线程：三、多线程锁、java锁的实现</a>）中开辟空间，记录<strong>被引用的次数（Reference Count）</strong>，如果A变量被其他对象引用时计数器+1，引用A变量的其他变量被删除则-1，如果计数器为0时，则判断A变量需要被回收。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我不想上早八&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时，在Java虚拟机栈（以下简称栈）开辟一个内存空间记录str，此时堆中的字符串常量池的“我不想上早八”，被引用的次数就是1（Reference Count&#x3D;1），此时我做修改操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;其实我想上早七&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时，在栈中的变量str原本引用常量池的”我不想上早八”引用次数为0，那么这一块就会被回收。</p>
<p>引用标记算法的回收机制遍布整个代码运行时期而没有集中于垃圾回收时期，因此不属于”Stop-The-World”的范围。</p>
<blockquote>
<p>“Stop The World”是 Java 垃圾收集中的一个重要概念。在垃圾收集过程中，JVM 会暂停所有的用户线程，这种暂停被称为”Stop The World”事件。</p>
<p>这么做的主要原因是为了防止在垃圾收集过程中，用户线程修改了堆中的对象，导致垃圾收集器无法准确地收集垃圾。</p>
</blockquote>
<p><strong>引用标记算法存在的问题：</strong></p>
<p>无法解决循环依赖的问题，看代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance;  <span class="comment">// 对象属性，用于存储对另一个 ReferenceCountingGC 对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReferenceCountingGC</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个 ReferenceCountingGC 对象</span></span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>(<span class="string">&quot;我爱玩原神&quot;</span>);</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>(<span class="string">&quot;那维莱特一次回调比得上3年的陪伴&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使 a 和 b 相互引用</span></span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 a 和 b 设置为 null</span></span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个位置是垃圾回收的触发点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中a,b变量相互引用，即使将将 a 和 b 设置为 null，也无法将字符串的引用改变（即Reference Count没有被减到0）。从案例可以知道，这样写永远无法通知GC对这两个字符串进行收集。</p>
<h2 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h2><p>现代虚拟机基本都是采用可达性分析算法来判断对象是否存活，可达性算法的原理是以一系列叫做  <strong>GC Root</strong> 的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 <strong>GC Root</strong> 为起点的引用链中，则这些对象会被判断为垃圾对象,会被 GC 回收。</p>
<p><img src="Snipaste_2024-08-13_10-31-47.png"></p>
<p><strong>a, b 对象可回收，就一定会被回收吗?</strong></p>
<p>并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！</p>
<p><strong>注意：</strong> finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!</p>
<p><strong>GC Roots 到底是什么东西呢，哪些对象可以作为 GC Root 呢？</strong></p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ul>
<p>关于这四个例子可以参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_38007185/article/details/108093716">GC Roots 是什么？哪些对象可以作为 GC Root？看完秒懂！-CSDN博客</a></p>
<h1 id="二、八股：垃圾收集算法"><a href="#二、八股：垃圾收集算法" class="headerlink" title="二、八股：垃圾收集算法"></a>二、八股：垃圾收集算法</h1><p>阿里八股16题，我们来详细的谈谈：</p>
<h2 id="1-标记清除算法"><a href="#1-标记清除算法" class="headerlink" title="1.标记清除算法"></a>1.标记清除算法</h2><p>标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为 2 部分，先把内存区域中的这些对象进行标记，哪些属于可回收的标记出来（用前面提到的可达性分析法），然后把这些垃圾拎出来清理掉。</p>
<p><img src="gc-20231227125304.png"></p>
<p>标记清除算法存在一个缺陷，在垃圾回收以后会产生内存碎片，无法应对需要一口气分配大内存的情况。</p>
<blockquote>
<p>内存碎片化是指在内存分配和回收过程中，被释放的内存空间没有被合并成较大的连续空间，而是形成了许多小块的、不连续的内存区域。这会导致在后续需要分配大块连续内存时，系统可能无法找到足够的连续空间，从而影响程序的性能和稳定性。</p>
</blockquote>
<h2 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h2><p>复制算法（Copying）是在标记清除算法上演化而来的，用于解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</p>
<p>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样就保证了内存的连续性，逻辑清晰，运行高效。</p>
<p><img src="gc-20231227125751.png"></p>
<p>但是也是存在一个大缺陷，相当于一大堆的内存我只能当一半用。</p>
<h2 id="3-标记整理算法"><a href="#3-标记整理算法" class="headerlink" title="3.标记整理算法"></a>3.标记整理算法</h2><p>标记整理算法（Mark-Compact），标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p>
<p><img src="gc-20231227130011.png"></p>
<p>标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法差很多。</p>
<h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h2><h3 id="4-1-分代收集算法组合拳"><a href="#4-1-分代收集算法组合拳" class="headerlink" title="4.1 分代收集算法组合拳"></a>4.1 分代收集算法组合拳</h3><p>分代收集算法（Generational Collection）严格来说并不是一种思想或理论，而是融合上述 3 种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。</p>
<p>根据对象存活周期的不同会将内存划分为几块，一般是把 <strong>Java 堆分为新生代和老年代</strong>，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<p><img src="gc-20231227131241.png"></p>
<p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收。</p>
<blockquote>
<p>这里提到了新生代和永久代，在JVM运行时数据区中也提到了一个”代“叫永久代，还记得永久代是什么吗？</p>
<p>永久代也叫方法区，在jdk8之后被代替成了元空间，运行时常量池放在元空间中，而字符串常量池在堆中。</p>
</blockquote>
<h3 id="4-2-新生代和老年代"><a href="#4-2-新生代和老年代" class="headerlink" title="4.2 新生代和老年代"></a>4.2 新生代和老年代</h3><p>堆主要分为 2 个区域，年轻代与老年代，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 两个区。</p>
<p><img src="gc-20231227132701.png"></p>
<h4 id="4-2-1-Eden-区"><a href="#4-2-1-Eden-区" class="headerlink" title="4.2.1 Eden 区"></a>4.2.1 Eden 区</h4><p>据 IBM 公司之前的研究表明，有将近 98% 的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，JVM 会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。</p>
<p>通过 Minor GC 之后，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区，如果 From 区不够，则直接进入 To 区。</p>
<p><strong>什么是Minor GC和Major GC？</strong></p>
<p>Minor GC是新生代的GC，Major GC是老年代的GC</p>
<p><strong>Survivor区的from和to角色切换</strong></p>
<ol>
<li>初始状态<ul>
<li>在JVM启动时，两个Survivor区中的一个被指定为from区，另一个为to区。这个初始分配是任意的，但一旦确定，它们将在后续的GC过程中交替使用。</li>
</ul>
</li>
<li>Minor GC过程<ul>
<li>当Eden区满或JVM认为需要执行Minor GC时，GC过程开始。</li>
<li>此时，from区存储着上一次GC后存活下来的对象。</li>
<li>GC扫描Eden区和from区，将存活的对象复制到to区。</li>
<li>如果对象的年龄（即经历Minor GC的次数）达到一定程度（默认是15次，但可以通过参数<code>-XX:MaxTenuringThreshold</code>来设定），则这些对象可能会被移动到老年代（Old Generation）。</li>
<li>GC完成后，Eden区和from区的内容被清空，然后这两个区域的角色互换：原来的to区变为新的from区，原来的from区变为新的to区。</li>
</ul>
</li>
<li>持续交替<ul>
<li>上述过程在每次Minor GC时都会重复，导致Survivor区的from和to角色持续交替。</li>
</ul>
</li>
</ol>
<h4 id="4-2-2-Survivor-区"><a href="#4-2-2-Survivor-区" class="headerlink" title="4.2.2 Survivor 区"></a>4.2.2 Survivor 区</h4><p>Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。</p>
<p><strong>为啥需要 Survivor 区？</strong></p>
<p>不就是新生代到老年代吗，直接 Eden 到 Old 不好了吗，为啥要这么复杂。</p>
<p>如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。</p>
<p>这时候移入老年区，很明显不是一个明智的决定。</p>
<p>所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历 16 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</p>
<p><strong>Survivor 区为啥划分为两块？</strong></p>
<p>设置两个 Survivor 区最大的好处就是解决内存碎片化，我们先假设一下，Survivor 只有一个区域会怎样。</p>
<p>Minor GC 执行后，Eden 区被清空，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。那么问题来了，这时候我们怎么清除它们？</p>
<p>在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。</p>
<p>但因为 Survivor 有 2 个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。</p>
<p>这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。</p>
<p>那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个？</p>
<p>显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。</p>
<h4 id="4-2-3-Old-区"><a href="#4-2-3-Old-区" class="headerlink" title="4.2.3 Old 区"></a>4.2.3 Old 区</h4><p>老年代占据着 2&#x2F;3 的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。</p>
<p>由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记整理算法。</p>
<h2 id="5-组合拳如何体现？"><a href="#5-组合拳如何体现？" class="headerlink" title="5.组合拳如何体现？"></a>5.组合拳如何体现？</h2><p>对于前三种收集算法，我们采用分代收集将前三种混合。</p>
<p><strong>新生代，主要采用复制算法</strong>，我相信聪明的你能看得出来，<strong>Survivor 区的from和to区就是复制算法中提到的，将内存一分为二的部分。</strong></p>
<p><strong>老年代，采用标记整理算法</strong>，理由有这些（ai部分）：</p>
<ol>
<li><strong>存活率高</strong>：老年代中的对象通常已经经过了多次垃圾回收周期，存活率较高。这意味着在每次垃圾回收时，只有少数对象会被回收，而大部分对象都会保留下来。如果使用复制算法，需要将存活的对象复制到另一块内存区域，这将导致大量的数据复制操作，不仅效率低下，还会增加系统的停顿时间。</li>
<li><strong>内存空间</strong>：老年代通常占据堆内存的大部分空间，以容纳更多的长时间存活对象。如果采用复制算法，需要为老年代分配同样大小的额外内存空间作为复制的目标区域，这在很多情况下是不现实的，因为这将极大地增加内存的使用量。</li>
<li><strong>内存碎片</strong>：虽然复制算法可以避免内存碎片的产生，但在老年代中，内存碎片的问题并不像新生代那样严重。老年代中的对象通常较大，且存活时间较长，因此内存碎片对性能的影响相对较小。相比之下，减少内存碎片并不是老年代选择垃圾收集算法的主要考虑因素。</li>
<li><strong>算法适用性</strong>：不同的垃圾收集算法适用于不同的场景。复制算法由于其简单性和高效性，在新生代中得到了广泛应用。然而，在老年代中，由于对象的特性和内存空间的需求，更适合采用其他类型的垃圾收集算法，如标记-清除、标记-整理或混合使用多种算法（如G1收集器中的混合收集策略，G1收集器下文介绍）。</li>
</ol>
<h1 id="三、垃圾收集器"><a href="#三、垃圾收集器" class="headerlink" title="三、垃圾收集器"></a>三、垃圾收集器</h1><p>垃圾收集器在这篇博客有8种，我把总览放出来，然后讲几个比较常用的：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44772566/article/details/136248892">一文彻底搞懂八种JVM垃圾回收器_说一下 jvm 有哪些垃圾回收器?-CSDN博客</a></p>
<p><img src="b7066e4374f7d7397613068ac5fdf5b1.png"></p>
<h2 id="1-CMS收集器"><a href="#1-CMS收集器" class="headerlink" title="1.CMS收集器"></a>1.CMS收集器</h2><p><strong>CMS垃圾收集器旨在降低STW的时间，允许垃圾回收器进行垃圾回收的同时，与应用程序并发进行。</strong></p>
<h3 id="1-1-步骤"><a href="#1-1-步骤" class="headerlink" title="1.1 步骤"></a>1.1 步骤</h3><p>CMS 垃圾收集器通过三色标记算法，实现了垃圾回收线程与用户线程的并发执行，从而极大地降低了系统响应时间，提高了强交互应用程序的体验。它的运行过程分为 4 个步骤，包括：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p><strong>初始标记</strong>，指的是寻找所有被 GCRoots 引用的对象，该阶段需要「Stop the World」。这个步骤仅仅只是标记一下 GC Roots 能直接关联到的对象，并不需要做整个引用的扫描，因此速度很快。</p>
<p><strong>并发标记</strong>，指的是对「初始标记阶段」标记的对象进行整个引用链的扫描，该阶段不需要「Stop the World」。 对整个引用链做扫描需要花费非常多的时间，因此通过垃圾回收线程与用户线程并发执行，可以降低垃圾回收的时间。</p>
<p>这也是 CMS 能极大降低 GC 停顿时间的核心原因，但这也带来了一些问题，即：并发标记的时候，引用可能发生变化，因此可能发生漏标（本应该回收的垃圾没有被回收）和多标（本不应该回收的垃圾被回收）了。</p>
<p><strong>重新标记</strong>，指的是对「并发标记」阶段出现的问题进行校正，该阶段需要「Stop the World」。正如并发标记阶段说到的，由于垃圾回收算法和用户线程并发执行，虽然能降低响应时间，但是会发生漏标和多标的问题。所以对于 CMS 来说，它需要在这个阶段做一些校验，解决并发标记阶段发生的问题。</p>
<p><strong>并发清除</strong>，指的是将标记为垃圾的对象进行清除，该阶段不需要「Stop the World」。 在这个阶段，垃圾回收线程与用户线程可以并发执行，因此并不影响用户的响应时间。</p>
<p><strong>注：</strong><br>收集区域： 老年代（见图常用的垃圾收集器。标记清除和标记整理也是用于老年代的垃圾收集算法，可以回看）<br>使用算法： 标记清除法+标记整理法<br>搜集方式： 多线程</p>
<h3 id="1-2-优劣势"><a href="#1-2-优劣势" class="headerlink" title="1.2 优劣势"></a>1.2 优劣势</h3><p>优点总结就是支持垃圾回收和程序执行的并发，降低STW时间，详细的可以参考以下内容：</p>
<p>并发标记和清除：CMS 垃圾收集器采用了并发标记和清除的方式，允许在垃圾收集过程中与应用程序并发执行。这意味着垃圾收集过程中只有一小部分时间需要暂停应用程序线程。<br>低停顿时间：由于并发执行的特性，CMS 垃圾收集器能够在较短的时间内完成垃圾回收操作，从而减少了应用程序的停顿时间。通常情况下，CMS 垃圾收集器能够将停顿时间控制在几百毫秒甚至更低。<br>老年代收集：CMS 垃圾收集器主要针对老年代进行垃圾回收，对于新生代则通常使用 ParNew 收集器。这种分代收集的方式能够更好地适应不同内存区域的特点和垃圾回收需求。</p>
<blockquote>
<p>这里提到了ParNew收集器，那么我也写一下，本来不想写来着（）</p>
</blockquote>
<p>劣势从算法考虑，无非就是会产生内存碎片，以及在垃圾收集与应用程序并发执行的过程中，应用程序也会一直产生垃圾，这个垃圾称为浮游垃圾，这部分只能等到下一次gc来处理，另外这两个并发的话，如果cpu的核心数（对线程的处理能力低）那么CMS的性能肯定会大打折扣。</p>
<h2 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h2><p>在上边提到的CMS收集器是针对老年代的，而ParNew收集器针对新生代的部分进行垃圾回收，通常和CMS收集器共同进行gc。查到的资料有显示，ParNew收集器是唯一的一个可以和CMS收集器打配合的。</p>
<p><strong>垃圾收集流程</strong><br>ParNew 收集器和 Parallel Scavenge 收集器在工作流程上确实非常相似，都是并行垃圾收集器。</p>
<ol>
<li><p>停止应用程序线程（Stop the World）：在进行垃圾收集之前，ParNew 收集器会暂停所有的用户线程。这一阶段被称为停止应用程序线程，以确保在垃圾收集过程中对象的状态不会被修改，保证垃圾回收的准确性。</p>
</li>
<li><p>多线程并行执行垃圾收集：一旦应用程序线程暂停，ParNew 收集器会启动多个线程并行执行垃圾回收操作。这些线程会同时在新生代中扫描和清理不再使用的对象，以释放内存空间。</p>
</li>
<li><p>暂停用户线程：在整个垃圾收集过程中，用户线程会一直处于暂停状态，直到垃圾收集完成。这个阶段也被称为“Stop the World”，在此期间应用程序无法执行任何操作。</p>
</li>
<li><p>恢复用户线程：当垃圾收集完成后，ParNew 收集器会恢复用户线程的执行。此时，垃圾已经被清理，堆中的内存空间得到了释放，用户线程可以继续执行。</p>
</li>
</ol>
<p>ParNew 收集器的工作流程与 Parallel Scavenge 收集器类似，都是通过停止应用程序线程，然后利用多线程并行执行垃圾回收操作，最后恢复用户线程的执行。这种并行执行的方式能够提高垃圾收集的效率，同时在暂停用户线程期间确保垃圾收集的准确性。</p>
<p><strong>注：</strong><br>收集区域： 新生代<br>使用算法： 标记复制法<br>搜集方式： 多线程。</p>
<p>正常来说，ParNew收集器和CMS收集器是一起打配合的，他俩在分类来说都是分代收集器，一个作用于新生代，一个作用于老年代。</p>
<h2 id="3-G1收集器"><a href="#3-G1收集器" class="headerlink" title="3.G1收集器"></a>3.G1收集器</h2><p>G1 垃圾收集器摒弃了传统的物理分区方式，而是将整个内存分成若干个大小不同的 Region 区域。每个 Region 在逻辑上组合成各个分代，这样做的好处是可以以 Region 为单位进行更细粒度的垃圾回收。G1 垃圾收集器在进行垃圾回收时，可以针对单个或多个 Region 进行回收，从而提高了收集效率和性能。</p>
<p>下面介绍一下G1的相关内容：</p>
<p><strong>分代：</strong>相信大家还记得我们上一讲中的年轻代和老年代，G1 也是基于这个思想进行设计的。<strong>G1舍弃分代，转变为分区，</strong>将堆内存分为多个大小相等的区域（Region），每个区域都可以是 Eden 区、Survivor 区或者 Old 区。</p>
<p><img src="gc-collector-20231228213824.png"></p>
<p>可以通过 <code>-XX:G1HeapRegionSize=n</code> 来设置 Region 的大小，可以设定为 1M、2M、4M、8M、16M、32M（不能超过）。</p>
<p>G1 有专门分配大对象的 Region 叫 Humongous 区，而不是让大对象直接进入老年代的 Region 中。在 G1 中，大对象的判定规则就是一个大对象超过了一个 Region 大小的 50%，比如每个 Region 是 2M，只要一个对象超过了 1M，就会被放入 Humongous 中，而且一个大对象如果太大，可能会横跨多个 Region 来存放。</p>
<p>G1 会根据各个区域的垃圾回收情况来决定下一次垃圾回收的区域，这样就避免了对整个堆内存进行垃圾回收，从而降低了垃圾回收的时间。</p>
<p>在进行老年代的垃圾回收时，G1 使用标记-整理算法。这个过程分为两个阶段：标记存活的对象和整理（压缩）堆空间。通过整理，G1 能够避免内存碎片化，提高内存利用率。年轻代的垃圾回收（Minor GC）使用复制算法，因为年轻代的对象通常是朝生夕死的。</p>
<p><img src="gc-collector-20231230100404.png"></p>
<p><strong>STW：</strong>G1 也是基于「标记-清除」算法，因此在进行垃圾回收的时候，仍然需要「Stop the World」。不过，G1 在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</p>
<p><strong>接下来介绍G1的三种回收机制：</strong></p>
<p><img src="gc-collector-20231228215108.png"></p>
<p>当 Eden 区的内存空间无法支持新对象的内存分配时，G1 会触发 Young GC。</p>
<p>当需要分配对象到 Humongous 区域或者堆内存的空间占比超过 <code>-XX:G1HeapWastePercent</code> 设置的 InitiatingHeapOccupancyPercent 值时，G1 会触发一次 concurrent marking，它的作用就是计算老年代中有多少空间需要被回收，当发现垃圾的占比达到 <code>-XX:G1HeapWastePercent</code> 中所设置的 G1HeapWastePercent 比例时，在下次 Young GC 后会触发一次 Mixed GC。</p>
<p>Mixed GC 是指回收年轻代的 Region 以及一部分老年代中的 Region。Mixed GC 和 Young GC 一样，采用的也是复制算法。</p>
<p>在 Mixed GC 过程中，如果发现老年代空间还是不足，此时如果 G1HeapWastePercent 设定过低，可能引发 Full GC。<code>-XX:G1HeapWastePercent</code> 默认是 5，意味着只有 5% 的堆是“浪费”的。如果浪费的堆的百分比大于 G1HeapWastePercent，则运行 Full GC。</p>
<p><strong>注：</strong><br>收集区域： 整个堆内存<br>使用算法： 标记复制法<br>搜集方式： 多线程</p>
<h2 id="4-ZGC"><a href="#4-ZGC" class="headerlink" title="4.ZGC"></a>4.ZGC</h2><p>参考一开始的博客链接。</p>
<h1 id="四、对象分配规则"><a href="#四、对象分配规则" class="headerlink" title="四、对象分配规则"></a>四、对象分配规则</h1><p>根据分代收集算法，将堆内存分为新生代和老年代，新生代分为eden区，Survivor from和Survivor to区，老年代为old区。</p>
<p><strong>1.对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</strong> </p>
<p>Minor GC 后，又创建的新对象会继续往 Eden 区分配。于是，随着新对象的创建，Eden 的剩余内存空间就会越来越少，又会触发 Minor GC，此时，JVM 会对 Eden 区和 From Survivor 区中的对象进行存活判断，对于存活的对象，会转移到 To Survivor 区。下一次 Minor GC，存活的对象又会从 To 到 From，这样就总有一个 Survivor 区是空的，而另外一个是无碎片的。</p>
<p><strong>2.大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。</strong></p>
<p>这样做的目的是避免在 Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 </p>
<p>可以通过 <code>-XX:PretenureSizeThreshold</code> 参数设置直接分配大对象到老年代的阈值。如果对象的大小超过这个阈值，它将直接在老年代中分配。例如，如果想将阈值设置为 1MB（1024KB），可以这样设置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:PretenureSizeThreshold=1048576</span><br></pre></td></tr></table></figure>

<p><strong>3.长期存活的对象进入老年代。</strong></p>
<p>虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次 Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC（从一个 Survivor 区转移到另外一个 Survivor 区时）那么对象的年龄加1，直到达到阀值对象进入老年区。 </p>
<p><strong>4.动态判断对象的年龄。</strong></p>
<p>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的 一半，年龄大于或等于该年龄的对象可以直接进入老年代。 </p>
<p><strong>5.空间分配担保。</strong></p>
<p>整个流程如下：</p>
<ul>
<li>Minor GC 之前，JVM 会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，则发起 Minor GC。</li>
<li>如果小于，则看 HandlePromotionFailure 有没有设置，如果没有设置，就发起 Full GC。</li>
<li>如果设置了 HandlePromotionFailure，则看老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于，就发起 Full GC。</li>
<li>如果大于，发起 Minor GC。Minor GC 后，看 Survivor 空间是否足够存放存活对象，如果不够，就放入老年代，如果够放，就直接存放 Survivor 空间。如果老年代都不够放存活对象，担保失败（Handle Promotion Failure），发起 Full GC。</li>
</ul>
<p><img src="whereis-the-object-8.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>判断是否需要进行垃圾回收的算法有<strong>引用标记算法和可达性分析算法</strong>，前者使用Java对象头的Reference Count属性，后者依靠引用关系，解决前者不能解决循环依赖的问题。</p>
<p>垃圾收集算法有标记清除算法（存在内存碎片化问题）、复制算法（内存分割出去不划算）、标记整理算法（需要改动引用对象地址，效率低）、分代收集算法（前三种的组合拳），其中学习了stop-to-world是什么，新生代和老年代是什么，复习了Java对象头和永久代，JVM运行时数据区。</p>
<p>垃圾收集器介绍了CMS、ParNew、G1等，其中，CMS和ParNew作为分区收集器，共同打配合清理堆内存。</p>
<p>基于分代收集的算法（组合拳），对象的分配规则由eden-&gt;Survivor-&gt;old区主键分配，其中根据不同的情况进行minor gc和full gc。</p>
</article><div class="post-copyright"><div class="post-copyright__author_group"><a class="post-copyright__author_img" href="/about/"><img class="post-copyright__author_img_front" src="/img/avatar.ico"></a><div class="post-copyright__author_name">颓废市民黄先生</div><div class="post-copyright__author_desc">welcome 艾瑞巴蒂</div></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div id="quit-box" onclick="RemoveRewardMask()"></div></div></div><div class="social-share"><a class="social-share-ico icon-qq" target="_blank" rel="noopener" href="https://connect.qq.com/widget/shareqq/index.html?url=https%3A%2F%2Fsamurai-127.github.io%2F2024%2F08%2F13%2FJVM-gc%2F&amp;title=JVM%EF%BC%9A%E8%AF%A6%E8%A7%A3GC&amp;desc=undefined&amp;summary=undefined&amp;site=JVM%EF%BC%9A%E8%AF%A6%E8%A7%A3GC&amp;pics=%2Fimg%2FJVM.jpg" title="分享到QQ"><i class="solitude st-qq-fill"></i></a></div><div class="post-copyright__notice"><span class="post-copyright-info">本文是原创文章，采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a>协议，完整转载请注明来自<a href="/">颓废市民黄先生</a></span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"></span>面试<span class="tagsPageCount">22</span></a><a class="post-meta__tags" href="/tags/JVM/"><span class="tags-punctuation"></span>JVM<span class="tagsPageCount">1</span></a></div></div></div><nav class="needEndHide pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/08/15/MySQL-%E7%B4%A2%E5%BC%95/"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL：（一）索引底层原理与实现</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/06/java%EF%BC%9A%E8%AF%A6%E8%A7%A3ConcurrentHashMap/"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java多线程：（四）详解ConcurrentHashMap构成</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="solitude st-star-smile-fill"></i><span>喜欢这篇的人也看了</span><div class="relatedPosts-link"><a onclick="event.preventDefault(); toRandomPost();" href="javascript:void(0);" rel="external nofollow" data-pjax-state="">随便逛逛</a></div></div><div class="relatedPosts-list"><div><a href="/2024/09/13/10seata/" title="分布式事务：Seata"><img class="cover" src="/img/cover/10seata.png" alt="cover"><div class="content is-center"><div class="title">分布式事务：Seata</div></div></a></div><div><a href="/2024/09/12/09%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84/" title="Java高级：动态代理、反射"><img class="cover" src="/img/cover/09dynamicproxy.png" alt="cover"><div class="content is-center"><div class="title">Java高级：动态代理、反射</div></div></a></div></div></div><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="solitude st-chat-fill"></i><span> 评论</span><span class="count"> (<span class="twikoo-count"><i class="solitude st-loading-line"></i></span>)</span></div></div><div class="comment-wrap"><div id="twikoo-wrap"></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><div class="author-info__top-group"><div class="author-info__sayhi" id="author-info__sayhi" onclick="sco.changeSayHelloText()">sayhello.morning</div></div></div><div class="avatar-img-group"><img class="avatar-img" alt="头像" src="/img/avatar.jpg"></div><div class="author-info__description_group"><div class="author-info__description">大郞，你来看我的博客啦~</div><div class="author-info__description2">看看有没有对你有帮助的内容呗</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about/"><div class="author-info__name">颓废市民黄先生</div><div class="author-info__desc">welcome 艾瑞巴蒂</div></a><div class="card-info-social-icons is-center"><a class="social-icon" target="_blank" rel="noopener" href="https://space.bilibili.com/314882691" title="Bilibili"><i class="solitude  st-bilibili-line"></i></a><a class="social-icon" target="_blank" rel="noopener" href="https://www.douyin.com/user/MS4wLjABAAAAy1FJN9CK4loLwbU-ngonlCdhB5ZT99fq4_Jdg3qJS7w" title="douyin"><i class="solitude  st-douyin-fill"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="solitude st-menu-line"></i><span>文章目录</span></div><div class="toc-content" id="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%A4%E6%96%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-text">一、判断垃圾回收的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%95%E7%94%A8%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="toc-text">1.引用标记算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">2.可达性分析算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%85%AB%E8%82%A1%EF%BC%9A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">二、八股：垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">1.标记清除算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">2.复制算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">3.标记整理算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">4.分代收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E7%BB%84%E5%90%88%E6%8B%B3"><span class="toc-text">4.1 分代收集算法组合拳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-text">4.2 新生代和老年代</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-Eden-%E5%8C%BA"><span class="toc-text">4.2.1 Eden 区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-Survivor-%E5%8C%BA"><span class="toc-text">4.2.2 Survivor 区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-Old-%E5%8C%BA"><span class="toc-text">4.2.3 Old 区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BB%84%E5%90%88%E6%8B%B3%E5%A6%82%E4%BD%95%E4%BD%93%E7%8E%B0%EF%BC%9F"><span class="toc-text">5.组合拳如何体现？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">三、垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">1.CMS收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.1 步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%BC%98%E5%8A%A3%E5%8A%BF"><span class="toc-text">1.2 优劣势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">2.ParNew收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">3.G1收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ZGC"><span class="toc-text">4.ZGC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-text">四、对象分配规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="solitude st-map-line"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/" title="Untitled"><img alt="Untitled" src="/img/default.avif"></a><div class="content"><a class="title" href="/2024/09/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%BF%9D%E6%8A%A4/" title="Untitled">Untitled</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/14/11sentinel/" title="微服务保护：sentinel"><img alt="微服务保护：sentinel" src="/img/cover/11sentinel.png"></a><div class="content"><a class="title" href="/2024/09/14/11sentinel/" title="微服务保护：sentinel">微服务保护：sentinel</a><a class="article-recent_post_categories" href="/2024/09/14/11sentinel/">后端开发</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/14/12Resilience4J%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81%E3%80%81%E9%87%8D%E8%AF%95/" title="微服务保护：resilience4j"><img alt="微服务保护：resilience4j" src="/img/resilience4j.png"></a><div class="content"><a class="title" href="/2024/09/14/12Resilience4J%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81%E3%80%81%E9%87%8D%E8%AF%95/" title="微服务保护：resilience4j">微服务保护：resilience4j</a><a class="article-recent_post_categories" href="/2024/09/14/12Resilience4J%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81%E3%80%81%E9%87%8D%E8%AF%95/">后端开发</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/13/10seata/" title="分布式事务：Seata"><img alt="分布式事务：Seata" src="/img/cover/10seata.png"></a><div class="content"><a class="title" href="/2024/09/13/10seata/" title="分布式事务：Seata">分布式事务：Seata</a><a class="article-recent_post_categories" href="/2024/09/13/10seata/">后端开发</a></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/12/09%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84/" title="Java高级：动态代理、反射"><img alt="Java高级：动态代理、反射" src="/img/cover/09dynamicproxy.png"></a><div class="content"><a class="title" href="/2024/09/12/09%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84/" title="Java高级：动态代理、反射">Java高级：动态代理、反射</a><a class="article-recent_post_categories" href="/2024/09/12/09%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84/">Java开发</a></div></div></div></div></div></div></main><footer id="footer"><div id="st-footer-bar"><div class="footer-logo"><span>颓废市民黄先生</span></div><div class="footer-bar-description">来自 颓废市民黄先生 的文章</div><a class="footer-bar-link" href="/about/">了解更多</a></div><div id="footer_deal"></div><div id="st-footer"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div class="copyright">© 2024 By&nbsp;<a class="footer-bar-link" href="/">颓废市民黄先生</a></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/everfu/hexo-theme-solitude" alt="主题">主题</a><a class="footer-bar-link cc" href="/null" aria-label="copyright"><i class="solitude st-copyright-line"></i><i class="solitude st-creative-commons-by-line"></i><i class="solitude st-creative-commons-nc-line"></i><i class="solitude st-creative-commons-nd-line"></i></a></div></div></div><div class="comment-barrage needEndHide"></div></footer></div><!-- right_menu--><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="solitude st-arrow-left-line"></i></div><div class="rightMenu-item" id="menu-forward"><i class="solitude st-arrow-right-line"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="solitude st-restart-line"></i></div><div class="rightMenu-item" id="menu-top"><i class="solitude st-arrow-up-line"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="solitude st-copy-fill"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="solitude st-clipboard-fill"></i><span>粘贴文本</span></div><div class="rightMenu-item" id="menu-commenttext"><i class="solitude st-chat-new-fill"></i><span>引用到评论</span></div><div class="rightMenu-item" id="menu-newwindow"><i class="solitude st-window-fill"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="solitude st-link-line"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="solitude st-copy-fill"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="solitude st-download-cloud-fill"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-search"><i class="solitude st-search-line"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="solitude st-play-fill"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="solitude st-skip-back-fill"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="solitude st-skip-forward-fill"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="solitude st-copy-fill"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><div class="rightMenu-item" id="menu-randomPost" onclick="toRandomPost()||rm.hideRightMenu()"><i class="solitude st-signal-tower-fill"></i><span>随机短文</span></div><div class="rightMenu-item" onclick="pjax.loadUrl('/categories/')||rm.hideRightMenu()"><i class="solitude st-checkbox-multiple-blank-fill"></i><span>全部分类</span></div><div class="rightMenu-item" onclick="pjax.loadUrl('/tags/')||rm.hideRightMenu()"><i class="solitude st-price-tag-fill"></i><span>全部标签</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><div class="rightMenu-item" id="menu-commentBarrage" onclick="sco.switchCommentBarrage()"><i class="solitude st-chat-fill"></i><span class="menu-commentBarrage-text">关闭热评</span></div><div class="rightMenu-item" id="menu-darkmode" onclick="sco.switchDarkMode()"><i class="solitude st-moon-clear-fill"></i><span class="menu-darkmode-text">深色模式</span></div><div class="rightMenu-item" id="menu-translate"><i class="solitude st-panben-line"></i><span>轉為繁體</span></div></div></div><div id="rightmenu-mask"></div><!-- inject body--><div><script src="/js/utils.js?v=1.13.3"></script><script src="/js/main.js?v=1.13.3"></script><script src="/js/third_party/waterfall.min.js?v=1.13.3"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/js/third_party/universe.min.js?v=1.13.3"></script><script>dark()
</script><script src="/js/tw_cn.js?v=1.13.3"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/node-snackbar/0.1.16/snackbar.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/Swiper/11.0.5/swiper-bundle.min.js"></script><script src="/js/third_party/efu_ai.min.js?v=1.13.3"></script><script>var meting_api = 'https://meting.qjqq.cn/?server=:server&type=:type&id=:id&auth=:auth&r=:r';</script><script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/meting/2.0.1/Meting.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js"></script><script src="/js/right_menu.js?v=1.13.3"></script><script src="/js/custom.js"></script><div class="js-pjax"><script>(() => {
    const getCount = () => {
        const ele = document.querySelectorAll('.twikoo-count')
        if (!ele) return
        twikoo.getCommentsCount({
            envId: 'https://samurai127.cn',
            region: '',
            urls: [window.location.pathname],
            includeReply: false
        }).then(res => {
            ele.forEach(item => item.textContent = res[0].count)
        }).catch(err => {
            console.error(err)
        })
    }
    const init = () => {
        twikoo.init(Object.assign({
            el: '#twikoo-wrap',
            envId: 'https://samurai127.cn',
            region: '',
            path: window.location.pathname,
            onCommentLoaded: () => {
                GLOBAL_CONFIG.lightbox && utils.lightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
            }
        }, null))

         && getCount()
        sco.owoBig({
            body: '.OwO-body',
            item: '.OwO-items li'
        })

        true && barrageTwikoo()
    }

    const loadTwikoo = () => {
        if (typeof twikoo === 'object') setTimeout(init,0)
        else utils.getScript('https://cdnjs.cloudflare.com/ajax/libs/twikoo/1.6.36/twikoo.all.min.js').then(init)
    }

    if ('Twikoo' === 'Twikoo' || false) {
        if (false) utils.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
        else loadTwikoo()
    } else {
        window.loadTwoComment = loadTwikoo
    }
})()
</script><script>async function barrageTwikoo() {
    await fetch("https://samurai127.cn", {
        method: "POST",
        headers: {
            "Content-Type": "application/json"
        },
        body: JSON.stringify({
            event: "COMMENT_GET",
            accessToken: "",
            url: window.location.pathname
        })
    }).then(async res => {
        if (!res.ok) throw new Error("HTTP error! status: " + res.status)
        const data = await res.json();
        const init = () => {
            initializeCommentBarrage((data.data).map(item => Object.assign({
                content: item.comment,
                nick: item.nick,
                mailMd5: item.mailMd5,
                id: item.id
            })))
        }
        if (typeof initializeCommentBarrage === "undefined") await utils.getScript('/js/third_party/barrage.min.js?v=1.13.3').then(init)
        else init()
    }).catch(error => console.error("An error occurred while fetching comments: ", error))
}</script><script defer pjax src="https://cdnjs.cloudflare.com/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.min.js"></script></div></div><!-- pjax--><script>const pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: ['title','#body-wrap','#site-config','meta[name="description"]','.js-pjax','meta[property^="og:"]','#config-diff'],
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
})

document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
})

document.addEventListener('pjax:complete', () => {
    window.refreshFn()

    document.querySelectorAll('script[data-pjax]').forEach(item => {
        const newScript = document.createElement('script')
        const content = item.text || item.textContent || item.innerHTML || ""
        Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
        newScript.appendChild(document.createTextNode(content))
        item.parentNode.replaceChild(newScript, item)
    })

    GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

})

document.addEventListener('pjax:error', (e) => {
    if (e.request.status === 404) {
        pjax.loadUrl('/404.html')
    }
})</script><!-- theme--><script>initTheme = () => {
    let isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const cachedMode = utils.saveToLocal.get('theme');
    if (cachedMode === undefined) {
        const nowMode =
            isDarkMode ? 'dark' : 'light'
        document.documentElement.setAttribute('data-theme', nowMode);
    } else {
        document.documentElement.setAttribute('data-theme', cachedMode);
    }
    typeof rm === 'object' && rm.mode(cachedMode === 'dark' && isDarkMode)
}
initTheme()</script><!-- google adsense--><!-- search--><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="solitude st-close-fill"></i></button></nav><div class="search-wrap"><div class="search-box"><input class="search-box-input" id="search-input" type="text" autocomplete="off" spellcheck="false" autocorrect="off" autocapitalize="off" placeholder="输入关键词快速查找"></div><div id="search-results"><div id="search-hits"></div></div><div id="search-pagination"></div><div id="search-tips"></div></div></div><div id="search-mask"></div></div><script src="/js/search/local.js?v=1.13.3"></script><!-- Tianli-Talk--><span class="needEndHide" id="efuTalk" onclick="togglePostChatContainer(); return false;" title="问答ai"><i class="solitude st-robot-fill"></i><span class="efuTalkTitle">问答ai</span></span><script>var postChatConfig = {
backgroundColor: "var(--efu-main)",
bottom: "60px",
...{"defaultInput":false,"upLoadWeb":true,"userTitle":"小黄同学来也","userDesc":"有什么可以帮助你的？","showInviteLink":"https://ai.tianli0.top/?InviteID=OZ3Z0V2R","blackDom":[".aplayer"]}
};

let b = true;

document.getElementById('efuTalk').addEventListener('click', function () {
    this.classList.toggle('on');
    let efu = this
    b && setTimeout(() => {
        document.getElementById('close-button').addEventListener('click', function () {
            efu.classList.remove('on');
        })
    }, 0);
    b = false
});</script><script pjax data-postChat_key="449aa72132adf73ef7084ef83c46792af1edab" src="https://ai.tianli0.top/static/public/postChatUser.min.js"></script><!-- music--><div class="needEndHide" id="nav-music" onclick="sco.musicToggle()"><div id="nav-music-hoverTips">音乐已暂停</div><meting-js id="994057368" server="netease" type="playlist" mutex="true" preload="none" data-lrctype="0" order="random" theme="var(--efu-main)"></meting-js></div></body></html><script>const posts=["2024/09/14/微服务保护/","2024/09/14/11sentinel/","2024/09/14/12Resilience4J熔断、限流、重试/","2024/09/13/10seata/","2024/09/12/09动态代理和反射/","2024/09/11/08Nacos/","2024/09/11/07项目总结/","2024/09/09/06MQ进阶/","2024/09/04/05SpringAMQP/","2024/09/02/04Redis：（三）缓存设计/","2024/08/30/03Redis：（二）缓存问题/","2024/08/28/02Redis：（一）内存数据结构存储/","2024/08/23/01Mysql-sql优化/","2024/08/20/MySQL-分库分表/","2024/08/19/spring框架：面试知识/","2024/08/16/MySQL-MVCC/","2024/08/15/MySQL-锁/","2024/08/15/MySQL-存储引擎/","2024/08/15/MySQL-索引/","2024/08/13/JVM-gc/","2024/08/06/java：详解ConcurrentHashMap/","2024/08/05/java多线程：三、锁/","2024/08/04/java多线程：JMM/","2024/08/03/java-线程池/","2024/07/30/操作系统：（二）为什么0-1-0-2不等于0-3/","2024/07/14/搭建博客？本站搭建博客花费了多少精力？/","2024/07/09/算法：（四）递归/","2024/07/06/Java-JDK8函数式接口、lambda表达式、方法引用/","2024/07/06/算法：（三）链表/","2024/07/06/Docker实操/","2024/07/06/centOS部署docker/","2024/07/06/mybatis/","2024/07/06/JDBC 笔记/","2024/07/03/算法：（二）二分查找/","2024/07/03/操作系统：（一）快速学习存储器/","2024/07/03/算法：（一）排序算法/","2024/06/26/git速查/"];function toRandomPost(){ pjax.loadUrl(GLOBAL_CONFIG.root+posts[Math.floor(Math.random()*posts.length)]); }</script>