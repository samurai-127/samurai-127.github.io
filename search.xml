<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker：速速上手docker部署镜像</title>
    <url>/2024/07/06/Docker%E5%AE%9E%E6%93%8D/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p>
<ul>
<li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li>
<li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li>
</ul>
<h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>
<ul>
<li><p>依赖关系复杂，容易出现兼容性问题</p>
</li>
<li><p>开发、测试、生产环境有差异</p>
</li>
</ul>
<p><img src="image-20210731141907366-17202512119731.png"></p>
<p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p>
<h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p>
<p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p>
<ul>
<li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p>
</li>
<li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p>
</li>
</ul>
<p><img src="image-20210731142219735-17202512390553.png"></p>
<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p>
<p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p>
<h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p>
<p><img src="image-20210731143401460-17202512515745.png"></p>
<p>结构包括：</p>
<ul>
<li>计算机硬件：例如CPU、内存、磁盘等</li>
<li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li>
<li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li>
</ul>
<p>应用于计算机交互的流程如下：</p>
<p>1）应用调用操作系统应用（函数库），实现各种功能</p>
<p>2）系统函数库是对内核指令集的封装，会调用内核指令</p>
<p>3）内核指令操作计算机硬件</p>
<p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p>
<p><img src="image-20210731144304990-17202512906267.png"></p>
<p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p>
<p><img src="image-20210731144458680-17202513039019.png"></p>
<p>Docker如何解决不同系统环境的问题？</p>
<ul>
<li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li>
<li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li>
</ul>
<p>如图：</p>
<p><img src="image-20210731144820638-172025131387611.png"></p>
<h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>
<ul>
<li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>
<li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>
</ul>
<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>
<ul>
<li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li>
</ul>
<p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p>
<ul>
<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li>
<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>
<li>启动、移除都可以通过一行命令完成，方便快捷</li>
</ul>
<h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>
<p>两者有什么差异呢？</p>
<p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p>
<p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p>
<p><img src="image-20210731145914960-172025132358913.png"></p>
<p>对比来看：</p>
<p><img src="image-20210731152243765-172025133336715.png"></p>
<p>小结：</p>
<p>Docker和虚拟机的差异：</p>
<ul>
<li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p>
</li>
<li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p>
</li>
</ul>
<h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p>
<p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>
<p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p>
<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>
<p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p>
<p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p>
<p><img src="image-20210731153059464-172025134110517.png"></p>
<p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p>
<h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p>
<ul>
<li><p>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</p>
</li>
<li><p>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</p>
</li>
</ul>
<p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p>
<p><img src="image-20210731153743354-172025135047219.png"></p>
<h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p>
<p>Docker是一个CS架构的程序，由两部分组成：</p>
<ul>
<li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p>
</li>
<li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p>
</li>
</ul>
<p>如图：</p>
<p><img src="image-20210731154257653-172025136278221.png"></p>
<h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p>
<ul>
<li>将应用程序及其依赖、环境、配置打包在一起</li>
</ul>
<p>容器：</p>
<ul>
<li>镜像运行起来就是容器，一个镜像可以运行多个容器</li>
</ul>
<p>Docker结构：</p>
<ul>
<li><p>服务端：接收命令或远程请求，操作镜像或容器</p>
</li>
<li><p>客户端：发送命令或者请求到Docker服务端</p>
</li>
</ul>
<p>DockerHub：</p>
<ul>
<li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li>
</ul>
<h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考我的另外一篇博客。</p>
<h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p>
<ul>
<li>镜名称一般分两部分组成：[repository]:[tag]。</li>
<li>在没有指定tag时，默认是latest，代表最新版本的镜像</li>
</ul>
<p>如图：</p>
<p><img src="image-20210731155141362-172025139335023.png"></p>
<p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p>
<h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p>
<p><img src="image-20210731155649535-172025140269125.png"></p>
<h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p>
<p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p>
<p><img src="image-20210731155844368-172025141331627.png"></p>
<p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p>
<p><img src="image-20210731155856199-172025142614029.png"></p>
<p>3）通过命令：docker images 查看拉取到的镜像</p>
<p><img src="image-20210731155903037-172025143514131.png"></p>
<h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p>
<p>1）利用docker xx –help命令查看docker save和docker load的语法</p>
<p>例如，查看save命令用法，可以输入命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="image-20210731161104732-172025144806833.png"></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure>



<p>2）使用docker save导出镜像到磁盘 </p>
<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="image-20210731161354344-172025149206737.png"></p>
<p>3）使用docker load加载镜像</p>
<p>先删除本地的nginx镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure>



<p>然后运行命令，加载本地文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="image-20210731161746245-172025150212339.png"></p>
<h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p>
<p><img src="image-20210731161950495-172025151425541.png"></p>
<p>容器保护三个状态：</p>
<ul>
<li>运行：进程正常运行</li>
<li>暂停：进程暂停，CPU不再运行，并不释放内存</li>
<li>停止：进程终止，回收进程占用的内存、CPU等资源</li>
</ul>
<p>其中：</p>
<ul>
<li><p>docker run：创建并运行一个容器，处于运行状态</p>
</li>
<li><p>docker pause：让一个运行的容器暂停</p>
</li>
<li><p>docker unpause：让一个容器从暂停状态恢复运行</p>
</li>
<li><p>docker stop：停止一个运行的容器</p>
</li>
<li><p>docker start：让一个停止的容器再次运行</p>
</li>
<li><p>docker rm：删除一个容器</p>
</li>
</ul>
<h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li>docker run ：创建并运行一个容器</li>
<li>–name : 给容器起一个名字，比如叫做mn</li>
<li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>
<li>-d：后台运行容器</li>
<li>nginx：镜像名称，例如nginx</li>
</ul>
<p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p>
<p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p>
<p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p>
<p><img src="image-20210731163255863-172025152437243.png"></p>
<h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p>
<p><strong>提示</strong>：进入容器要用到docker exec命令。</p>
<p><strong>步骤</strong>：</p>
<p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li><p>docker exec ：进入容器内部，执行一个命令</p>
</li>
<li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p>
</li>
<li><p>mn ：要进入的容器的名称</p>
</li>
<li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p>
</li>
</ul>
<p>2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p>
<p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p>
<p><img src="image-20210731164159811-172025153479945.png"></p>
<p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p>
<p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p>
<p>我们执行命令，进入该目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure>

<p> 查看目录下文件：</p>
<p><img src="image-20210731164455818-172025154570447.png"></p>
<p>3）修改index.html的内容</p>
<p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure>



<p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.101，即可看到结果：">http://192.168.150.101，即可看到结果：</a></p>
<p><img src="image-20210731164717604-172025155924049.png"></p>
<h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p>
<ul>
<li>–name：指定容器名称</li>
<li>-p：指定端口映射</li>
<li>-d：让容器后台运行</li>
</ul>
<p>查看容器日志的命令：</p>
<ul>
<li>docker logs</li>
<li>添加 -f 参数可以持续查看日志</li>
</ul>
<p>查看容器状态：</p>
<ul>
<li>docker ps</li>
<li>docker ps -a 查看所有容器，包括已经停止的</li>
</ul>
<h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p>
<p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p>
<p><img src="image-20210731172440275-172025157161351.png"></p>
<p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>
<h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<p><img src="image-20210731173541846-172025159346453.png"></p>
<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p>
<p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p>
<h3 id="2-3-2-数据集操作命令"><a href="#2-3-2-数据集操作命令" class="headerlink" title="2.3.2.数据集操作命令"></a>2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>

<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>
<ul>
<li>create 创建一个volume</li>
<li>inspect 显示一个或多个volume的信息</li>
<li>ls 列出所有的volume</li>
<li>prune 删除未使用的volume</li>
<li>rm 删除一个或多个指定的volume</li>
</ul>
<h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p>
<p>① 创建数据卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></table></figure>



<p>② 查看所有数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="image-20210731173746910-172025160602555.png"></p>
<p>③ 查看数据卷详细信息卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="image-20210731173809877-172025161650357.png"></p>
<p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p>
<p><strong>小结</strong>：</p>
<p>数据卷的作用：</p>
<ul>
<li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li>
</ul>
<p>数据卷操作：</p>
<ul>
<li>docker volume create：创建数据卷</li>
<li>docker volume ls：查看所有数据卷</li>
<li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li>
<li>docker volume rm：删除指定数据卷</li>
<li>docker volume prune：删除所有未使用的数据卷</li>
</ul>
<h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure>

<p>这里的-v就是挂载数据卷的命令：</p>
<ul>
<li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中</li>
</ul>
<h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p>
<p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p>
<p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p>
<p>步骤：</p>
<p>① 创建容器并挂载数据卷到容器内的HTML目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>



<p>② 进入html数据卷所在位置，并修改HTML内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure>



<h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p>
<ul>
<li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li>
<li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li>
</ul>
<p>如图：</p>
<p><img src="image-20210731175155453-172025163822859.png"></p>
<p><strong>语法</strong>：</p>
<p>目录挂载与数据卷挂载的语法是类似的：</p>
<ul>
<li>-v [宿主机目录]:[容器内目录]</li>
<li>-v [宿主机文件]:[容器内文件]</li>
</ul>
<p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p>
<p>实现思路如下：</p>
<p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p>
<p>2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data</p>
<p>3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf</p>
<p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p>
<p>① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录</p>
<p>② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件</p>
<p>③ 设置MySQL密码</p>
<h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p>
<ul>
<li>-v volume名称:容器内目录</li>
<li>-v 宿主机文件:容器内文</li>
<li>-v 宿主机目录:容器内目录</li>
</ul>
<p>数据卷挂载与目录直接挂载的</p>
<ul>
<li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li>
<li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li>
</ul>
<h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p>
<p>而要自定义镜像，就必须先了解镜像的结构才行。</p>
<h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>
<p>我们以MySQL为例，来看看镜像的组成结构：</p>
<p><img src="image-20210731175806273-172025168205161.png"></p>
<p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p>
<p>我们要构建镜像，其实就是实现上述打包的过程。</p>
<h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p>
<p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p>
<p>而描述上述信息的文件就是Dockerfile文件。</p>
<p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p>
<p><img src="image-20210731180321133-172025169038663.png"></p>
<p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p>
<h2 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3.小结"></a>3.3.小结</h2><p>小结：</p>
<ol>
<li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p>
</li>
<li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p>
</li>
<li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p>
</li>
</ol>
<h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><h2 id="4-1-dockerCompose介绍"><a href="#4-1-dockerCompose介绍" class="headerlink" title="4.1 dockerCompose介绍"></a>4.1 dockerCompose介绍</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">version<span class="punctuation">:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"> services<span class="punctuation">:</span></span><br><span class="line">  mysql<span class="punctuation">:</span></span><br><span class="line">    image<span class="punctuation">:</span> mysql<span class="punctuation">:</span><span class="number">5.7</span><span class="number">.25</span></span><br><span class="line">    environment<span class="punctuation">:</span></span><br><span class="line">     MYSQL_ROOT_PASSWORD<span class="punctuation">:</span> <span class="number">123</span> </span><br><span class="line">    volumes<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span></span><br><span class="line">  web<span class="punctuation">:</span></span><br><span class="line">    build<span class="punctuation">:</span> .</span><br><span class="line">    ports<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的Compose文件就描述一个项目，其中包含两个容器：</p>
<ul>
<li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li>
<li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li>
</ul>
<p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p>
<p>​                         </p>
<h2 id="4-2-dockerCompose案例（没做实操）"><a href="#4-2-dockerCompose案例（没做实操）" class="headerlink" title="4.2 dockerCompose案例（没做实操）"></a>4.2 dockerCompose案例（没做实操）</h2><p>dockerCompose底层可以直接使用服务名称连接到对应微服务而不是用地址，比如配置nacos的地址，在Java的application.yml文件的spring的addr中配置之前写的是localhost：10086，但是其他主机访问不到。dockerCompose能够使用服务名称跨设备访问微服务。nacos：10086。</p>
<p> <img src="Composedemo-172025204419373.png"></p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>软件技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC：Java语言连接数据库</title>
    <url>/2024/07/06/JDBC%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、-什么是JDBC"><a href="#一、-什么是JDBC" class="headerlink" title="一、 什么是JDBC"></a>一、 什么是JDBC</h1><p><em>JDBC（Java DataBase Connectivity）</em>是Java数据库连接技术的简称，提供连接和操作各种常用数据库的能力，JDBC只定义了Java应用程序访问数据库的标准接口层，而对于不同的数据库而言则由数据库厂商去实现JDBC接口层的功能 （叫做数据库驱动程序包）。</p>
<h1 id="二、-JDBC工作原理"><a href="#二、-JDBC工作原理" class="headerlink" title="二、  JDBC工作原理"></a>二、  JDBC工作原理</h1><p><img src="image-20230509201759580-3634684.png"></p>
<p>JDBC驱动程序包实际上是对JDK jdbc api的具体实现。可以理解成JDBC只定义了与数据库通信的规范和协议，而这些规范的具体实现由各数据库厂商自己实现也只有数据库厂商才知道怎样操作自己的数据库。</p>
<p><img src="image-20230509201842721-3634725.png"></p>
<h1 id="三、-JDBC访问数据库的步骤"><a href="#三、-JDBC访问数据库的步骤" class="headerlink" title="三、  JDBC访问数据库的步骤"></a>三、  JDBC访问数据库的步骤</h1><p>准备工作：把驱动程序包<em>mysql-connector-j-8.2.0.jar</em>引入<strong>项目依赖</strong>，</p>
<p><em>Project Structure</em> —&gt;选中<em>module</em> —&gt; <em>Dependency</em> —&gt;点击右侧<em>”+”</em>号添加依赖库。</p>
<ol>
<li><p>注册数据库动程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/scott&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//1. 注册数据库动程序</span></span><br><span class="line">  Class.forName(DRIVER);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  System.err.println(<span class="string">&quot;注册数据库驱动失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>java.sql.DriverManager</code> 获得数据库连接 <code>java.sql.Connection</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="comment">//2. 通过`java.sql.DriverManager` 获得数据库连接 `java.sql.Connection`</span></span><br><span class="line">conn = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>java.sql.Connection</code> 创建语句对象 <code>java.sql.Statement</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//3. 通过 `java.sql.Connection` 创建语句对象 `java.sql.Statement`</span></span><br><span class="line">stmt = conn.createStatement();</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 SQL 语句</p>
<ul>
<li><p><strong>select 查询</strong>：<em>java.sql.ResultSet  statement.exceuteQuery( sql : String )</em> 返回结果集对象</p>
</li>
<li><p><strong>insert, update, delete 语句</strong>：<em>int  statement.executeUpate( sql : String )</em> 返回整数，此操作数据库影响的行数。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">//4.执行 SQL 语句获得结果集对象</span></span><br><span class="line">rs = stmt.executeQuery(<span class="string">&quot;select * from emp&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历查询结果集 <code>java.sql.ResultSet</code>（select 操作）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 遍历查询结果集 `java.sql.ResultSet`（select 操作）</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123; <span class="comment">//遍历每一行</span></span><br><span class="line">  <span class="comment">//取每一列</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">empno</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;empno&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">ename</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;ename&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;job&quot;</span>);</span><br><span class="line">  <span class="type">int</span> <span class="variable">mgr</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;mgr&quot;</span>);</span><br><span class="line">  <span class="type">Date</span> <span class="variable">hiredate</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;hiredate&quot;</span>);</span><br><span class="line">  <span class="type">double</span> <span class="variable">sal</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;sal&quot;</span>);</span><br><span class="line">  <span class="type">double</span> <span class="variable">comm</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;comm&quot;</span>);</span><br><span class="line">  <span class="type">int</span> <span class="variable">deptno</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;deptno&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(empno, ename, job, mgr, hiredate, sal, comm, deptno);</span><br><span class="line">  employees.add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 <code>java.sql.ResultSet</code>、<code>java.sql.Statement</code>、<code>java.sql.Connection</code> 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//6. 关闭 `java.sql.ResultSet`、`java.sql.Statement`、`java.sql.Connection` 对象</span></span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">      rs.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">      stmt.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">      conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;关闭数据资源失败！&quot;</span> + e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="image-20230509201950686-3634794.png"></p>
<blockquote>
<p><strong>注意：</strong></p>
<p>注册数据驱动只需在整个项目运行时注册一次即可。不需要每次获取<code>Connection</code> 时都去注册驱动。注册数据库驱动程序后其它的类再去访问数据库时 JVM 就能找得到数据库驱动了，所以通常把注册驱动的代码写在某个类的*static{ ….. }*静态初始化块中。</p>
</blockquote>
<h3 id="3-1-各数据库-URL"><a href="#3-1-各数据库-URL" class="headerlink" title="3.1 各数据库 URL"></a>3.1 各数据库 URL</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//url格式：协议:子协议:主机:port:数据库</span></span><br><span class="line"><span class="comment">//SQL Server</span></span><br><span class="line"><span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:sqlserver://localhost:1433;DatabaseName=数据库名&quot;</span>;</span><br><span class="line"><span class="comment">//Oracle</span></span><br><span class="line"><span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:oracle:thin:@localhost:1521:ORCL(实例名,SID)&quot;</span>;</span><br><span class="line"><span class="comment">//MySQL</span></span><br><span class="line"><span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/数据库名?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="四、-JDBC-API-类"><a href="#四、-JDBC-API-类" class="headerlink" title="四、 JDBC API 类"></a>四、 JDBC API 类</h1><h2 id="4-1-Connection常用方法"><a href="#4-1-Connection常用方法" class="headerlink" title="4.1 Connection常用方法"></a>4.1 Connection常用方法</h2><ol>
<li><p><code>close()</code>：立即释放此 Connection 对象的数据库和 JDBC 资源，而不是等待它们被自动释放。</p>
</li>
<li><p><code>commit()</code> ：提交SQL操作，默认是自动提交SQL操作，很少情况需要手动提交。</p>
</li>
<li><p>createStatement() ：创建一个 Statement (普通语句)对象并将 SQL 语句发送到数据库去执行。</p>
</li>
<li><p><code>prepareStatement(String sql)</code>：创建一个 <code>PreparedStatement</code>(预编译语句) 对象来将参数化的 SQL 语句发送到数据库，其后对<strong>占位符</strong>设置参数，这种语句类型可获得更好的性能。</p>
</li>
<li><p><code>prepareCall(String sql)</code> ：创建一个 <code>CallableStatement</code> 对象来调用数据库存储过程。</p>
</li>
<li><p>必须在 <em>finally</em> 块中关闭<code>Connection</code>。</p>
</li>
<li><p><code>void rollback()</code>：取消在当前事务中进行的所有更改，并释放此 <code>Connection</code> 对象当前持有的所有数据库锁。</p>
</li>
<li><p><code>void setAutoCommit(boolean autoCommit):</code> 将此连接的自动提交模式设置为给定状态。</p>
</li>
</ol>
<h2 id="4-2-Statement常用方法"><a href="#4-2-Statement常用方法" class="headerlink" title="4.2 Statement常用方法"></a>4.2 Statement常用方法</h2><ol>
<li><p><strong>（不推荐用）</strong><code>Boolean execute(String sql)</code> ：执行给定的 SQL 语句（增删改查语句都可以），该语句可能返回多个结果。</p>
</li>
<li><p><code>ResultSet executeQuery(String sql)</code> : 执行给定的 SQL 查询语句，该语句返回单个 <code>ResultSet</code> 对象。</p>
</li>
<li><p><code>int intexecuteUpdate(Stringsql)</code>: 执行给定 SQL 语句，该语句可能为 <em>INSERT、UPDATE 或 DELETE</em> 语句，或者不返回任何内容的 SQL 语句（如 DDL 语句）。</p>
</li>
<li><p><code>setQueryTimeout(int seconds)</code> ：将驱动程序等待 <code>Statement</code> 对象执行的秒数设置为给定秒数。</p>
</li>
<li><p>必须在finally块中关闭<code>Statement</code>。</p>
</li>
</ol>
<h2 id="4-3-ResultSet常用方法"><a href="#4-3-ResultSet常用方法" class="headerlink" title="4.3  ResultSet常用方法"></a>4.3  ResultSet常用方法</h2><ol>
<li><p><code>next()</code>: 将光标从当前位置向前移一行。ResultSet 光标最初位于第一行之前；第一次调用 next 方法使第一行成为当前行；第二次调用使第二行成为当前行，依此类推。</p>
</li>
<li><p><code>close()</code> ：立即释放此 ResultSet 对象的数据库和 JDBC 资源，而不是等待该对象自动关闭时发生此操作。</p>
</li>
<li><p><code>getXxx(int columnIndex)</code> ：使用列索引来获取数据，Xxx表示相应的数据类型。</p>
</li>
</ol>
<p>​		例如：</p>
<ul>
<li>获字符串用<em>getString(int columnIndex)，getString(String columnNanme)</em></li>
<li>获取整数用<em>getInt(int columnIndex),  getInt(String columnName)</em></li>
</ul>
<p>d)   必须在<code>finally</code>块中关闭<code>ResultSet</code>。</p>
<h1 id="五、PreparedStatement"><a href="#五、PreparedStatement" class="headerlink" title="五、PreparedStatement"></a>五、PreparedStatement</h1><ol>
<li><p>预编译语句<code>PreparedStatement</code>是<code>Statement</code>的子类</p>
</li>
<li><p>为什么要使用预编译语句？</p>
<ul>
<li><p>执行效率高</p>
</li>
<li><p>安全</p>
</li>
<li><p>支持参数值占位符：？</p>
</li>
</ul>
</li>
</ol>
<p><img src="image-20230509215556993-3640563.png"></p>
<p>SQL中的 “**- -**” 把后面的语句给注掉了，这样就出现了SQL漏洞。预编译语句可以避免此类问题的发生。</p>
<p>如果要多次执行相似的SQL语句，如：一次插入（更新、删除）几百条记录; 又如不同用户登录执行 SQL语句只有用户名和密码不同。可以使用<code>PreparedStatement</code>（预编译语句对象）对象来执行。由于预编译语句使用占位符 ”?”，在执行SQL之前语句会被先发送到数据库服务器进行语法检查和编译等工作，并将SQL语句加入到数据库的语句缓冲池里，随后再对SQL语句中的占位符 <strong>”?”</strong> 设置定值。那么也就说如果你要执行1000行插入的时候第一次先SQL语句发送给数据库服务器处理，接着后面只需传递占位符的值就可以了。因此它不需每次传递大量的SQL语句也无需对每条SQL语句做语法检查和编译所以比较高效。</p>
<ol start="3">
<li>通过Connection的prepareStatement( sql )方法来创建预编译语句对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(Employee e)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> (</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">  ) &#123;</span><br><span class="line">      <span class="comment">//? 占位符只能对赋值的地方占位，</span></span><br><span class="line">      <span class="comment">//如：where empno=?;    update emp set ename=? ....</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into emp(ename,job,mgr,hiredate,sal,comm,deptno) values (?,?,?,?,?,?,?)&quot;</span>; </span><br><span class="line">      <span class="comment">//1.先创建预编译语句，占位符只能给值进行占位</span></span><br><span class="line">      <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//2.再给？(点位符)设置值, 占位符索引位置从1开始</span></span><br><span class="line">      ps.setString(index++, e.getEname());</span><br><span class="line">      ps.setString(index++, e.getJob());</span><br><span class="line">      ps.setInt(index++, e.getMgr());</span><br><span class="line">      ps.setDate(index++, <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(e.getHiredate().getTime()));</span><br><span class="line">      ps.setDouble(index++, e.getSal());</span><br><span class="line">      <span class="comment">//如果列允许为空时，需要作一下JDBC 的空值处理, setNull(i, sqlType);</span></span><br><span class="line">      <span class="keyword">if</span>(e.getComm()==<span class="literal">null</span>)&#123;</span><br><span class="line">          ps.setNull(index++, java.sql.Types.DOUBLE);</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          ps.setDouble(index++,e.getComm());</span><br><span class="line">      &#125;</span><br><span class="line">      ps.setInt(index++, e.getDeptno());</span><br><span class="line">      <span class="comment">//3.执行，不能再指定SQL 语句</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">          System.err.println(<span class="string">&quot;&gt;&gt;2.新增员工实体失败：&quot;</span> + ex.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-常用方法"><a href="#5-1-常用方法" class="headerlink" title="5.1 常用方法"></a>5.1 常用方法</h2><ul>
<li><p><code>boolean   execute()</code>：在此 <code>PreparedStatement</code> 对象中执行 SQL 语句，该语句可以是任何种类的 SQL 语句。</p>
</li>
<li><p><code>ResultSet executeQuery()</code> 在此 <code>PreparedStatement</code> 对象中执行 SQL 查询，并返回该查询生成的 ResultSet 对象。</p>
</li>
<li><p><code>int executeUpdate()</code>：在此 <code>PreparedStatement</code> 对象中执行 SQL 语句，该语句必须是一个 SQL 数据操作语言<em>（Data Manipulation Language，DML）</em>语句，比如 <em>INSERT、UPDATE 或 DELETE</em> 语句；或者是无返回内容的 SQL 语句，比如 DDL 语句。</p>
</li>
<li><p><code>void setXxx(int parameterIndex, Xxx value)</code>: Xxx表示相应的数据类型，如：setString(…), setInt(…)等。设置点位符位置的值，第一个参数是 1，第二个参数是 2，…..</p>
</li>
<li><p><code>setNull(int parameterIndex, java.sql.Types value)</code>: 插入或更新时处理空值的字段，通常对非<code>char, varchar</code>类型字段空值时使用。</p>
</li>
<li><p>必须在 <em>finally</em> 块中关闭<code>PreparedStatement</code>。</p>
</li>
</ul>
<h2 id="5-2-PreparedStatement与Statement的对比"><a href="#5-2-PreparedStatement与Statement的对比" class="headerlink" title="5.2 PreparedStatement与Statement的对比"></a>5.2 PreparedStatement与Statement的对比</h2><table>
<thead>
<tr>
<th></th>
<th>Statement</th>
<th>PreparedStatement</th>
</tr>
</thead>
<tbody><tr>
<td>创建语句对象的方法</td>
<td><em>Connection.createStatement( )</em>  创建语句对象时 不提供SQL</td>
<td><em>Connection.preparedStatement( sql )</em>  创建语句对象时 提供SQL</td>
</tr>
<tr>
<td>查询</td>
<td><em>executeQuery( sql )</em>  要提供SQL语句</td>
<td><em>executeQuery( )</em>  不提供提供SQL语句，但随后要设置占位符的值</td>
</tr>
<tr>
<td>插入、更新、删除</td>
<td><em>executeUpdate( sql )</em>  要提供SQL语句</td>
<td><em>executeUpdate( )</em>  不提供提供SQL语句</td>
</tr>
</tbody></table>
<h1 id="六-存储过程调用"><a href="#六-存储过程调用" class="headerlink" title="六. 存储过程调用"></a>六. 存储过程调用</h1><p>调用存储过程可以使用<code>CallableStatement</code>语句类型来调用。</p>
<ol>
<li><p>通过conn.prepareCall(<strong>“</strong>{call find_employee(?,?)}”); 获得一个使用CallableStatement语句对象。</p>
</li>
<li><p>设置<em>输入（IN模式）参数</em>的值和注册<em>输出（OUT模式）参数</em>。</p>
<ul>
<li><p>设置输入（IN模式）参数的值使用：</p>
<p><code>CallableStatement.setString(parameterIndex, value);</code></p>
<p>根据参数类型选择调用相应的方法。</p>
</li>
<li><p>注册输出（OUT模式）参数:</p>
</li>
</ul>
</li>
</ol>
<p>​			<code>CallableStatement.registerOutParameter(OUT_ ParameterIndex, java.sql.Types.类型常量);</code></p>
<ol start="3">
<li>获得输出参数的值使用方法：getString (输出参数的索引位置); 根据输出参数类型调用相应的方法。</li>
</ol>
<ul>
<li><strong>示例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用存储过程</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProcedure</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">//调用存储过程必须用CallableStatement语句对象，它是PreparedStatement的子类</span></span><br><span class="line">    <span class="type">CallableStatement</span> <span class="variable">cs</span> <span class="operator">=</span></span><br><span class="line">            <span class="built_in">this</span>.conn.prepareCall(<span class="string">&quot;&#123;call get_job_sum_sal(?,?)&#125;&quot;</span>); <span class="comment">//第二个？号的参数模式是out</span></span><br><span class="line">    <span class="comment">//设置点位符的值</span></span><br><span class="line">    cs.setString(<span class="number">1</span>, <span class="string">&quot;SALESMAN&quot;</span>);</span><br><span class="line">    cs.setDouble(<span class="number">2</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">//若过程有输出参数模式的，必须在过程执行前注册输出参数，也是说要告诉oracle驱动要得到哪个占位符的值 </span></span><br><span class="line">    cs.registerOutParameter(<span class="number">2</span>, java.sql.Types.DOUBLE, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行过程</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> cs.execute();</span><br><span class="line">    <span class="comment">//得到结果，即过程的输出参数的值</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> cs.getDouble(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;SALESMAN的总工资：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七-批量更新"><a href="#七-批量更新" class="headerlink" title="七. 批量更新"></a>七. 批量更新</h1><h2 id="7-1-Statement-批量更新"><a href="#7-1-Statement-批量更新" class="headerlink" title="7.1 Statement 批量更新"></a>7.1 Statement 批量更新</h2><p>用Statement对象执行批量更新时，用到addBatch()和executeBatch()方法。</p>
<p><em>insert</em> 和 <em>delete</em> 操作与<em>update</em> 操作相似。</p>
<ul>
<li><strong>示例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JdbcUtil.getConnection();</span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//1.设置自动提交事务为 false</span></span><br><span class="line">    connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    statement = connection.createStatement();</span><br><span class="line">    <span class="comment">//2.使用addBatch（）方法添加要在批处理中执行的SQL语句。然后使用executeBatch（）执行SQL语句。</span></span><br><span class="line">    statement.addBatch(<span class="string">&quot;update people set firstname=&#x27;aaa&#x27; where id=123&quot;</span>);</span><br><span class="line">    statement.addBatch(<span class="string">&quot;update people set firstname=&#x27;bbb&#x27; where id=456&quot;</span>);</span><br><span class="line">    statement.addBatch(<span class="string">&quot;update people set firstname=&#x27;ccc&#x27;  where id=789&quot;</span>);</span><br><span class="line">		<span class="comment">//返回每条件语句数据受影响的行数</span></span><br><span class="line">    <span class="type">int</span>[] recordsAffected = statement.executeBatch();</span><br><span class="line">    <span class="comment">//3.1 提交事务</span></span><br><span class="line">    connection.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">  	<span class="comment">//3.2 回滚事务</span></span><br><span class="line">  	connection.rollback();</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-PreparedStatement-批量更新"><a href="#7-2-PreparedStatement-批量更新" class="headerlink" title="7.2 PreparedStatement 批量更新"></a>7.2 PreparedStatement 批量更新</h2><p>使用<code>PreparedStatement</code>对象执行批量更新。<code>PreparedStatement</code><em>可以重用相同的SQL语句</em>，并只需插入新参数即可执行每个更新。</p>
<p><em>insert</em> 和 <em>delete</em> 操作与<em>update</em> 操作相似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JdbcUtil.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update PEOPLE set firstname=? where id=?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//1.设置自动提交事务为 false</span></span><br><span class="line">    connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">  	<span class="comment">//2.添加语句组，并为每条语句设置参数值</span></span><br><span class="line">    <span class="comment">//第1条记录</span></span><br><span class="line">    preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;james&quot;</span>);</span><br><span class="line">    preparedStatement.setLong  (<span class="number">2</span>, <span class="number">123</span>);</span><br><span class="line">    <span class="comment">//加入到批量处理</span></span><br><span class="line">    preparedStatement.addBatch();</span><br><span class="line">    <span class="comment">//第2条记录</span></span><br><span class="line">    preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">    preparedStatement.setLong  (<span class="number">2</span>, <span class="number">456</span>);</span><br><span class="line">    preparedStatement.addBatch();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] affectedRecords = preparedStatement.executeBatch();</span><br><span class="line">    <span class="comment">//3.1 提交事务</span></span><br><span class="line">    connection.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">  	<span class="comment">//3.2 回滚事务</span></span><br><span class="line">  	connection.rollback();</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preparedStatement != <span class="literal">null</span>) &#123;</span><br><span class="line">            preparedStatement.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		将每组参数值插入到preparedStatement中，并调用*addBatch( )<em>方法。 这会将参数值添加到批处理内部。 现在可以添加另一组值，以便插入到SQL语句中。 将全部批次发送到数据库后，将每组参数插入到SQL中并分别执行。然后执行</em>executeBatch( )*方法，它执行所有的批量更新。 SQL语句和参数集一起发送到数据库。</p>
<p><strong>注意: 批量操作应该放到事务里进行，因为它会存在某条语句执行失败的情况。</strong></p>
<h1 id="八-Java数据类型与SQL类型的映射"><a href="#八-Java数据类型与SQL类型的映射" class="headerlink" title="八. Java数据类型与SQL类型的映射"></a>八. Java数据类型与SQL类型的映射</h1><h2 id="8-1-Conversions-by-setObject-index-value"><a href="#8-1-Conversions-by-setObject-index-value" class="headerlink" title="8.1 Conversions by setObject(index, value)"></a>8.1 Conversions by setObject(index, value)</h2><p>下表说明了可用*Statement.setObject(index, value)和 PreparedStatement.setObject(index, value)*方法支持将Java类型到JDBC类型赋值。</p>
<p><img src="clip_image001.png"></p>
<p>An “x” means that the given Java object type may be converted to the given JDBC type. This table show the possible values for the parameter specifying a target JDBC type that is passed to the method PreparedStatement.setObject or RowSet.setObject. Note that some conversions may fail at run time if the value presented is invalid.</p>
<h2 id="8-2-Conversions-by-ResultSet-getXXX-Methods"><a href="#8-2-Conversions-by-ResultSet-getXXX-Methods" class="headerlink" title="8.2 Conversions by ResultSet.getXXX Methods"></a>8.2 Conversions by ResultSet.getXXX Methods</h2><p><img src="clip_image001-3697769-3697774.png"></p>
<p><code>SQLInput.readXXX</code> methods support only the recommended conversions. An “x” means that the method <em>can</em> retrieve the JDBC type. An “<strong>X</strong>“ means that the method is <em>recommended</em> for retrieving the JDBC type.</p>
<h1 id="九、apache-DButils-组件库"><a href="#九、apache-DButils-组件库" class="headerlink" title="九、apache DButils 组件库"></a>九、apache DButils 组件库</h1><p>dbutils是apache 中的一个简化了jdbc的编程的工具组件库。</p>
<p>下载地址：<a href="https://commons.apache.org/proper/commons-dbutils/">DbUtils – JDBC Utility Component (apache.org)</a></p>
<p>官方示例：<a href="https://commons.apache.org/proper/commons-dbutils/examples.html">DbUtils – JDBC Utility Component – Examples (apache.org)</a></p>
<h2 id="9-1-ResultSetHandler结果集处理器接口"><a href="#9-1-ResultSetHandler结果集处理器接口" class="headerlink" title="9.1 ResultSetHandler结果集处理器接口"></a>9.1 ResultSetHandler结果集处理器接口</h2><p><code>ResultSetHandler</code> 的功能是将查询结果的列名与JavaBean对象的属性名(setter方法)进行反射赋值，有以下几个常用实现类：</p>
<ul>
<li><p><code>BeanHandler</code>：JavaBean处理器。将查询结果集 <code>ResultSet</code>的一行仅且一行封装成一个JavaBean对象。</p>
</li>
<li><p><code>BeanListHandler</code>：JavaBean列表处理器。 将多行查询集 <code>ResultSet</code>封装成一个JavaBean列表。</p>
</li>
<li><p><code>MapHandler</code>：Map处理器。将查询结果集的一行仅且一行封装成一个<em>Map</em>对象，结果集的列名作为 Map 的<em>key</em>，值作为Map 的<em>value</em>;</p>
</li>
<li><p><code>MapListHandler</code>： Map列表处理器。返回一个列表其元素为Map，查询结果集的每一行封装成一个Map对象，结果的列名作为key，值作为value;</p>
</li>
<li><p><code>ScalarHandler</code>: 标量类型处理器。将只有一行一列的查询结果集封装成一个基本类型的值，如：<em>Select  count(*)  as rows  from  employee</em>;</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将查询结果集通过反射机制封装成一个JavaBean实体，查询结果的列名将与JavaBean的属性名进行反射（实际上是调用 JavaBean 的setter方法）</span></span><br><span class="line"><span class="comment">//如果结果集的列有与 JavaBean 属性名不同时，可通过给列名取别名的方式使之与JavaBean 属性名一样</span></span><br><span class="line">ResultSetHandler&lt;Employee&gt;  rsh = <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;Employee&gt;(Employee.class); </span><br><span class="line">runner.query(conn, sql, rsh [,Object... params]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将查询结果集通过反射机制封装成一个JavaBean实体列表</span></span><br><span class="line">ResultSetHandler&lt;Employee&gt;  rsh = <span class="keyword">new</span> <span class="title class_">BeanListHandler</span> &lt;Employee&gt;(Employee.class);</span><br><span class="line">runner.query(conn, sql, rsh [,Object... params]);</span><br></pre></td></tr></table></figure>

<h2 id="9-2-QueryRunner-SQL执行操作类-多线程安全"><a href="#9-2-QueryRunner-SQL执行操作类-多线程安全" class="headerlink" title="9.2 QueryRunner SQL执行操作类(多线程安全)"></a>9.2 QueryRunner SQL执行操作类(多线程安全)</h2><p>官方是这样解释的：</p>
<blockquote>
<p>Executes SQL queries with pluggable strategies for handling <code>ResultSet</code>s. This class is thread safe.</p>
</blockquote>
<p>所有对数据库的CRUD操作都通过 <code>QueryRunner</code> 完成。</p>
<p>如果创建<code>QueryRunner</code>实例时没有提供<code>DataSource</code>数据源参数则在执行CRUD操作方法时需提供数据库连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式 1: 不使用数据源</span></span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//方式 2：使用数据源，数据源通过其它方式获得并传入构造中</span></span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>([DataSource]);</span><br></pre></td></tr></table></figure>

<h3 id="普通查询（无占位符参数）"><a href="#普通查询（无占位符参数）" class="headerlink" title="普通查询（无占位符参数）"></a>普通查询（无占位符参数）</h3><p>以下示例均以junit 单元测试提供。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuerySingleEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from emp where ename=&#x27;ZHANG&#x27;&quot;</span>;</span><br><span class="line">    <span class="comment">//默认dbutil会通过结果集的类名与bean的属性名进行反射，</span></span><br><span class="line">    <span class="comment">//如果列名与bean的属性名不一致时可以为列名取别名来解决</span></span><br><span class="line">    ResultSetHandler&lt;Employee&gt; rsh = <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;Employee&gt;(Employee.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> runner.query(conn, sql, rsh);</span><br><span class="line">      System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带占位符参数查询"><a href="#带占位符参数查询" class="headerlink" title="带占位符参数查询"></a>带占位符参数查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryEmployeeList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//复杂查询时SQL语句需动态构建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from emp where ename like ? and sal between ? and ?&quot;</span>;</span><br><span class="line">    <span class="comment">//默认dbutil会通过结果集的类名与bean的属性名进行反射，</span></span><br><span class="line">    <span class="comment">//如果列名与bean的属性名不一致时可以为列名取别名来解决</span></span><br><span class="line">    ResultSetHandler&lt;List&lt;Employee&gt;&gt; rsh = <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;Employee&gt;(Employee.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; list = runner.query(conn, sql, rsh,<span class="string">&quot;%A%&quot;</span>,<span class="number">1000.0</span>,<span class="number">5000.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list) &#123;</span><br><span class="line">          System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标量查询"><a href="#标量查询" class="headerlink" title="标量查询"></a>标量查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(empno) AS r from emp&quot;</span>;</span><br><span class="line">    ResultSetHandler&lt;BigDecimal&gt; rsh = <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>&lt;BigDecimal&gt;(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">rows</span> <span class="operator">=</span> runner.query(conn, sql, rsh);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> rows.intValue();</span><br><span class="line">        System.out.println(rows);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//SQL语句可能需动态构建，参考以前JDBC的代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into emp(EMPNO,ENAME,MGR,HIREDATE,SAL,DEPTNO) values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回数据库受影响的行数，即插入的行数</span></span><br><span class="line">      	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> runner.update(conn, sql, <span class="number">8136</span>,<span class="string">&quot;Alex&quot;</span>,<span class="number">7369</span>,<span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="keyword">new</span> <span class="title class_">Date</span>().getTime()),<span class="number">4440.0</span>,<span class="number">10</span>);</span><br><span class="line">      	System.out.println(i);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//SQL语句可能需动态构建，参考以前JDBC的代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update emp set ENAME=?,JOB=?,SAL=? Where EMPNO=?&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回数据库受影响的行数，即更新的行数</span></span><br><span class="line">      	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> runner.update(conn, sql, <span class="number">8136</span>,<span class="string">&quot;Alex&quot;</span>,<span class="number">7369</span>,<span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="keyword">new</span> <span class="title class_">Date</span>().getTime()),<span class="number">4440.0</span>,<span class="number">10</span>);</span><br><span class="line">      	System.out.println(i);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//SQL语句可能需动态构建，参考以前JDBC的代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete employee Where EMPNO=?&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回数据库受影响的行数，即删除的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> runner.update(conn, sql, <span class="number">8136</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：JDK8函数式接口、lambda表达式、方法引用</title>
    <url>/2024/07/06/Java-JDK8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一、函数式接口"><a href="#一、函数式接口" class="headerlink" title="一、函数式接口"></a>一、函数式接口</h1><p>只有一个抽象方法的接口就成为函数式接口。同时，引入了一个新的注解：@FunctionalInterface。可以把他它放在一个接口前，表示这个接口是一个函数式接口。这个注解是非必须的，只要接口只包含一个方法的接口，虚拟机会自动判断，不过最好在接口上使用注解 @FunctionalInterface 进行声明。在接口中添加了 @FunctionalInterface 的接口，只允许有一个抽象方法，否则编译器也会报错。</p>
<p>举例几个Java常用的函数式接口：predicate断言型接口、consumer消费者接口、supplier提供者接口、Function接口等。</p>
<p><strong>记好一句话：函数式接口可以接收匿名内部类和lambda表达式</strong></p>
<p><strong>记好一句话：函数式接口可以接收匿名内部类和lambda表达式</strong></p>
<p><strong>记好一句话：函数式接口可以接收匿名内部类和lambda表达式</strong></p>
<p><strong>全文重点：</strong></p>
<p>俗话说，new一个接口就要new他的实现类对象，但是假设我不存在函数时接口的实现类对象，那么一般就使用匿名内部类的形式创建对象。创建出来的匿名内部类需要实现函数式接口中全部（其实就一个）的抽象方法。既然是匿名内部类的抽象方法，当然可以使用lambda表达式代替方法的实现。然而使用lambda表达式虽然简便了书写，但是代码的可读性也直线下降，没有注解的情况去读lambda表达式十分痛苦，为了针对代码可读性的问题，方法引用应运而生。方法引用作为lambda表达式的语法糖，可以简化lambda表达式的同时，提高代码的可读性，方法引用通过本篇博客的三种情况，代替lambda表达式的书写。</p>
<h3 id="1-1-Predicate"><a href="#1-1-Predicate" class="headerlink" title="1.1 Predicate"></a>1.1 Predicate</h3><p><code>java.util.function.Predicate</code>为函数式接口，predicate的中文意思是“断定”，即判断的意思，判断某个东西是否满足某种条件； 因此它包含test方法，根据输入值来做逻辑判断，其结果为True或者False。</p>
<ul>
<li><code>Predicate</code> 是一个布尔类型的函数，该函数只有一个输入参数。</li>
<li><code>Predicate</code>接口包含了多种默认方法，用于处理复杂的逻辑动词（<em>and, or, negate</em>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是使用<code>Predicate</code>的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; atLeast5 = x -&gt; x&gt;<span class="number">5</span>;</span><br><span class="line">predicate.test(<span class="number">3</span>);              <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line">predicate.test(<span class="string">&quot;foo&quot;</span>);          <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">&quot;foo&quot;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">System.out.println(nonNull.test(<span class="literal">null</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line">System.out.println(isNull.test(<span class="literal">null</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">System.out.println(isEmpty.test(<span class="string">&quot;&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br><span class="line">System.out.println(isNotEmpty.test(<span class="string">&quot;&quot;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><em>x&gt;5</em> 是表达式的主体，返回值就是表达式主体的值。</p>
<h3 id="1-2-Function"><a href="#1-2-Function" class="headerlink" title="1.2 Function"></a>1.2 Function</h3><p><code>java.util.function.Function</code>也是一个函数式编程接口；它代表的含义是“函数”，而函数经常是<strong>有输入输出</strong>的，因此它含有一个<em>apply方法</em>，<em>包含一个输入（一个参数）与一个输出（返回值）</em>；<br> 除apply方法外，它还有<em>compose</em> 与 <em>andThen</em>方法。</p>
<ul>
<li><p>**高阶函数: **</p>
<p>接受一个函数或返回一个函数。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = s -&gt; s + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = s -&gt; s * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 高阶函数: 接受一个函数或返回一个函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 下面表示在执行F时，先执行G，并且执行F时使用G的结果当作输入。</span></span><br><span class="line"><span class="comment"> * 相当于以下代码：</span></span><br><span class="line"><span class="comment"> * Integer a = g.apply(1);</span></span><br><span class="line"><span class="comment"> * System.out.println(f.apply(a));</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(f.compose(g).apply(<span class="number">1</span>)); <span class="comment">//output: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示执行F的 apply 后使用其返回的值当作输入再执行G的Apply；</span></span><br><span class="line"><span class="comment"> * 相当于以下代码</span></span><br><span class="line"><span class="comment"> * Integer a = f.apply(1);</span></span><br><span class="line"><span class="comment"> * System.out.println(g.apply(a));</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(f.apply(<span class="number">1</span>));            <span class="comment">//output: 2</span></span><br><span class="line">System.out.println(f.andThen(g).apply(<span class="number">1</span>)); <span class="comment">//output: 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>转换器实例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**定义一个转换的函数式接口</span></span><br><span class="line"><span class="comment"> * T：参数类型</span></span><br><span class="line"><span class="comment"> * R：返回值类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;T,R&gt; &#123;</span><br><span class="line">    R <span class="title function_">convert</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConverterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Converter&lt;String,Integer&gt; intConverter = (s) -&gt; Integer.valueOf(s);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> intConverter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;String to Integer:&quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        Converter&lt;String,Double&gt; doubleConverter = (s) -&gt; Double.valueOf(s);</span><br><span class="line">      	<span class="type">Double</span> <span class="variable">dblValue</span> <span class="operator">=</span> doubleConverter.convert(<span class="string">&quot;123.99&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;String to Double:&quot;</span> + dblValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接使用 Function 接口</span></span><br><span class="line">        Function&lt;String,Integer&gt; function = s -&gt; Integer.valueOf(s);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value2</span> <span class="operator">=</span> function.apply(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(value2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法引用</span></span><br><span class="line">        <span class="comment">// :: 表示引用方法</span></span><br><span class="line">        <span class="comment">//引用静态方法，类名::类方法名；如：Integer.valueOf(s)</span></span><br><span class="line">      	<span class="comment">//引用实例方法，对象::方法名</span></span><br><span class="line">        Function&lt;String,Integer&gt; function2 = Integer::valueOf;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value3</span> <span class="operator">=</span> function2.apply(<span class="string">&quot;9999&quot;</span>);</span><br><span class="line">        System.out.println(value3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-Consumer-消费者（重点）"><a href="#1-3-Consumer-消费者（重点）" class="headerlink" title="1.3 Consumer 消费者（重点）"></a>1.3 Consumer 消费者（重点）</h3><p>它定义了一个名为<code>accept</code>的<a href="https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">抽象方法</a>，该方法接受一个参数并且不返回任何结果。换句话说，<code>Consumer</code>接口表示一个消费者，它可以对给定的对象执行某些操作，但不产生任何结果。</p>
<p><code>accept(T) 方法</code>：是 Consumer 函数式接口的函数方法，传入一个任意类型，无返回值，可以用于 Lambda 表达式和方法引用。<br><code>andThen(Consumer) 方法</code>：可以传入一个 Consumer ，返回组合了两个 Consumer 后的 Consumer ，传入的 Consumer 不能为 null，否则会得到 NullPointerException 。</p>
<p><strong>通俗的来说：</strong><br>Consumer 相当于一个放东西的容器，你可以在这个容器里定义一个带有入参的代码块，然后返回 T 类型，当调用 accept(T) 方法的时候才会去执行容器里的代码。</p>
<p><strong>例子1：</strong>使用类名引用成员方法（类名引用成员方法见本篇博客第三节3.3）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用实例方法</span></span><br><span class="line">Consumer&lt;String&gt; enameConsumer = employee::setEname;</span><br><span class="line">enameConsumer.accept(<span class="string">&quot;mike&quot;</span>);</span><br><span class="line"><span class="comment">// test(enameConsumer);</span></span><br><span class="line">System.out.println(employee.getName());</span><br><span class="line"></span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> System.out::println;</span><br><span class="line">Arrays.asList(<span class="string">&quot;james&quot;</span>,<span class="string">&quot;andy&quot;</span>,<span class="string">&quot;scott&quot;</span>).forEach(consumer);</span><br></pre></td></tr></table></figure>



<p><strong>例子2：</strong>使用Consumer函数式接口接受lambda表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class MainServer &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Consumer&lt;String&gt; first = x -&gt; System.out.println(&quot;1.&quot;+x.toLowerCase());</span><br><span class="line">        Consumer&lt;String&gt; second = y -&gt; System.out.println(&quot;2.&quot; + y);</span><br><span class="line">        System.out.println(&quot;开始&quot;);</span><br><span class="line">        Consumer&lt;String&gt; result = first.andThen(second);</span><br><span class="line">        //调用了accept 后，会先执行 first 容器里的代码，再执行 second 容器里的代码</span><br><span class="line">        result.accept(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-Supplier-供应者"><a href="#1-4-Supplier-供应者" class="headerlink" title="1.4 Supplier 供应者"></a>1.4 Supplier 供应者</h3><p>代表无参数，返回一个结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用默认构造函数</span></span><br><span class="line">Supplier&lt;Employee&gt; supplier = Employee::<span class="keyword">new</span>;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">System.out.println(employee);</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用对象的String getName()方法</span></span><br><span class="line">Supplier&lt;String&gt; stringSupplier = employee::getEname;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-BinaryOperator"><a href="#1-5-BinaryOperator" class="headerlink" title="1.5 BinaryOperator"></a>1.5 BinaryOperator</h3><ul>
<li><p><code>BinaryOperator</code><em>接口接收两个参数，返回一个值，返回值和参数的数据类型相同。</em></p>
</li>
<li><p><code>BinaryOperator</code>接口是<code>BiFunction</code> （接收两个参数）的子接口。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; addLongs = (x,y) -&gt; x + y;</span><br><span class="line">System.out.println(addLongs.apply(<span class="number">1L</span>, <span class="number">2L</span>));</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;Lambda表达式是一个匿名方法，将行为像数据一样传递。&#x3D;&#x3D;</p>
<h1 id="二、Lambda表达式"><a href="#二、Lambda表达式" class="headerlink" title="二、Lambda表达式"></a>二、Lambda表达式</h1><p><img src="%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png"></p>
<p><strong>1、Lambda表达式的基本作用?</strong><br>简化函数式接口的<strong>匿名内部类</strong>的写法。</p>
<p><strong>2、Lambda表达式有什么使用前提?</strong><br>必须是接口的匿名内部类，接口中只能有一个抽象方法</p>
<p><strong>3、Lambda的好处?</strong><br>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码，它可以写出更简洁、更灵活的代码，作为一种更紧凑的代码风格，使Java语言表达能力得到了提升。</p>
<p>举个例子：单列集合arraylist调用foreach方法进行遍历。</p>
<p><img src="forEach.png"></p>
<p>其中方法的参数是<strong>consumer接口</strong>（留意一下consumer接口）的实现类，因此需要使用匿名内部类的形式调用方法，改进后可以使用lambda表达式遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;博主你这个博客是自己写的吗&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;我的天，好有水平，但是我看不懂&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.使用匿名内部类进行遍历</span></span><br><span class="line">        coll.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使用lambda表达式进行遍历</span></span><br><span class="line">        coll.forEach(</span><br><span class="line">           (String s)-&gt; &#123;</span><br><span class="line">               System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.lambda简化版</span></span><br><span class="line">        coll.forEach(</span><br><span class="line">                (String s)-&gt; System.out.println(s)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、方法引用"><a href="#三、方法引用" class="headerlink" title="三、方法引用"></a>三、方法引用</h1><p><img src="%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.png"></p>
<p>只有使用匿名内部类和lambda表达式的地方才可以使用方法引用。</p>
<p>它的基本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。事实上，方法引用就是让你根据已有的方法实现来创建Lambda表达式。但是，显式地指明方法的名称，你的代码的可读性会更好。</p>
<p><strong>方法引用的规则:</strong></p>
<ol>
<li>需要有函数式接口</li>
<li>被引用的方法必须已经存在</li>
<li>被引用方法的形参，需要跟抽象方法的第二个形参到最后一个形参保持一致， 返回值需要保持一致。</li>
<li>被引用方法的功能需要满足当前的需求</li>
</ol>
<p><strong>抽象方法形参的详解:</strong><br><strong>第一个参数：</strong>表示被引用方法的调用者，决定了可以引用哪些类中的方法<br>在Stream流当中，第一个参数一般都表示流里面的每一个数据。假设流里面的数据是字符串，那么使用这种方式进行方法引用，只能引用String这个类中的方法。<br><strong>第二个参数到最后一个参数：</strong>跟被引用方法的形参保持一致，如果没有第二个参数，说明被引用的方法需要是无参的成员方法</p>
<h2 id="3-1-静态方法引用"><a href="#3-1-静态方法引用" class="headerlink" title="3.1 静态方法引用"></a>3.1 静态方法引用</h2><img src="%E9%9D%99%E6%80%81%E5%BC%95%E7%94%A8.png" style="zoom:80%;">



<p>举个例子</p>
<p><img src="1.png"></p>
<h2 id="3-2-对象引用成员方法"><a href="#3-2-对象引用成员方法" class="headerlink" title="3.2 对象引用成员方法"></a>3.2 对象引用成员方法</h2><img src="%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95.png" style="zoom: 50%;">

<p>this::方法名和super::方法名，这两个的被引用处不能是静态方法，因为静态方法没有this、super关键字</p>
<p>举个例子：</p>
<p><img src="2.png"></p>
<h2 id="3-3-类名引用成员方法"><a href="#3-3-类名引用成员方法" class="headerlink" title="3.3 类名引用成员方法"></a>3.3 类名引用成员方法</h2><p>举个例子：我现在需要把集合中的字母全部变成大写，使用匿名内部类语法如下</p>
<img src="3.png" style="zoom: 67%;">



<p>现在使用类名引用方法的形式，首先看String类中的toUpperCase方法</p>
<p><img src="all%E5%A4%A7%E5%86%99%E6%96%B9%E6%B3%95.png"></p>
<p>按照抽象方法参数的详解（3.1节），匿名内部类中抽象方法apply中的参数String s是抽象方法的第一个参数，它决定能使用什么类的方法。</p>
<p>第二个参数到末尾的参数要和成员方法的一致，如果抽象方法只有一个参数，那么应该调用这个类的无参方法。</p>
<p>String类中的toUpperCase方法提供了两个，符合可以用空参的那个。</p>
<img src="string%E7%B1%BBtoUpperCase.png" style="zoom:80%;">



<p>因此可以把匿名内部类的写法改成使用方法引用的形式</p>
<img src="4.png" style="zoom:80%;">









]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL：MVCC与事务</title>
    <url>/2024/08/15/MySQL-MVCC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>八股放在最后，前面讲讲八股的答案原理。</p>
<h1 id="一、什么是MVCC"><a href="#一、什么是MVCC" class="headerlink" title="一、什么是MVCC"></a>一、什么是MVCC</h1><p>多版本并发控制（MVCC&#x3D;Multi-Version Concurrency Control），是一种用来解决<strong>读 - 写冲突的无锁并发控制</strong>。也就是为事务分配单向增长的时间戳，为每个修改保存一个版本。版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照（复制了一份数据）。mvcc解决的就是读写时的线程安全问题，线程不用去争抢<strong>读写锁</strong>（读写锁可参考：<a href="https://rengoku.top/2024/08/05/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E4%B8%89%E3%80%81%E9%94%81/">Java多线程：三、多线程锁、java锁的实现 | 颓废市民黄先生 (rengoku.top)</a>）。</p>
<blockquote>
<p>说到读写冲突和多线程并发控制，肯定也会涉及事务的隔离级别，即读未提交（可能脏读），读已提交（不可重复读），可重复读（可能幻读）。MVCC和事务隔离级别共同解决这些问题。</p>
</blockquote>
<p>MVCC所提到的读是快照读，也就是普通的select语句。快照读在读写时不用加锁，不过可能会读到历史数据。</p>
<p>还有一种读取数据的方式是当前读，是一种悲观锁的操作。它会对当前读取的数据进行加锁，所以读到的数据都是最新的。主要包括以下几种操作：</p>
<ul>
<li><p>select lock in share mode（共享锁）</p>
</li>
<li><p>select for update（排他锁）</p>
</li>
<li><p>update（排他锁）</p>
</li>
<li><p>insert（排他锁）</p>
</li>
<li><p>delete（排他锁）</p>
</li>
</ul>
<p><strong>MVCC采用的快照读，当前读来读取数据，那么什么是快照读和当前读？</strong></p>
<p><strong>快照读：</strong>快照读是指在读取数据时，读取的是某个一致性视图（Consistent View）中的数据，这个一致性视图反映了事务开始时刻数据库的快照。</p>
<blockquote>
<p>什么是一致性视图？这里虽然说的玄乎，其实就是read view，待会儿在介绍mvcc实现原理中介绍。</p>
</blockquote>
<p><strong>当前读：</strong>当前读，是指读取操作获取的是数据的最新版本，即读取操作发生时数据库中该数据的实际状态。这种读取方式通常伴随着锁的使用，以确保读取的数据在事务处理期间不会被其他事务修改，从而保证事务的一致性和隔离性。</p>
<p><strong>MVCC在MySQL的InnoDB引擎是默认实现的，无需配置其他内容。</strong></p>
<h1 id="二、MVCC实现原理"><a href="#二、MVCC实现原理" class="headerlink" title="二、MVCC实现原理"></a>二、MVCC实现原理</h1><p>MVCC 的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主要是依赖记录中的版本链、undo 日志、Read View 来实现的。</p>
<p><img src="db3218ed0f37c6a0f6a1b973808b4bb7.png" alt="MVCC实现原理"></p>
<p>在图中，有两个没见过的列，一个是trx_id，另外一个是roll_pointer。在MySQL中，除了我们显示的定义列，存储引擎还会隐式帮我们定义一些列，其中就存在trx_id，roll_pointer。下面逐一介绍。</p>
<p><strong>trx_id：</strong></p>
<p>在MySQL的InnoDB存储引擎中，<code>trx_id</code>是一个隐藏列，<strong>用于记录对该行数据最后一次进行修改（INSERT、UPDATE或DELETE）的事务的ID</strong>，或者InnoDB**通过递增<code>max_trx_id</code>（max_trx_id在read view中介绍）的值来生成新的<code>trx_id</code>**。当需要一个新的<code>trx_id</code>时，InnoDB会获取<code>max_trx_id</code>的当前值，然后将其加1，并将结果赋值给新的或修改的数据行的<code>trx_id</code>隐藏列。</p>
<p><strong>roll_pointer：</strong></p>
<p>回滚指针，用于找到上一个版本的数据，结合undolog进行回滚。</p>
<p><strong>什么是read view？</strong></p>
<p>在上边提到，MVCC会使用快照读，快照读读取的就是read view。当我们用select读取数据时，这一时刻的数据会有很多个版本（例如上图有四个版本），但我们并不知道读取哪个版本，这时就靠readview来对我们进行读取版本的限制，<strong>通过readview我们才知道自己能够读取哪个版本</strong>。</p>
<p>其中read view的字段：</p>
<p><img src="1cbe594d87429293ce903d55308d564b.png" alt="read view字段"></p>
<p>m_ids：活跃的事务就是指还没有commit的事务。</p>
<p>max_trx_id：例如m_ids中的事务id为（1，2，3），那么下一个应该分配的事务id就是4，max_trx_id就是4。</p>
<p>creator_trx_id：执行select读这个操作的事务的id</p>
<p><strong>介绍一下read view字段如何代表是否可读：</strong></p>
<p><img src="7ee4ab42374825c8dcec080b6005862e.png"></p>
<p>trx_id表示要读取的事务id</p>
<ol>
<li><p>如果要读取的事务id等于进行读操作的事务id，说明是我读取我自己创建的记录，可以读。</p>
</li>
<li><p>如果要读取的事务id小于最小的活跃事务id，说明要读取的事务已经提交，那么可以读取。</p>
</li>
<li><p>max_trx_id表示生成readview时，分配给下一个事务的id，如果要读取的事务id大于max_trx_id，说明该id已经不在该readview版本链中了，故无法访问。</p>
</li>
<li><p>m_ids中存储的是活跃事务的id，如果要读取的事务id不在活跃列表，那么就可以读取，反之不行。</p>
</li>
</ol>
<h1 id="三、写博客的时候想的问题"><a href="#三、写博客的时候想的问题" class="headerlink" title="三、写博客的时候想的问题"></a>三、写博客的时候想的问题</h1><h3 id="1-为什么mvcc可以解决脏读，幻读的问题？"><a href="#1-为什么mvcc可以解决脏读，幻读的问题？" class="headerlink" title="1.为什么mvcc可以解决脏读，幻读的问题？"></a>1.为什么mvcc可以解决脏读，幻读的问题？</h3><p>MVCC（多版本并发控制，Multiversion Concurrency Control）在MySQL的InnoDB存储引擎中，主要用于提高数据库的并发性能，并有效地解决脏读、不可重复读和幻读等事务隔离问题。以下是MVCC如何解决脏读和幻读问题的详细解释：</p>
<p><strong>解决脏读问题</strong></p>
<p>脏读是指一个事务读取了另一个事务未提交的数据。在MVCC机制下，每个事务在读取数据时，都会根据事务的隔离级别和当前时间戳（或事务ID）来生成一个“读视图”（ReadView）。这个读视图定义了哪些版本的数据对当前事务是可见的。由于MVCC会确保事务只能读取到已经提交的数据版本，因此即使有其他事务正在修改数据但尚未提交，当前事务也不会读取到这些未提交的数据版本，从而避免了脏读问题。</p>
<p><strong>解决幻读问题</strong></p>
<p>幻读是事务隔离中的另一个问题，它发生在同一事务中，当某个事务两次执行相同的查询时，由于其他事务的插入操作，导致第二次查询结果中出现了第一次查询中不存在的记录。MVCC通过以下方式解决幻读问题：</p>
<ol>
<li><p><strong>版本链机制</strong>：MVCC通过维护数据的版本链来记录每个数据行的修改历史。每次对数据的修改都会生成一个新的数据版本，并将旧版本保留在版本链中。这样，事务在读取数据时，可以根据读视图选择适合的版本进行读取。</p>
</li>
<li><p><strong>读写隔离</strong>：在MVCC中，读操作不会阻塞写操作，写操作也不会阻塞读操作。这种读写隔离的机制避免了并发操作的冲突，使得事务可以在不锁定数据的情况下进行读取，从而减少了锁的竞争和提高了并发性能。</p>
</li>
<li><p><strong>间隙锁（Gap Locks）</strong>：虽然MVCC本身不直接通过间隙锁来解决幻读问题，但在某些情况下（如可重复读隔离级别下），InnoDB会结合MVCC和间隙锁来防止幻读。间隙锁可以锁定一个范围内的记录间隙，防止其他事务在该间隙内插入新的记录。这样，即使其他事务尝试在已锁定的间隙内插入新记录，也会被阻塞，从而避免了幻读的发生。</p>
<blockquote>
<p>间隙锁是InnoDB在可重复读（REPEATABLE READ）隔离级别下为了解决幻读（Phantom Reads）问题时<strong>自动采用的</strong>一种锁机制。它用于锁定一个范围内的间隙，即锁定那些不存在的记录之间的“空间”，从而防止其他事务在这个范围内插入新的记录。</p>
</blockquote>
</li>
<li><p><strong>一致性快照</strong>：MVCC通过创建每个读取数据的版本快照，使得每个事务都在一个一致性的快照中执行。这意味着在同一时间点，可以有多个事务并发的读取同一份数据，而不会相互干扰。这种一致性快照保证了事务读取数据的一致性，从而避免了幻读问题。</p>
</li>
</ol>
<h3 id="2-如果mvcc可以解决脏读、幻读、不可重复读的问题，为什么还需要提出事务隔离级别？"><a href="#2-如果mvcc可以解决脏读、幻读、不可重复读的问题，为什么还需要提出事务隔离级别？" class="headerlink" title="2.如果mvcc可以解决脏读、幻读、不可重复读的问题，为什么还需要提出事务隔离级别？"></a>2.如果mvcc可以解决脏读、幻读、不可重复读的问题，为什么还需要提出事务隔离级别？</h3><p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是数据库管理系统（如MySQL中的InnoDB存储引擎）中用于实现事务隔离级别的一种技术。尽管MVCC在解决脏读、不可重复读和幻读问题上发挥了重要作用，但事务隔离级别的提出和存在仍然是必要的，原因如下：</p>
<ol>
<li>隔离级别的多样性需求</li>
</ol>
<p>不同的应用场景对事务的隔离性有不同的需求。事务隔离级别从低到高分为Read Uncommitted（读未提交）、Read Committed（读已提交）、Repeatable Read（可重复读）和Serializable（可串行化）。每种隔离级别都有其特定的应用场景和优缺点。例如：</p>
<ul>
<li><strong>Read Uncommitted</strong>：允许读取未提交的数据，这可能导致脏读，但在某些特定场景下，如需要极高并发且对数据一致性要求不高的场景，可能会选择这种隔离级别。</li>
<li><strong>Read Committed</strong>：保证读取的数据是已提交的，避免了脏读，但可能出现不可重复读。</li>
<li><strong>Repeatable Read</strong>：MySQL InnoDB存储引擎的默认隔离级别，它通过MVCC和Next-Key锁等技术解决了脏读和不可重复读问题，但在某些情况下（如当前读）仍可能遇到幻读。</li>
<li><strong>Serializable</strong>：最高的隔离级别，通过强制事务串行执行来避免脏读、不可重复读和幻读，但会显著降低并发性能。</li>
</ul>
<ol start="2">
<li>MVCC的局限性</li>
</ol>
<p>虽然MVCC在解决并发问题时非常有效，但它也有其局限性：</p>
<ul>
<li><strong>幻读问题</strong>：在可重复读隔离级别下，MVCC通过快照读可以避免幻读，但在当前读（如加锁的SELECT、INSERT、UPDATE、DELETE等操作）时，仍可能遇到幻读问题。这是因为当前读会读取最新的数据版本，而不是事务开始时的快照。</li>
<li><strong>性能考虑</strong>：虽然MVCC提高了并发性能，但它也增加了系统的复杂性和开销。例如，需要维护多个数据版本、管理undo日志等。</li>
</ul>
<ol start="3">
<li>灵活性和兼容性</li>
</ol>
<p>事务隔离级别的提出允许数据库系统在不同的应用场景下提供灵活的隔离性保证。同时，它也保证了数据库系统与其他系统或应用的兼容性。例如，某些应用可能依赖于特定的事务隔离级别来保证其数据一致性和完整性。</p>
<ol start="4">
<li>标准化和可配置性</li>
</ol>
<p>事务隔离级别是数据库管理系统中的一个重要概念，它已经被广泛接受并标准化。数据库系统允许用户根据实际需求配置不同的事务隔离级别，以满足不同的性能和数据一致性要求。</p>
<h1 id="四、八股部分"><a href="#四、八股部分" class="headerlink" title="四、八股部分"></a>四、八股部分</h1><p><img src="Snipaste_2024-08-15_11-17-01.png" alt="八股"></p>
<p>关于24题中3个隐式字段，除了trx_id和roll_pointer，还有一个是row_id，在这里整理一下：</p>
<ol>
<li><p>row_id</p>
<p>这是一个唯一的标识符，用于唯一标识一条行记录。当表没有显式定义主键或唯一索引时，InnoDB会使用row_id作为主键。</p>
</li>
<li><p>trx_id</p>
<p>事务ID，记录的是当前行记录是被哪个事务修改提交的。InnoDB会为每个开启的事务分配一个递增的ID，用于唯一标识一个事务。当某个事务修改了某个行记录时，就会在这个行记录的trx_id隐式字段中记录当前事务的ID。</p>
</li>
<li><p>roll_pointer</p>
<p>回滚指针，用于指向undo日志中该行记录的历史版本。当一个事务对某条记录进行修改时，会把该行记录先拷贝到undo日志中作为一个历史版本，然后再对该行记录进行修改，并使用roll_pointer指针指向undo日志中该行记录的历史版本。</p>
</li>
</ol>
<p>24题中使用undo日志的体现：</p>
<ul>
<li>构成版本链：每次对记录修改时会写入undo日志，而回滚指针将这些记录构成一条链表，供回滚指针进行回滚</li>
<li>实现多线程并发控制：记录未提交事务内容，可以作为其他事务的参考进行快照读</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MVCC是多版本并发控制，在MySQL的InnoDB引擎中是默认实现的。MVCC和事务隔离级别共同管理事务，尽可能的避免脏读、幻读的问题。</p>
<p>MVCC通过三个隐式字段（row_id、trx_id、roll_pointer）、版本链、undo日志、read view视图实现事务隔离。</p>
<p>在第三大节中，拓展了一下什么是间歇锁。</p>
<p>顺便把锁的博客放一篇：<a href="https://blog.csdn.net/u010841296/article/details/87909468">mysql的共享锁(S)、排他锁(X)、意向共享锁(IS)、意向排他锁(IX)的关系_is锁-CSDN博客</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库：（一）索引底层原理与实现</title>
    <url>/2024/08/15/MySQL-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="一、-什么是索引？"><a href="#一、-什么是索引？" class="headerlink" title="一、 什么是索引？"></a>一、 什么是索引？</h2><p>索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，可以大大加快查询的速度，使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。索引的作用类似于书的目录，可以根据目录中的页码快速找到所需的内容。</p>
<h3 id="1-1-索引概述（了解）"><a href="#1-1-索引概述（了解）" class="headerlink" title="1.1 索引概述（了解）"></a>1.1 索引概述（了解）</h3><p>当数据保存在磁盘类存储介质上时，它是作为数据块存放。这些数据块是被当作一个整体来访问的，这样可以保证操作的原子性。硬盘数据块存储结构类似于链表，都包含数据部分，以及一个指向下一个节点（或数据块）的指针，不需要连续存储。</p>
<p>记录集只能在某个关键字段上进行排序，所以如果需要在一个无序字段上进行搜索，就要执行一个线性搜索（Linear Search）的过程，平均需要访问 N&#x2F;2 的数据块，N 是表示所占据的数据块数目。如果这个字段是一个非主键字段（也就是说，不包含唯一的访问入口）， 那么需要在 N 个数据块上搜索整个表格空间。</p>
<p>但是对于一个有序字段，可以运用二分查找（BinarySearch），这样只需要访问 log2(N)的数据块。这就是为什么数据表使用索引后性能可以得到本质上提高的原因。</p>
<p>索引是对记录集的多个字段进行排序的方法。在一张表中为一个字段创建一个索引，将创建另外一个数据结构，包含字段数值以及指向相关记录的指针，然后对这个索引结构进行排序，允许在该数据上进行二分法排序。索引需要额外的磁盘空间。</p>
<p>对于 MyISAM 引擎而言，这些索引是被统一保存在一张表中的。如果很多字段都建立了索引，那么会占用大量的磁盘空间，这个文件将很快到达底层文件系统所能够支持的大小限制。</p>
<h4 id="1-1-1-索引的作用"><a href="#1-1-1-索引的作用" class="headerlink" title="1.1.1 索引的作用"></a>1.1.1 索引的作用</h4><p>索引除了快没有其他的作用，数据库利用各种各样的快速定位技术，能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍。</p>
<h4 id="1-1-2-索引的查找过程"><a href="#1-1-2-索引的查找过程" class="headerlink" title="1.1.2 索引的查找过程"></a>1.1.2 索引的查找过程</h4><p>举一个例子，三个表t1、t2、t3，每个表中只有一个字段，但是每一个表中都有1000行记录，这些记录都是1~1000的数字。</p>
<p>执行以下的查找语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt;SELECT c1,c2,c3 FROM t1,t2,t3 WHERE c1=c2 AND c1=c3;</span><br></pre></td></tr></table></figure>


<p>在无索引的情况下处理此查询， 必须寻找 3 个表所有的组合，以便得出与 WHERE 子句相配的那些行。而可能的组合数目 为 1000×1000×1000（十亿）</p>
<p>如果对每个表进行索引，就能极大地加速查询进程，利用索引的查询处理如下。</p>
<p>从表 t1 中选择第一行，查看此行所包含的数据。<br>使用表 t2 上的索引，直接定位 t2 中与 t1 的值匹配的行。同理，利用表 t3 上的索引， 直接定位 t3 中与 t1 的值匹配的行。<br>扫描表 t1 的下一行并重复前面的过程，直到遍历 t1 中所有的行。<br>在这样的情况下，对表 t1 执行了一个完全扫描，但能够在表 t2 和 t3 上进行索引查找直接取出这些表中的行，比未用索引时要快一百万倍。<br>利用索引，MySQL 加速了 WHERE 子句满足条件行的搜索，而在多表连接查询时、在执行连接时加快了与其他表中的行匹配的速度。</p>
<h2 id="二、索引的分类（逻辑分类）"><a href="#二、索引的分类（逻辑分类）" class="headerlink" title="二、索引的分类（逻辑分类）"></a>二、索引的分类（逻辑分类）</h2><p>逻辑的角度来划分，索引分为普通索引、唯一索引、主键索引、组合索引和全文索引。</p>
<h3 id="2-1-普通索引"><a href="#2-1-普通索引" class="headerlink" title="2.1 普通索引"></a>2.1 普通索引</h3><h4 id="2-1-1-普通索引格式"><a href="#2-1-1-普通索引格式" class="headerlink" title="2.1.1 普通索引格式"></a>2.1.1 普通索引格式</h4><p>普通索引是最基本的索引，它没有任何限制，也是大多数情况下用到的索引。</p>
<p>直接创建索引的方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># column 是指定要创建索引的列名</span></span><br><span class="line"><span class="comment"># length 是可选项</span></span><br><span class="line">mysql&gt;CREATE INDEX index_name ON table_name (column(length));</span><br></pre></td></tr></table></figure>

<p>索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字 节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，BLOB 或 TEXT 类型的列也必须使用前缀索引。</p>
<h4 id="2-1-2-创建普通索引"><a href="#2-1-2-创建普通索引" class="headerlink" title="2.1.2 创建普通索引"></a>2.1.2 创建普通索引</h4><p>方法一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>);  <span class="comment">##创建一个表结构</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   |     | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; create index id_index on info(<span class="built_in">id</span>);    <span class="comment">##为info表中的id创建索引</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | MUL | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到在key下面的MUL，索引创建成功了</span></span><br></pre></td></tr></table></figure>




<p>方法二：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">修改表结构的方式添加索引</span><br><span class="line">mysql&gt;ALTER TABLE table_name ADD INDEX index_name (column(length));</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table info add index name_index (name);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | MUL | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | MUL | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>




<p>方法三：<br>在创建一个表结构时，就创建索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table num (<span class="built_in">id</span> int(3),index id_index(<span class="built_in">id</span>));</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; describe num;</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">| Field | Type   | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>    | int(3) | YES  | MUL | NULL    |       |</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>



<h4 id="2-1-3-查看索引"><a href="#2-1-3-查看索引" class="headerlink" title="2.1.3 查看索引"></a>2.1.3 查看索引</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show index from info\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: id_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: name_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>



<h3 id="2-2-唯一索引"><a href="#2-2-唯一索引" class="headerlink" title="2.2 唯一索引"></a>2.2 唯一索引</h3><p>唯一索引与普通索引类似，不同的就是：唯一索引的索引列的值必须唯一，但允许有空<br>值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一。唯一索引创建方法和普<br>通索引类似。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改表结构的时候添加唯一索引：</span></span><br><span class="line">mysql&gt;CREATEUNIQUEINDEXindex_nameON table_name(column(length));</span><br></pre></td></tr></table></figure>

<p>新建一个表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>,primary key(<span class="built_in">id</span>));</span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; create unique index unique_name on info2(name);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | UNI | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>




<p>修改表结构的时候添加唯一索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式</span><br><span class="line">mysql&gt;ALTERTABLEtable_nameADD UNIQUEindex_name(column(length));</span><br></pre></td></tr></table></figure>


<p>创建表的时候同时创建唯一索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATETABLE`table`( </span><br><span class="line">...</span><br><span class="line">UNIQUE index Name (title(length)) );</span><br></pre></td></tr></table></figure>

<h3 id="2-3-主键索引"><a href="#2-3-主键索引" class="headerlink" title="2.3 主键索引"></a>2.3 主键索引</h3><p>主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。</p>
<p>主键索引也就是primary key，在之前的创建表的过程中已经演示过，有两种方式。</p>
<p>第一种：在字段外创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>,primary key(<span class="built_in">id</span>));</span><br></pre></td></tr></table></figure>

<p>第二种：在字段内创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null primary key,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-联合索引（组合索引）"><a href="#2-4-联合索引（组合索引）" class="headerlink" title="2.4 联合索引（组合索引）"></a>2.4 联合索引（组合索引）</h3><p>组合索引，也称为联合索引，复合索引或多列索引，是指索引同时包含多个列。在创建联合索引时，可以指定多个列名，以逗号分隔。联合索引的列顺序非常重要，因为查询时使用了联合索引中的一部分列时，这些列必须按照联合索引中的顺序出现。联合索引可以应用于需要根据多个列进行查询、排序、范围查询或分组的场景，以提高这些操作的效率。</p>
<p>平时用的 SQL 查询语句一般都有比较多的限制条件，所以为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。在组合索引的创建中，有两种场景，即为单列索引和多列索引。</p>
<p><strong>特点：</strong><br><strong>遵从最左原则，从左往右依次执行</strong></p>
<h3 id="2-5-全文索引"><a href="#2-5-全文索引" class="headerlink" title="2.5 全文索引"></a>2.5 全文索引</h3><p>对于较大的数据集，将资料输入一个没有 FULLTEXT 索引的表中，然后创建索引，其 速度比把资料输入现有 FULLTEXT 索引的速度更快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间、非常消耗硬盘空间的做法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table info2 add fulltext index addr_index(address);    <span class="comment">##创建全文索引</span></span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.04 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 1</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | UNI | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  | MUL | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; show index from info2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: addr_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: address</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<h3 id="2-6-覆盖索引"><a href="#2-6-覆盖索引" class="headerlink" title="2.6 覆盖索引"></a>2.6 覆盖索引</h3><p>覆盖索引是指一个索引包含了所有需要查询的列，即查询语句中的SELECT字段全部在索引中，通过索引就可以直接获取查询结果，而无需回表查询数据行。这种索引方式可以显著提高查询性能，因为它减少了磁盘I&#x2F;O操作。需要注意的是，覆盖索引并不是针对某次查询而言的，而是指索引本身包含了查询所需的所有列。</p>
<p><strong>联合索引和覆盖索引的区别</strong></p>
<ul>
<li><strong>区别</strong>：覆盖索引关注的是索引是否包含了查询所需的所有列，而联合索引关注的是索引是否同时包含了多个列。一个索引可以是覆盖索引但不一定是联合索引（如只包含一个列的索引且该列满足查询需求），也可以是联合索引但不一定是覆盖索引（如包含多个列但查询还需要其他列的数据）。</li>
<li><strong>联系</strong>：在某些情况下，一个联合索引也可以是覆盖索引，即当查询语句中的SELECT字段全部包含在联合索引中时。此时，联合索引不仅提高了查询效率（因为可以同时利用多个列进行索引），还因为包含了查询所需的所有列而实现了覆盖索引的效果。</li>
</ul>
<h2 id="三、-查看及删除索引"><a href="#三、-查看及删除索引" class="headerlink" title="三、 查看及删除索引"></a>三、 查看及删除索引</h2><h3 id="3-1-查看索引"><a href="#3-1-查看索引" class="headerlink" title="3.1 查看索引"></a>3.1 查看索引</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看索引的两种方法</span><br><span class="line">mysql&gt;show index from tablename;</span><br><span class="line">mysql&gt;show keys from tablename;</span><br></pre></td></tr></table></figure>


<p>以show keys from tablename为例，两种方法用法相同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show keys from info2;</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name    | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| info2 |          0 | PRIMARY     |            1 | <span class="built_in">id</span>          | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| info2 |          0 | unique_name |            1 | name        | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| info2 |          1 | addr_index  |            1 | address     | NULL      |           0 |     NULL | NULL   | YES  | FULLTEXT   |         |               |</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>可以使用 mysql&gt; show keys from info2\G;使用显示结果更加直观</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; mysql&gt; show keys from info2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: addr_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: address</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Table：表的名称。</p>
</li>
<li><p>Non_unique：如果索引不能包括重复词，则为 0；如果可以，则为 1。</p>
</li>
<li><p>Key_name：索引的名称。</p>
</li>
<li><p>Seq_in_index：索引中的列序号，从 1 开始。</p>
</li>
<li><p>Column_name：列名称。</p>
</li>
<li><p>Collation：列以什么方式存储在索引中。在 MySQL 中，有值‘A’（升序）或 NULL（无分类）。</p>
</li>
<li><p>Cardinality：索引中唯一值数目的估计值。通过运行 ANALYZETABLE 或 myisamchk-a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没 有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</p>
</li>
<li><p>Sub_part：如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列 被编入索引，则为 NULL。</p>
</li>
<li><p>Packed：指示关键字如何被压缩。如果没有被压缩，则为 NULL。</p>
</li>
<li><p>Null：如果列含有 NULL，则含有 YES。如果没有，则该列含有 NO。</p>
</li>
<li><p>Index_type：用过的索引方法（BTREE, FULLTEXT,HASH, RTREE）。</p>
</li>
<li><p>Comment：备注。</p>
</li>
</ol>
<h3 id="3-2-删除索引"><a href="#3-2-删除索引" class="headerlink" title="3.2 删除索引"></a>3.2 删除索引</h3><p>索引在创建之后，是会占用一定的磁盘空间的，因此表内如果有不再使用的索引，从数据库性能方面考虑，最好是删除无用索引。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">删除索引的两种方式</span><br><span class="line">DROP INDEX 索引名 ON 表名; </span><br><span class="line">ALTER TABLE 表名 DROP INDEX 索引名;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop index addr_index on info2;    <span class="comment">##删除刚刚创建的全文索引</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show keys from info2\G;   </span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>



<h2 id="四、-索引的底层原理"><a href="#四、-索引的底层原理" class="headerlink" title="四、 索引的底层原理"></a>四、 索引的底层原理</h2><h3 id="4-1-八股：数据结构"><a href="#4-1-八股：数据结构" class="headerlink" title="4.1 八股：数据结构"></a>4.1 八股：数据结构</h3><p>Mysql数据库中的常见索引结构有多种，常用Hash，B+树（最常用，多路搜索树）等数据结构来进行数据存储。树的深度加深一层，意味着多一次查询，对于数据库磁盘而言，就是多一次IO操作，导致查询效率低下。</p>
<p><strong>创建一次索引就代表了创建了一个数据结构，例如B+树。</strong></p>
<p><strong>B+树的特征：</strong></p>
<ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</li>
<li>更适合文件索引系统；</li>
</ol>
<p>此处讨论B+树，结合案例见4.3。</p>
<h3 id="4-2-八股：搜索引擎"><a href="#4-2-八股：搜索引擎" class="headerlink" title="4.2 八股：搜索引擎"></a>4.2 八股：搜索引擎</h3><p>常见的有InnoDB、MyASIM（不支持数据库事务）、Memory等。存储引擎和存储方式（磁盘等）见文章：<a href="https://blog.csdn.net/wangfeijiu/article/details/112454405">MySQL体系构架、存储引擎和索引结构</a></p>
<p>此处使用InnoDB来讨论索引的存储结构，见4.3。</p>
<h3 id="4-3-八股：InnoDB-B-树存储数据结构"><a href="#4-3-八股：InnoDB-B-树存储数据结构" class="headerlink" title="4.3 八股：InnoDB B+树存储数据结构"></a>4.3 八股：InnoDB B+树存储数据结构</h3><p>存储数据结构，也是索引分类的一种：物理分类（第二章讲了逻辑分类）。物理分类分为<strong>聚簇索引</strong>和非聚簇索引。存储数据结构虽然说是索引分类的一种，但是准确的来说，<strong>聚簇索引和非聚簇索引是一种数据的存储方式。</strong></p>
<p><strong>聚簇索引（clustered index）</strong>不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。</p>
<img src="%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg">

<p><strong>非聚簇索引（辅助索引或者二级索引）</strong>：数据和索引是分开的，非聚簇索引的叶子节点并不存储数据表中的完整数据记录。相反，它们存储的是指向数据表中相应行的指针，这个指针通常是数据表中主键的值。</p>
<img src="%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg">

<p>虽然InnoDB和MyISAM存储引擎都默认使用B+树结构存储索引，但是只有InnoDB的<strong>主键索引</strong>（主键索引见2.3）才是聚簇索引，InnoDB中的辅助索引以及MyISAM使用的都是非聚簇索引。</p>
<p><strong>使用聚簇索引的优缺点（面试）：</strong></p>
<p>优点：</p>
<ol>
<li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂（页分裂见4.2链接、下图，属于操作系统的知识），严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键（主键列不要选没有意义的自增列，选经常查询的条件列才好，不然无法体现其主键索引性能）</p>
</li>
<li><p>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</p>
</li>
<li><p>二级索引（非聚簇索引）访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
</li>
</ol>
<img src="f6cd40465df212dd91614785713be6cb.gif" style="zoom:150%;">





<h3 id="4-4-八股：回表是什么？为什么会有回表？"><a href="#4-4-八股：回表是什么？为什么会有回表？" class="headerlink" title="4.4 八股：回表是什么？为什么会有回表？"></a>4.4 八股：回表是什么？为什么会有回表？</h3><p>在4.3的聚簇索引中，我们提到缺点的第三条，非聚簇索引需要两次索引查找，这个过程我们就称为回表。</p>
<p>为什么会有回表？我们刚说到，聚簇索引是将索引和数据存储放在一起的，所以找到索引了就是找到了数据。但是根据实际查询的要求，不一定只会根据主键去查询数据。我们看以下场景：</p>
<p>假如有个表T， 里面三个字段：id k name， id为主键，并且其中对k建立了单独索引。此时有两棵B+树，一个是聚簇索引（主键索引）的B+树，一个是非聚簇索引的B+树。</p>
<ol>
<li><p>如果语句是 select * from T where id&#x3D;500，即主键查询方式（聚簇索引），则只需要搜索 ID 这棵 B+ 树，查询一表即可。</p>
</li>
<li><p>如果语句是 select id, k from T where k&#x3D;5，即普通索引查询方式（非聚簇索引），则只要搜索 k 索引树，这样的话查询一表即可。</p>
</li>
<li><p>如果语句是 select id, k , name from T where k&#x3D;5，第一次通过普通索引查询方式得到 id 的值为 500，再到 id 索引树搜索一次（需要回表才能查到name这个数据）。此时这个过程就成为回表了，回表是基于聚簇索引的缺点之一。</p>
</li>
</ol>
<p>所以为了避免回表，那么可以将k和name建成联合索引（<strong>在这个情况下的联合索引，在非主键索引就可以查询到数据，也等同于覆盖索引）。</strong></p>
<p><strong>为什么建成联合索引就可以避免回表？</strong></p>
<p>在4.3中提到，非聚簇索引的叶子结点存储的是指向数据表中相应行的指针，这个指针通常是数据表中主键的值。那么查询到K或者name后，自然的指向了对应的id，那么这个行数据自然也就拿到了。</p>
<h2 id="五、八股：什么时候索引会失效？"><a href="#五、八股：什么时候索引会失效？" class="headerlink" title="五、八股：什么时候索引会失效？"></a>五、八股：什么时候索引会失效？</h2><h3 id="1-不合理的查询条件"><a href="#1-不合理的查询条件" class="headerlink" title="1. 不合理的查询条件"></a>1. 不合理的查询条件</h3><ul>
<li><strong>前模糊查询</strong>：当使用LIKE操作符进行模糊匹配，并且匹配模式以通配符<code>%</code>开头时（如<code>LIKE &#39;%abc&#39;</code>），索引会失效。因为索引是基于前缀匹配的，前缀不确定时，数据库无法利用索引快速定位数据。</li>
<li><strong>OR条件中的非索引列</strong>：如果查询条件中包含OR，且OR连接的条件列中有的列不是索引列，那么索引可能会失效。尽管在某些情况下，如果OR连接的每个条件列都单独建立了索引，数据库可能会使用索引合并策略，但这并不总是发生。</li>
</ul>
<h3 id="2-对索引列使用函数或表达式"><a href="#2-对索引列使用函数或表达式" class="headerlink" title="2. 对索引列使用函数或表达式"></a>2. 对索引列使用函数或表达式</h3><ul>
<li><strong>函数操作</strong>：在查询条件中对索引列使用函数（如<code>UPPER(column_name)</code>、<code>LENGTH(column_name)</code>等）会导致索引失效。因为索引是基于列的原始值建立的，而函数操作改变了列的值，使得数据库无法直接利用索引。</li>
<li><strong>表达式计算</strong>：在索引列上进行表达式计算（如<code>column_name + 1 = 2</code>）同样会导致索引失效。原因与对索引列使用函数类似，索引保存的是原始值，而不是计算后的结果。</li>
</ul>
<h3 id="3-数据类型不匹配"><a href="#3-数据类型不匹配" class="headerlink" title="3. 数据类型不匹配"></a>3. 数据类型不匹配</h3><ul>
<li><strong>隐式类型转换</strong>：当查询条件中的数据类型与索引列的数据类型不匹配，且数据库进行了隐式类型转换时，索引可能会失效。例如，如果索引列是字符串类型，但在查询条件中使用了整型值，而没有显式地进行类型转换，那么数据库可能会进行隐式类型转换，从而导致索引失效。</li>
</ul>
<h3 id="4-索引使用不当"><a href="#4-索引使用不当" class="headerlink" title="4. 索引使用不当"></a>4. 索引使用不当</h3><ul>
<li><strong>联合索引非最左匹配</strong>：在使用联合索引时，如果查询条件没有遵循最左前缀原则，即没有从联合索引的最左边列开始匹配，那么索引可能会失效。这是因为联合索引是按照索引列的顺序进行排序的，直接跳过前面的列进行匹配会破坏索引的有序性。</li>
<li><strong>范围查询后的列</strong>：在联合索引中，如果某个列使用了范围查询（如<code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>等），那么该列之后的所有列都无法使用索引进行快速定位。</li>
</ul>
<h3 id="5-其他情况"><a href="#5-其他情况" class="headerlink" title="5. 其他情况"></a>5. 其他情况</h3><ul>
<li><strong>索引列包含大量重复值</strong>：如果索引列的值区分度不高，即包含大量重复值，那么数据库可能会选择不使用索引，而是通过全表扫描来查询数据。因为在这种情况下，使用索引可能并不会带来性能上的提升。</li>
<li><strong>索引列被用作条件表达式的一部分</strong>：在某些情况下，如果索引列被用作条件表达式的一部分（如<code>column_name IN (SELECT ...)</code>中的子查询），且数据库无法有效地将表达式转换为对索引的直接引用，那么索引可能会失效。</li>
</ul>
<h2 id="六、什么时候不推荐使用索引"><a href="#六、什么时候不推荐使用索引" class="headerlink" title="六、什么时候不推荐使用索引"></a>六、什么时候不推荐使用索引</h2><h2 id="附上一篇美团讲解的索引内容"><a href="#附上一篇美团讲解的索引内容" class="headerlink" title="附上一篇美团讲解的索引内容"></a>附上一篇美团讲解的索引内容</h2><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">美团：MySQL索引原理及慢查询优化</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7部署docker</title>
    <url>/2024/07/06/centOS%E9%83%A8%E7%BD%B2docker/</url>
    <content><![CDATA[<h1 id="0-安装Docker"><a href="#0-安装Docker" class="headerlink" title="0.安装Docker"></a>0.安装Docker</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p>
<p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p>
<p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p>
<h1 id="1-CentOS安装Docker"><a href="#1-CentOS安装Docker" class="headerlink" title="1.CentOS安装Docker"></a>1.CentOS安装Docker</h1><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p>
<h2 id="1-1-卸载（可选）"><a href="#1-1-卸载（可选）" class="headerlink" title="1.1.卸载（可选）"></a>1.1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure>



<h2 id="1-2-安装docker"><a href="#1-2-安装docker" class="headerlink" title="1.2.安装docker"></a>1.2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure>



<p>然后更新本地镜像源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>





<p>然后输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure>

<p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p>
<h2 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3.启动docker"></a>1.3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p>
<p>启动docker前，一定要关闭防火墙后！！</p>
<p>启动docker前，一定要关闭防火墙后！！</p>
<p>启动docker前，一定要关闭防火墙后！！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>



<p>通过命令启动docker：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure>



<p>然后输入命令，可以查看docker版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="image-20210418154704436.png"></p>
<h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p>
<p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p>
<h1 id="2-CentOS7安装DockerCompose"><a href="#2-CentOS7安装DockerCompose" class="headerlink" title="2.CentOS7安装DockerCompose"></a>2.CentOS7安装DockerCompose</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h2><p>Linux下需要通过命令下载：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>如果下载速度较慢，或者下载失败，联系博主给你一份</p>
<p><img src="image-20210417133020614.png"></p>
<p>上传到<code>/usr/local/bin/</code>目录也可以。</p>
<h2 id="2-2-修改文件权限"><a href="#2-2-修改文件权限" class="headerlink" title="2.2.修改文件权限"></a>2.2.修改文件权限</h2><p>修改文件权限：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>



<h2 id="2-3-Base自动补全命令："><a href="#2-3-Base自动补全命令：" class="headerlink" title="2.3.Base自动补全命令："></a>2.3.Base自动补全命令：</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 补全命令</span></span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure>

<p>如果这里出现错误，需要修改自己的hosts文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>





<h1 id="3-Docker镜像仓库"><a href="#3-Docker镜像仓库" class="headerlink" title="3.Docker镜像仓库"></a>3.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p>
<p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p>
<h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1.简化版镜像仓库"></a>3.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p>
<p>搭建方式比较简单，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry	\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure>



<p>命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。</p>
<p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p>
<h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2.带有图形化界面版本"></a>3.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:static</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=传智教育私有仓库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_URL=http://registry:5000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br></pre></td></tr></table></figure>



<h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3.配置Docker信任地址"></a>3.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://192.168.150.101:8080&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>软件技术</tag>
      </tags>
  </entry>
  <entry>
    <title>快速复习git</title>
    <url>/2024/06/26/git%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="1-博客前言"><a href="#1-博客前言" class="headerlink" title="1. 博客前言"></a>1. 博客前言</h3><p>本篇博客记录git常用的命令，用于快速复习。基于命令行，对一个项目进行版本控制（不使用图形化界面，例如idea、vscode等）。</p>
<h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><h4 id="2-1-删除git仓库"><a href="#2-1-删除git仓库" class="headerlink" title="2.1 删除git仓库"></a>2.1 删除git仓库</h4><p>​	如果项目是拉取的，或者想要换一个gitee仓库，那么在使用自己的仓库之前需要将之前的删掉。步骤如下：</p>
<ol>
<li><p>打开命令行工具,得航到你的项目所在的目录。</p>
</li>
<li><p>输入以下命令来取消当前项目与Gitee的关联: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>

<p>这里的”origin”通常是默认的远程仓库名称，但如果你使用了不同的名称，你需要将其替换为实际的远程仓库名。</p>
</li>
<li><p>输入以下命令来检查是否已成功取消关联:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -V</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​		如果没有版本提示，说明就是删除成功了，跳到2.2步</p>
<h4 id="2-2-提交代码到gitee仓库"><a href="#2-2-提交代码到gitee仓库" class="headerlink" title="2.2 提交代码到gitee仓库"></a>2.2 提交代码到gitee仓库</h4><ol>
<li><p>项目初始化。右键自己的项目，或者进项目的目录一级，右键打开git bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 右键自己的项目，或者进项目的目录一级，右键打开git bash</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>



<p>此时文件夹中多出一个.git文件（需要打开隐藏文件夹开关）</p>
<img src="init%E5%91%BD%E4%BB%A4.png" style="zoom: 50%;">




</li>
<li><p>添加远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># origin 后面的是自己在gitee上创建的仓库地址</span></span><br><span class="line">git remote add origin https://gitee.com/samurai127/XXX.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否连接成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p>提示版本号说明成功绑定</p>
</li>
</ol>
<h4 id="2-3-提交"><a href="#2-3-提交" class="headerlink" title="2.3 提交"></a>2.3 提交</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将代码提交到本地仓库</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git commit -m <span class="string">&#x27;版本备注&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代码推送到远程仓库。如果多人开发，需要把master换成自己的分支，例如dev01</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>至此，在gitee上已经能够看到提交的代码了</p>
<h4 id="2-4-版本回退"><a href="#2-4-版本回退" class="headerlink" title="2.4 版本回退"></a>2.4 版本回退</h4><p>如果本地的代码被你改的bug一大堆，那么可以尝试恢复到之前交的git仓库的版本。<br>此处推荐使用reset命令进行版本回退（如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法）。</p>
<h5 id="2-4-1-回退到上一个版本"><a href="#2-4-1-回退到上一个版本" class="headerlink" title="2.4.1 回退到上一个版本"></a>2.4.1 回退到上一个版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取所有更新，不同步</span></span><br><span class="line">git fetch --all </span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地代码同步线上最新版本(会覆盖本地所有与远程仓库.上同名的文件);</span></span><br><span class="line">git reset --hard origin/ master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再更新一次 (其实也可以不用，第二二步命令做过了其实)</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>



<h5 id="2-4-2-回退到指定版本"><a href="#2-4-2-回退到指定版本" class="headerlink" title="2.4.2 回退到指定版本"></a>2.4.2 回退到指定版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看版本号</span></span><br><span class="line">git logs</span><br><span class="line"><span class="comment"># 回退版本：f42aa0e换成需要的版本号</span></span><br><span class="line">git reset --hard f42aa0e</span><br></pre></td></tr></table></figure>



<h3 id="3-管理分支开发"><a href="#3-管理分支开发" class="headerlink" title="3. 管理分支开发"></a>3. 管理分支开发</h3><h4 id="3-1-从其他分支更新本地代码"><a href="#3-1-从其他分支更新本地代码" class="headerlink" title="3.1 从其他分支更新本地代码"></a>3.1 从其他分支更新本地代码</h4><p>假设多人开发，我在dev01，另一个成员在dev02，dev02更新后上传到origin dev02，我需要在本地更新dev02的代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin dev02:dev01</span><br></pre></td></tr></table></figure>



<p>看一张图了解原理：</p>
<img src="pull%E5%91%BD%E4%BB%A4.png" style="zoom: 50%;">

<p><strong>所以：git pull &#x3D; git fetch + git merge</strong></p>
<h4 id="3-2-绑定远程分支和本地分支"><a href="#3-2-绑定远程分支和本地分支" class="headerlink" title="3.2 绑定远程分支和本地分支"></a>3.2 绑定远程分支和本地分支</h4><p>按照3.1的场景，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev02 origin/dev02 </span><br></pre></td></tr></table></figure>

<p>这个命令做了如下事情：</p>
<ol>
<li><strong>创建本地分支</strong>：如果本地不存在名为 dev02 的分支，这个命令会创建一个新的本地分支 dev02。</li>
<li><strong>设置上游分支</strong>：新创建的本地 dev02 分支会自动设置为跟踪（tracking）远程仓库 origin 上的 dev02 分支。这意味着当你以后在这个本地分支上执行 git pull 或 git  push（不带参数）时，Git 会知道要与远程的 origin&#x2F;dev02 分支进行交互。</li>
</ol>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>软件技术</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程：一、线程池</title>
    <url>/2024/08/03/java-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>全文了解线程池干货，<strong>要想看面试题直接看标题中带有八股的就行了。</strong></p>
<h1 id="一、什么是线程池"><a href="#一、什么是线程池" class="headerlink" title="一、什么是线程池"></a>一、什么是线程池</h1><h2 id="1-1-什么是线程池？"><a href="#1-1-什么是线程池？" class="headerlink" title="1.1 什么是线程池？"></a>1.1 什么是线程池？</h2><p>线程池（Thread Pool）是一种并发编程中常用的技术，用于管理和重用线程。它由线程池管理器、工作队列和线程池线程组成。</p>
<p>线程池的基本概念是，在应用程序启动时创建一定数量的线程，并将它们保存在线程池中。当需要执行任务时，从线程池中获取一个空闲的线程，将任务分配给该线程执行。当任务执行完毕后，线程将返回到线程池，可以被其他任务复用。</p>
<p>大白话：线程池的设计思想是为了避免频繁地创建和销毁线程的开销，以及控制并发执行的线程数量，从而提高系统的性能和资源利用率。线程池保证线程的可复用。</p>
<h2 id="1-2-线程池的关键组成部分："><a href="#1-2-线程池的关键组成部分：" class="headerlink" title="1.2 线程池的关键组成部分："></a>1.2 线程池的关键组成部分：</h2><h3 id="1-2-1-线程池管理器（ThreadPoolExecutor）"><a href="#1-2-1-线程池管理器（ThreadPoolExecutor）" class="headerlink" title="1.2.1 线程池管理器（ThreadPoolExecutor）"></a>1.2.1 线程池管理器（ThreadPoolExecutor）</h3><p>负责创建、管理和控制线程池。它负责线程的创建、销毁和管理，以及线程池的状态监控和调度任务。</p>
<h3 id="1-2-2-线程池阻塞队列（BlockingQueue）"><a href="#1-2-2-线程池阻塞队列（BlockingQueue）" class="headerlink" title="1.2.2 线程池阻塞队列（BlockingQueue）"></a>1.2.2 线程池阻塞队列（BlockingQueue）</h3><p>用于存储待执行的任务。当线程池中的线程都在执行任务时，新的任务会被放入工作队列中等待执行。</p>
<h3 id="1-2-3-线程池线程（Worker-Thread）"><a href="#1-2-3-线程池线程（Worker-Thread）" class="headerlink" title="1.2.3 线程池线程（Worker Thread）"></a>1.2.3 线程池线程（Worker Thread）</h3><p>实际执行任务的线程。线程池中会维护一组线程，这些线程可以被重复使用，从而避免了频繁创建和销毁线程的开销。</p>
<h2 id="1-3-八股：Java线程池中阻塞队列常用类型有哪些？"><a href="#1-3-八股：Java线程池中阻塞队列常用类型有哪些？" class="headerlink" title="1.3 八股：Java线程池中阻塞队列常用类型有哪些？"></a>1.3 八股：Java线程池中阻塞队列常用类型有哪些？</h2><p><code>ArrayBlockingQueue</code>是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则 对元素进行排序。 </p>
<p><code>LinkedBlockingQueue</code> 一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于 ArrayBlockingQueue </p>
<p><code>SynchronousQueue</code>一个不存储元素的阻塞队列。</p>
<p><code>PriorityBlockingQueue</code>一个具有优先级的无限阻塞队列。PriorityBlockingQueue也是基于最小二叉堆实现。PriorityBlockingQueue 并<strong>不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。</strong><br>因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度</strong>，否则时间一长，会最终耗尽所有的可用堆内存空间。</p>
<p><code>DelayQueue</code> 阿里内部资料只有当其指定的延迟时间到了，才能够从队列中获取到该元素。 DelayQueue是一个没有大小限制的队列， 因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。 </p>
<p>这里能说出前三种也就差不多了，如果能说全那是最好。</p>
<h1 id="二、八股：常用的线程池"><a href="#二、八股：常用的线程池" class="headerlink" title="二、八股：常用的线程池"></a>二、八股：常用的线程池</h1><p><strong>newSingleThreadExecutor：</strong>创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<p><strong>newFixedThreadPool：</strong>创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</p>
<p><strong>newCachedThreadPool：</strong>创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p>
<p><strong>newScheduledThreadPool：</strong>创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</p>
<h1 id="三、使用线程池的步骤"><a href="#三、使用线程池的步骤" class="headerlink" title="三、使用线程池的步骤"></a>三、使用线程池的步骤</h1><h2 id="3-1-使用线程池的一般步骤如下："><a href="#3-1-使用线程池的一般步骤如下：" class="headerlink" title="3.1 使用线程池的一般步骤如下："></a>3.1 使用线程池的一般步骤如下：</h2><ol>
<li><strong>创建线程池：</strong>使用Executors工具类提供的静态方法之一，或者直接使用ThreadPoolExecutor类来创建线程池。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); <span class="comment">// 创建固定大小的线程池</span></span><br></pre></td></tr></table></figure>

<p><img src="Snipaste_2024-08-03_18-05-06.png" alt="使用executors工具类创建线程"></p>
<p><code>newCachedThreadPool</code>说是没有上限的线程池，实际上还是有的，是int的最大值。并且普通电脑在创建几千个的时候就蚌埠住了，所以理论上是没有上限的线程池。</p>
<ol start="2">
<li><strong>提交任务：</strong>使用execute()或submit()方法将任务提交给线程池。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executor.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>()); <span class="comment">// 提交Runnable任务</span></span><br><span class="line">Future&lt;String&gt; future = executor.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>()); <span class="comment">// 提交Callable任务，并返回Future对象</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>关闭线程池：</strong>在不再需要线程池时，需要调用shutdown()方法来关闭线程池。这将停止接受新任务，并逐渐关闭线程池中的线程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>

<p>实际开发中不会关闭线程池，比如游戏的服务器之类的，实时打开，在学习的时候还是需要了解流程的。</p>
<h2 id="3-2-八股：Java线程池中submit-和-execute-方法有什么区别？"><a href="#3-2-八股：Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="3.2 八股：Java线程池中submit() 和 execute()方法有什么区别？"></a>3.2 八股：Java线程池中submit() 和 execute()方法有什么区别？</h2><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了 Executor接口，其它线程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些 方法。</p>
<h2 id="3-3-演示线程池（个人认为理解线程池的需要看）"><a href="#3-3-演示线程池（个人认为理解线程池的需要看）" class="headerlink" title="3.3 演示线程池（个人认为理解线程池的需要看）"></a>3.3 演示线程池（个人认为理解线程池的需要看）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.print1n(Thread.current <span class="title function_">Thread</span><span class="params">()</span>.getName() + ---<span class="string">&quot; );</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//main方法：</span></span><br><span class="line"><span class="string">//1.获取线程池对象</span></span><br><span class="line"><span class="string">ExecutorService pool1 = Executors . newCachedThreadPool();</span></span><br><span class="line"><span class="string">//2.提交任务</span></span><br><span class="line"><span class="string">pool1. submit (new MyRunnable());</span></span><br><span class="line"><span class="string">//Thread.sleep( millis: 1000);</span></span><br><span class="line"><span class="string">poo11.submit (new MyRunnable());</span></span><br><span class="line"><span class="string">//Thread.sleep( millis: 1000);</span></span><br><span class="line"><span class="string">pool1.submit(new MyRunnable());</span></span><br><span class="line"><span class="string">//Thread.sleep( millis: 1000);</span></span><br><span class="line"><span class="string">pool1.submit(new MyRunnable());</span></span><br><span class="line"><span class="string">//Thread.sleep( millis: 1000);</span></span><br><span class="line"><span class="string">poo11.submit (new MyRunnable());</span></span><br><span class="line"><span class="string">//Thread.sleep( millis: 1000);</span></span><br><span class="line"><span class="string">pool1.submit (new MyRunnable());</span></span><br><span class="line"><span class="string">//3.销毁线程池</span></span><br><span class="line"><span class="string">//pool1. shutdown();</span></span><br></pre></td></tr></table></figure>

<p>首先，在main方法中，不让main线程sleep，那么打印的结果如下：可以看到，线程池1中创建了1,2,3,4,5，一共5个线程（打印结果比较长我就截图一部分，实际上是5个）</p>
<p><img src="Snipaste_2024-08-03_18-21-34.png" alt="main线程没有sleep的打印结果"></p>
<p><strong>如果让main线程睡眠，那么可以让线程1在main方法sleep时赶紧结束run方法中的逻辑，使得线程1执行结束后返回线程池，在main线程sleep的时间结束后，再次调用submit方法时，拿到的还是线程1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.print1n(Thread.current <span class="title function_">Thread</span><span class="params">()</span>.getName() + ---<span class="string">&quot; );</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//main方法：</span></span><br><span class="line"><span class="string">//1.获取线程池对象</span></span><br><span class="line"><span class="string">ExecutorService pool1 = Executors . newCachedThreadPool();</span></span><br><span class="line"><span class="string">//2.提交任务</span></span><br><span class="line"><span class="string">pool1. submit (new MyRunnable());</span></span><br><span class="line"><span class="string">Thread.sleep( millis: 1000);</span></span><br><span class="line"><span class="string">poo11.submit (new MyRunnable());</span></span><br><span class="line"><span class="string">Thread.sleep( millis: 1000);</span></span><br><span class="line"><span class="string">pool1.submit(new MyRunnable());</span></span><br><span class="line"><span class="string">Thread.sleep( millis: 1000);</span></span><br><span class="line"><span class="string">pool1.submit(new MyRunnable());</span></span><br><span class="line"><span class="string">Thread.sleep( millis: 1000);</span></span><br><span class="line"><span class="string">poo11.submit (new MyRunnable());</span></span><br><span class="line"><span class="string">Thread.sleep( millis: 1000);</span></span><br><span class="line"><span class="string">pool1.submit (new MyRunnable());</span></span><br><span class="line"><span class="string">//3.销毁线程池</span></span><br><span class="line"><span class="string">//pool1. shutdown();</span></span><br></pre></td></tr></table></figure>

<p><img src="Snipaste_2024-08-03_18-26-05.png" alt="使main线程sleep的打印结果"></p>
<h1 id="四、线程池原理"><a href="#四、线程池原理" class="headerlink" title="四、线程池原理"></a>四、线程池原理</h1><h2 id="4-1-ThreadPoolExecutor类"><a href="#4-1-ThreadPoolExecutor类" class="headerlink" title="4.1 ThreadPoolExecutor类"></a>4.1 ThreadPoolExecutor类</h2><p>在创建线程池的方法中（3.1节），曾经说过创建线程池使用工具类或者使用ThreadPoolExecutor类，实际上工具类的底层也是调用ThreadPoolExecutor类来创建线程池：</p>
<p>Executors类提供4个静态工厂方法：newCachedThreadPool()、newFixedThreadPool(int)、newSingleThreadExecutor和newScheduledThreadPool(int)。这些方法最终都是通过ThreadPoolExecutor类来完成的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以看到类里面有7个参数，这7个参数也就是线程池的核心参数。</strong></p>
<h2 id="4-2-八股：线程池七大核心参数"><a href="#4-2-八股：线程池七大核心参数" class="headerlink" title="4.2 八股：线程池七大核心参数"></a>4.2 八股：线程池七大核心参数</h2><h3 id="4-2-1-黑马讲的故事（方便记忆参数，可以跳过）"><a href="#4-2-1-黑马讲的故事（方便记忆参数，可以跳过）" class="headerlink" title="4.2.1 黑马讲的故事（方便记忆参数，可以跳过）"></a>4.2.1 黑马讲的故事（方便记忆参数，可以跳过）</h3><p>故事就是讲了饭店内只有3名正式员工，同时招待的顾客最大6人，但是剩下的3名员工是临时工，只有招待人数大于3人的时候才会去招人，否则就不招，辞退这三个临时工。</p>
<p><img src="Snipaste_2024-08-03_18-48-51.png"></p>
<p>但是饭店小，只能允许10个人排队，超出的人就不给排队了</p>
<p><img src="Snipaste_2024-08-03_18-53-22.png"></p>
<p>OK，现在根据故事给出的7个参数代换： </p>
<p><img src="Snipaste_2024-08-03_18-57-58.png" alt="7个参数代换"></p>
<h3 id="4-2-2-八股：7个核心参数"><a href="#4-2-2-八股：7个核心参数" class="headerlink" title="4.2.2 八股：7个核心参数"></a>4.2.2 八股：7个核心参数</h3><ol>
<li>int corePoolSize,核心线程数量，不能小于0 </li>
<li>int maximumPoolSize,最大的线程数量，减去核心线程&#x3D;临时线程</li>
<li>long keepAliveTime,空闲线程的最大存活时间</li>
<li>TimeUnit unit,时间单位</li>
<li>BlockingQueue<Runnable> workQueue,任务队列</Runnable></li>
<li>ThreadFactory threadFactory,创建线程工厂</li>
<li>RejectedExecutionHandler handler，任务的拒绝策略</li>
</ol>
<h2 id="4-3-线程池的工作原理流程（建议4-3全看，方便理解4-5的八股）"><a href="#4-3-线程池的工作原理流程（建议4-3全看，方便理解4-5的八股）" class="headerlink" title="4.3 线程池的工作原理流程（建议4.3全看，方便理解4.5的八股）"></a>4.3 线程池的工作原理流程（建议4.3全看，方便理解4.5的八股）</h2><h3 id="4-3-1-场景一"><a href="#4-3-1-场景一" class="headerlink" title="4.3.1 场景一"></a>4.3.1 场景一</h3><p>现在有如下场景：核心线程3个，临时线程3个，此时有5个任务进来的时候线程池应该如何创建线程？</p>
<p><img src="Snipaste_2024-08-03_19-05-57.png"></p>
<p>正确的是创建3个核心线程去处理前3个任务，而后两个任务应该排队，直到3个核心线程空闲出来才会被执行。</p>
<p><img src="Snipaste_2024-08-03_19-07-50.png"></p>
<h3 id="4-3-2-场景二"><a href="#4-3-2-场景二" class="headerlink" title="4.3.2 场景二"></a>4.3.2 场景二</h3><p>此时在场景一中，提交的任务数是8个，那么线程池如何创建线程？</p>
<p>答案是1,2,3任务由核心线程处理，4,5,6任务进入阻塞队列，7,8任务交给临时线程处理。</p>
<p><strong>重点：</strong></p>
<ol>
<li>只有阻塞队列满了以后，才会临时线程</li>
<li>任务被线程处理的顺序不取决于先来先处理，比如案例中4,5,6任务先来但是7,8任务先被处理</li>
</ol>
<p><img src="Snipaste_2024-08-03_19-13-39.png"></p>
<h3 id="4-3-3-场景三"><a href="#4-3-3-场景三" class="headerlink" title="4.3.3 场景三"></a>4.3.3 场景三</h3><p>当提交的任务数超过了核心线程数（参数1），临时线程数（参数2减去参数1），队列数（参数6，创建阻塞队列的时候给队列传递参数决定容量的大小，比如ArrayBlockingQueue指定数组大小，见1.3节）的时候，多出来的线程就会触发拒绝策略（参数7）</p>
<p><img src="Snipaste_2024-08-03_19-23-56.png"></p>
<h2 id="4-4-八股：任务拒绝策略（参数7）"><a href="#4-4-八股：任务拒绝策略（参数7）" class="headerlink" title="4.4 八股：任务拒绝策略（参数7）"></a>4.4 八股：任务拒绝策略（参数7）</h2><p><img src="Snipaste_2024-08-03_19-28-28.png" alt="任务拒绝策略"></p>
<p><strong>主要的是使用默认的策略。</strong></p>
<p>如果使用第三个，那么在场景三中，被抛弃的是任务4，然后加入任务10，队列为5&#x3D;&gt;6&#x3D;&gt;10</p>
<p>如果使用第四个，那么任务10会跳过线程池，直接调用这个线程的run方法</p>
<h2 id="4-5-阿里八股：线程池原理知道吗？以及核心参数？"><a href="#4-5-阿里八股：线程池原理知道吗？以及核心参数？" class="headerlink" title="4.5 阿里八股：线程池原理知道吗？以及核心参数？"></a>4.5 阿里八股：线程池原理知道吗？以及核心参数？</h2><p>首先线程池有几个核心的参数概念： </p>
<ol>
<li>最大线程数maximumPoolSize </li>
<li>核心线程数corePoolSize </li>
<li>活跃时间keepAliveTime </li>
<li>阻塞队列workQueue </li>
<li>拒绝策略RejectedExecutionHandler</li>
</ol>
<p>当提交一个新任务到线程池时，具体的执行流程如下： </p>
<ol>
<li>当我们提交任务，线程池会根据corePoolSize大小创建若干任务数量线程执行任务 </li>
<li>当任务的数量超过corePoolSize数量，后续的任务将会进入阻塞队列阻塞排队 </li>
<li>当阻塞队列也满了之后，那么将会继续创建(maximumPoolSize-corePoolSize)个数量的线程来 执行任务，如果任务处理完成，maximumPoolSize-corePoolSize额外创建的线程等待 keepAliveTime之后被自动销毁 </li>
<li>如果达到maximumPoolSize，阻塞队列还是满的状态，那么将根据不同的拒绝策略对应处理</li>
</ol>
<p><img src="Snipaste_2024-08-03_19-33-13.png"></p>
<p>这是阿里面试多线程&amp;JUC的35题，我直接照着搬答案过来了，是不是把第四大节看完后就很好理解了？</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM：详解GC</title>
    <url>/2024/08/13/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-gc/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>据我看到的面试题有：判断垃圾回收的算法有什么，以及是什么原理，垃圾收集算法有什么，常见的垃圾回收器有什么，什么是STW等，所以这篇博客基于GC给大家介绍，如果有其他面试题可以在评论区发言，博客可修改内容，可添加。</p>
<h1 id="一、判断垃圾回收的算法"><a href="#一、判断垃圾回收的算法" class="headerlink" title="一、判断垃圾回收的算法"></a>一、判断垃圾回收的算法</h1><p>先提前说两个算法，分别是：</p>
<ol>
<li><p>引用标记算法</p>
</li>
<li><p>可达性分析算法</p>
</li>
</ol>
<h2 id="1-引用标记算法"><a href="#1-引用标记算法" class="headerlink" title="1.引用标记算法"></a>1.引用标记算法</h2><p>引用标记算法是在Java对象头（Java对象头在介绍多线程的时候有详细的解释，直达链接：<a href="https://rengoku.top/2024/08/05/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E4%B8%89%E3%80%81%E9%94%81/">Java多线程：三、多线程锁、java锁的实现</a>）中开辟空间，记录<strong>被引用的次数（Reference Count）</strong>，如果A变量被其他对象引用时计数器+1，引用A变量的其他变量被删除则-1，如果计数器为0时，则判断A变量需要被回收。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我不想上早八&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时，在Java虚拟机栈（以下简称栈）开辟一个内存空间记录str，此时堆中的字符串常量池的“我不想上早八”，被引用的次数就是1（Reference Count&#x3D;1），此时我做修改操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;其实我想上早七&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时，在栈中的变量str原本引用常量池的”我不想上早八”引用次数为0，那么这一块就会被回收。</p>
<p>引用标记算法的回收机制遍布整个代码运行时期而没有集中于垃圾回收时期，因此不属于”Stop-The-World”的范围。</p>
<blockquote>
<p>“Stop The World”是 Java 垃圾收集中的一个重要概念。在垃圾收集过程中，JVM 会暂停所有的用户线程，这种暂停被称为”Stop The World”事件。</p>
<p>这么做的主要原因是为了防止在垃圾收集过程中，用户线程修改了堆中的对象，导致垃圾收集器无法准确地收集垃圾。</p>
</blockquote>
<p><strong>引用标记算法存在的问题：</strong></p>
<p>无法解决循环依赖的问题，看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object instance;  <span class="comment">// 对象属性，用于存储对另一个 ReferenceCountingGC 对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReferenceCountingGC</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testGC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个 ReferenceCountingGC 对象</span></span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>(<span class="string">&quot;我爱玩原神&quot;</span>);</span><br><span class="line">        <span class="type">ReferenceCountingGC</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGC</span>(<span class="string">&quot;那维莱特一次回调比得上3年的陪伴&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使 a 和 b 相互引用</span></span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 a 和 b 设置为 null</span></span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        b = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个位置是垃圾回收的触发点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码中a,b变量相互引用，即使将将 a 和 b 设置为 null，也无法将字符串的引用改变（即Reference Count没有被减到0）。从案例可以知道，这样写永远无法通知GC对这两个字符串进行收集。</p>
<h2 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2.可达性分析算法"></a>2.可达性分析算法</h2><p>现代虚拟机基本都是采用可达性分析算法来判断对象是否存活，可达性算法的原理是以一系列叫做  <strong>GC Root</strong> 的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。这样通过 GC Root 串成的一条线就叫引用链），直到所有的结点都遍历完毕,如果相关对象不在任意一个以 <strong>GC Root</strong> 为起点的引用链中，则这些对象会被判断为垃圾对象,会被 GC 回收。</p>
<p><img src="Snipaste_2024-08-13_10-31-47.png"></p>
<p><strong>a, b 对象可回收，就一定会被回收吗?</strong></p>
<p>并不是，对象的 finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！</p>
<p><strong>注意：</strong> finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记!</p>
<p><strong>GC Roots 到底是什么东西呢，哪些对象可以作为 GC Root 呢？</strong></p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
</ul>
<p>关于这四个例子可以参考：<a href="https://blog.csdn.net/weixin_38007185/article/details/108093716">GC Roots 是什么？哪些对象可以作为 GC Root？看完秒懂！-CSDN博客</a></p>
<h1 id="二、八股：垃圾收集算法"><a href="#二、八股：垃圾收集算法" class="headerlink" title="二、八股：垃圾收集算法"></a>二、八股：垃圾收集算法</h1><p>阿里八股16题，我们来详细的谈谈：</p>
<h2 id="1-标记清除算法"><a href="#1-标记清除算法" class="headerlink" title="1.标记清除算法"></a>1.标记清除算法</h2><p>标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为 2 部分，先把内存区域中的这些对象进行标记，哪些属于可回收的标记出来（用前面提到的可达性分析法），然后把这些垃圾拎出来清理掉。</p>
<p><img src="gc-20231227125304.png" alt="标记清除算法"></p>
<p>标记清除算法存在一个缺陷，在垃圾回收以后会产生内存碎片，无法应对需要一口气分配大内存的情况。</p>
<blockquote>
<p>内存碎片化是指在内存分配和回收过程中，被释放的内存空间没有被合并成较大的连续空间，而是形成了许多小块的、不连续的内存区域。这会导致在后续需要分配大块连续内存时，系统可能无法找到足够的连续空间，从而影响程序的性能和稳定性。</p>
</blockquote>
<h2 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h2><p>复制算法（Copying）是在标记清除算法上演化而来的，用于解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</p>
<p>当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样就保证了内存的连续性，逻辑清晰，运行高效。</p>
<p><img src="gc-20231227125751.png"></p>
<p>但是也是存在一个大缺陷，相当于一大堆的内存我只能当一半用。</p>
<h2 id="3-标记整理算法"><a href="#3-标记整理算法" class="headerlink" title="3.标记整理算法"></a>3.标记整理算法</h2><p>标记整理算法（Mark-Compact），标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p>
<p><img src="gc-20231227130011.png"></p>
<p>标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法差很多。</p>
<h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h2><h3 id="4-1-分代收集算法组合拳"><a href="#4-1-分代收集算法组合拳" class="headerlink" title="4.1 分代收集算法组合拳"></a>4.1 分代收集算法组合拳</h3><p>分代收集算法（Generational Collection）严格来说并不是一种思想或理论，而是融合上述 3 种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。</p>
<p>根据对象存活周期的不同会将内存划分为几块，一般是把 <strong>Java 堆分为新生代和老年代</strong>，这样就可以根据各个年代的特点采用最适当的收集算法。</p>
<p><img src="gc-20231227131241.png"></p>
<p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记清理或者标记整理算法来进行回收。</p>
<blockquote>
<p>这里提到了新生代和永久代，在JVM运行时数据区中也提到了一个”代“叫永久代，还记得永久代是什么吗？</p>
<p>永久代也叫方法区，在jdk8之后被代替成了元空间，运行时常量池放在元空间中，而字符串常量池在堆中。</p>
</blockquote>
<h3 id="4-2-新生代和老年代"><a href="#4-2-新生代和老年代" class="headerlink" title="4.2 新生代和老年代"></a>4.2 新生代和老年代</h3><p>堆主要分为 2 个区域，年轻代与老年代，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 两个区。</p>
<p><img src="gc-20231227132701.png"></p>
<h4 id="4-2-1-Eden-区"><a href="#4-2-1-Eden-区" class="headerlink" title="4.2.1 Eden 区"></a>4.2.1 Eden 区</h4><p>据 IBM 公司之前的研究表明，有将近 98% 的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，JVM 会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。</p>
<p>通过 Minor GC 之后，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区，如果 From 区不够，则直接进入 To 区。</p>
<p><strong>什么是Minor GC和Major GC？</strong></p>
<p>Minor GC是新生代的GC，Major GC是老年代的GC</p>
<p><strong>Survivor区的from和to角色切换</strong></p>
<ol>
<li>初始状态<ul>
<li>在JVM启动时，两个Survivor区中的一个被指定为from区，另一个为to区。这个初始分配是任意的，但一旦确定，它们将在后续的GC过程中交替使用。</li>
</ul>
</li>
<li>Minor GC过程<ul>
<li>当Eden区满或JVM认为需要执行Minor GC时，GC过程开始。</li>
<li>此时，from区存储着上一次GC后存活下来的对象。</li>
<li>GC扫描Eden区和from区，将存活的对象复制到to区。</li>
<li>如果对象的年龄（即经历Minor GC的次数）达到一定程度（默认是15次，但可以通过参数<code>-XX:MaxTenuringThreshold</code>来设定），则这些对象可能会被移动到老年代（Old Generation）。</li>
<li>GC完成后，Eden区和from区的内容被清空，然后这两个区域的角色互换：原来的to区变为新的from区，原来的from区变为新的to区。</li>
</ul>
</li>
<li>持续交替<ul>
<li>上述过程在每次Minor GC时都会重复，导致Survivor区的from和to角色持续交替。</li>
</ul>
</li>
</ol>
<h4 id="4-2-2-Survivor-区"><a href="#4-2-2-Survivor-区" class="headerlink" title="4.2.2 Survivor 区"></a>4.2.2 Survivor 区</h4><p>Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。</p>
<p><strong>为啥需要 Survivor 区？</strong></p>
<p>不就是新生代到老年代吗，直接 Eden 到 Old 不好了吗，为啥要这么复杂。</p>
<p>如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。</p>
<p>这时候移入老年区，很明显不是一个明智的决定。</p>
<p>所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历 16 次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</p>
<p><strong>Survivor 区为啥划分为两块？</strong></p>
<p>设置两个 Survivor 区最大的好处就是解决内存碎片化，我们先假设一下，Survivor 只有一个区域会怎样。</p>
<p>Minor GC 执行后，Eden 区被清空，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。那么问题来了，这时候我们怎么清除它们？</p>
<p>在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。</p>
<p>但因为 Survivor 有 2 个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。</p>
<p>这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。</p>
<p>那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个？</p>
<p>显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。</p>
<h4 id="4-2-3-Old-区"><a href="#4-2-3-Old-区" class="headerlink" title="4.2.3 Old 区"></a>4.2.3 Old 区</h4><p>老年代占据着 2&#x2F;3 的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。</p>
<p>由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记整理算法。</p>
<h2 id="5-组合拳如何体现？"><a href="#5-组合拳如何体现？" class="headerlink" title="5.组合拳如何体现？"></a>5.组合拳如何体现？</h2><p>对于前三种收集算法，我们采用分代收集将前三种混合。</p>
<p><strong>新生代，主要采用复制算法</strong>，我相信聪明的你能看得出来，<strong>Survivor 区的from和to区就是复制算法中提到的，将内存一分为二的部分。</strong></p>
<p><strong>老年代，采用标记整理算法</strong>，理由有这些（ai部分）：</p>
<ol>
<li><strong>存活率高</strong>：老年代中的对象通常已经经过了多次垃圾回收周期，存活率较高。这意味着在每次垃圾回收时，只有少数对象会被回收，而大部分对象都会保留下来。如果使用复制算法，需要将存活的对象复制到另一块内存区域，这将导致大量的数据复制操作，不仅效率低下，还会增加系统的停顿时间。</li>
<li><strong>内存空间</strong>：老年代通常占据堆内存的大部分空间，以容纳更多的长时间存活对象。如果采用复制算法，需要为老年代分配同样大小的额外内存空间作为复制的目标区域，这在很多情况下是不现实的，因为这将极大地增加内存的使用量。</li>
<li><strong>内存碎片</strong>：虽然复制算法可以避免内存碎片的产生，但在老年代中，内存碎片的问题并不像新生代那样严重。老年代中的对象通常较大，且存活时间较长，因此内存碎片对性能的影响相对较小。相比之下，减少内存碎片并不是老年代选择垃圾收集算法的主要考虑因素。</li>
<li><strong>算法适用性</strong>：不同的垃圾收集算法适用于不同的场景。复制算法由于其简单性和高效性，在新生代中得到了广泛应用。然而，在老年代中，由于对象的特性和内存空间的需求，更适合采用其他类型的垃圾收集算法，如标记-清除、标记-整理或混合使用多种算法（如G1收集器中的混合收集策略，G1收集器下文介绍）。</li>
</ol>
<h1 id="三、垃圾收集器"><a href="#三、垃圾收集器" class="headerlink" title="三、垃圾收集器"></a>三、垃圾收集器</h1><p>垃圾收集器在这篇博客有8种，我把总览放出来，然后讲几个比较常用的：<a href="https://blog.csdn.net/weixin_44772566/article/details/136248892">一文彻底搞懂八种JVM垃圾回收器_说一下 jvm 有哪些垃圾回收器?-CSDN博客</a></p>
<p><img src="b7066e4374f7d7397613068ac5fdf5b1.png" alt="常用的垃圾收集器"></p>
<h2 id="1-CMS收集器"><a href="#1-CMS收集器" class="headerlink" title="1.CMS收集器"></a>1.CMS收集器</h2><p><strong>CMS垃圾收集器旨在降低STW的时间，允许垃圾回收器进行垃圾回收的同时，与应用程序并发进行。</strong></p>
<h3 id="1-1-步骤"><a href="#1-1-步骤" class="headerlink" title="1.1 步骤"></a>1.1 步骤</h3><p>CMS 垃圾收集器通过三色标记算法，实现了垃圾回收线程与用户线程的并发执行，从而极大地降低了系统响应时间，提高了强交互应用程序的体验。它的运行过程分为 4 个步骤，包括：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p><strong>初始标记</strong>，指的是寻找所有被 GCRoots 引用的对象，该阶段需要「Stop the World」。这个步骤仅仅只是标记一下 GC Roots 能直接关联到的对象，并不需要做整个引用的扫描，因此速度很快。</p>
<p><strong>并发标记</strong>，指的是对「初始标记阶段」标记的对象进行整个引用链的扫描，该阶段不需要「Stop the World」。 对整个引用链做扫描需要花费非常多的时间，因此通过垃圾回收线程与用户线程并发执行，可以降低垃圾回收的时间。</p>
<p>这也是 CMS 能极大降低 GC 停顿时间的核心原因，但这也带来了一些问题，即：并发标记的时候，引用可能发生变化，因此可能发生漏标（本应该回收的垃圾没有被回收）和多标（本不应该回收的垃圾被回收）了。</p>
<p><strong>重新标记</strong>，指的是对「并发标记」阶段出现的问题进行校正，该阶段需要「Stop the World」。正如并发标记阶段说到的，由于垃圾回收算法和用户线程并发执行，虽然能降低响应时间，但是会发生漏标和多标的问题。所以对于 CMS 来说，它需要在这个阶段做一些校验，解决并发标记阶段发生的问题。</p>
<p><strong>并发清除</strong>，指的是将标记为垃圾的对象进行清除，该阶段不需要「Stop the World」。 在这个阶段，垃圾回收线程与用户线程可以并发执行，因此并不影响用户的响应时间。</p>
<p><strong>注：</strong><br>收集区域： 老年代（见图常用的垃圾收集器。标记清除和标记整理也是用于老年代的垃圾收集算法，可以回看）<br>使用算法： 标记清除法+标记整理法<br>搜集方式： 多线程</p>
<h3 id="1-2-优劣势"><a href="#1-2-优劣势" class="headerlink" title="1.2 优劣势"></a>1.2 优劣势</h3><p>优点总结就是支持垃圾回收和程序执行的并发，降低STW时间，详细的可以参考以下内容：</p>
<p>并发标记和清除：CMS 垃圾收集器采用了并发标记和清除的方式，允许在垃圾收集过程中与应用程序并发执行。这意味着垃圾收集过程中只有一小部分时间需要暂停应用程序线程。<br>低停顿时间：由于并发执行的特性，CMS 垃圾收集器能够在较短的时间内完成垃圾回收操作，从而减少了应用程序的停顿时间。通常情况下，CMS 垃圾收集器能够将停顿时间控制在几百毫秒甚至更低。<br>老年代收集：CMS 垃圾收集器主要针对老年代进行垃圾回收，对于新生代则通常使用 ParNew 收集器。这种分代收集的方式能够更好地适应不同内存区域的特点和垃圾回收需求。</p>
<blockquote>
<p>这里提到了ParNew收集器，那么我也写一下，本来不想写来着（）</p>
</blockquote>
<p>劣势从算法考虑，无非就是会产生内存碎片，以及在垃圾收集与应用程序并发执行的过程中，应用程序也会一直产生垃圾，这个垃圾称为浮游垃圾，这部分只能等到下一次gc来处理，另外这两个并发的话，如果cpu的核心数（对线程的处理能力低）那么CMS的性能肯定会大打折扣。</p>
<h2 id="2-ParNew收集器"><a href="#2-ParNew收集器" class="headerlink" title="2.ParNew收集器"></a>2.ParNew收集器</h2><p>在上边提到的CMS收集器是针对老年代的，而ParNew收集器针对新生代的部分进行垃圾回收，通常和CMS收集器共同进行gc。查到的资料有显示，ParNew收集器是唯一的一个可以和CMS收集器打配合的。</p>
<p><strong>垃圾收集流程</strong><br>ParNew 收集器和 Parallel Scavenge 收集器在工作流程上确实非常相似，都是并行垃圾收集器。</p>
<ol>
<li><p>停止应用程序线程（Stop the World）：在进行垃圾收集之前，ParNew 收集器会暂停所有的用户线程。这一阶段被称为停止应用程序线程，以确保在垃圾收集过程中对象的状态不会被修改，保证垃圾回收的准确性。</p>
</li>
<li><p>多线程并行执行垃圾收集：一旦应用程序线程暂停，ParNew 收集器会启动多个线程并行执行垃圾回收操作。这些线程会同时在新生代中扫描和清理不再使用的对象，以释放内存空间。</p>
</li>
<li><p>暂停用户线程：在整个垃圾收集过程中，用户线程会一直处于暂停状态，直到垃圾收集完成。这个阶段也被称为“Stop the World”，在此期间应用程序无法执行任何操作。</p>
</li>
<li><p>恢复用户线程：当垃圾收集完成后，ParNew 收集器会恢复用户线程的执行。此时，垃圾已经被清理，堆中的内存空间得到了释放，用户线程可以继续执行。</p>
</li>
</ol>
<p>ParNew 收集器的工作流程与 Parallel Scavenge 收集器类似，都是通过停止应用程序线程，然后利用多线程并行执行垃圾回收操作，最后恢复用户线程的执行。这种并行执行的方式能够提高垃圾收集的效率，同时在暂停用户线程期间确保垃圾收集的准确性。</p>
<p><strong>注：</strong><br>收集区域： 新生代<br>使用算法： 标记复制法<br>搜集方式： 多线程。</p>
<p>正常来说，ParNew收集器和CMS收集器是一起打配合的，他俩在分类来说都是分代收集器，一个作用于新生代，一个作用于老年代。</p>
<h2 id="3-G1收集器"><a href="#3-G1收集器" class="headerlink" title="3.G1收集器"></a>3.G1收集器</h2><p>G1 垃圾收集器摒弃了传统的物理分区方式，而是将整个内存分成若干个大小不同的 Region 区域。每个 Region 在逻辑上组合成各个分代，这样做的好处是可以以 Region 为单位进行更细粒度的垃圾回收。G1 垃圾收集器在进行垃圾回收时，可以针对单个或多个 Region 进行回收，从而提高了收集效率和性能。</p>
<p>下面介绍一下G1的相关内容：</p>
<p><strong>分代：</strong>相信大家还记得我们上一讲中的年轻代和老年代，G1 也是基于这个思想进行设计的。<strong>G1舍弃分代，转变为分区，</strong>将堆内存分为多个大小相等的区域（Region），每个区域都可以是 Eden 区、Survivor 区或者 Old 区。</p>
<p><img src="gc-collector-20231228213824.png" alt="G1收集器分区"></p>
<p>可以通过 <code>-XX:G1HeapRegionSize=n</code> 来设置 Region 的大小，可以设定为 1M、2M、4M、8M、16M、32M（不能超过）。</p>
<p>G1 有专门分配大对象的 Region 叫 Humongous 区，而不是让大对象直接进入老年代的 Region 中。在 G1 中，大对象的判定规则就是一个大对象超过了一个 Region 大小的 50%，比如每个 Region 是 2M，只要一个对象超过了 1M，就会被放入 Humongous 中，而且一个大对象如果太大，可能会横跨多个 Region 来存放。</p>
<p>G1 会根据各个区域的垃圾回收情况来决定下一次垃圾回收的区域，这样就避免了对整个堆内存进行垃圾回收，从而降低了垃圾回收的时间。</p>
<p>在进行老年代的垃圾回收时，G1 使用标记-整理算法。这个过程分为两个阶段：标记存活的对象和整理（压缩）堆空间。通过整理，G1 能够避免内存碎片化，提高内存利用率。年轻代的垃圾回收（Minor GC）使用复制算法，因为年轻代的对象通常是朝生夕死的。</p>
<p><img src="gc-collector-20231230100404.png"></p>
<p><strong>STW：</strong>G1 也是基于「标记-清除」算法，因此在进行垃圾回收的时候，仍然需要「Stop the World」。不过，G1 在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</p>
<p><strong>接下来介绍G1的三种回收机制：</strong></p>
<p><img src="gc-collector-20231228215108.png"></p>
<p>当 Eden 区的内存空间无法支持新对象的内存分配时，G1 会触发 Young GC。</p>
<p>当需要分配对象到 Humongous 区域或者堆内存的空间占比超过 <code>-XX:G1HeapWastePercent</code> 设置的 InitiatingHeapOccupancyPercent 值时，G1 会触发一次 concurrent marking，它的作用就是计算老年代中有多少空间需要被回收，当发现垃圾的占比达到 <code>-XX:G1HeapWastePercent</code> 中所设置的 G1HeapWastePercent 比例时，在下次 Young GC 后会触发一次 Mixed GC。</p>
<p>Mixed GC 是指回收年轻代的 Region 以及一部分老年代中的 Region。Mixed GC 和 Young GC 一样，采用的也是复制算法。</p>
<p>在 Mixed GC 过程中，如果发现老年代空间还是不足，此时如果 G1HeapWastePercent 设定过低，可能引发 Full GC。<code>-XX:G1HeapWastePercent</code> 默认是 5，意味着只有 5% 的堆是“浪费”的。如果浪费的堆的百分比大于 G1HeapWastePercent，则运行 Full GC。</p>
<p><strong>注：</strong><br>收集区域： 整个堆内存<br>使用算法： 标记复制法<br>搜集方式： 多线程</p>
<h2 id="4-ZGC"><a href="#4-ZGC" class="headerlink" title="4.ZGC"></a>4.ZGC</h2><p>参考一开始的博客链接。</p>
<h1 id="四、对象分配规则"><a href="#四、对象分配规则" class="headerlink" title="四、对象分配规则"></a>四、对象分配规则</h1><p>根据分代收集算法，将堆内存分为新生代和老年代，新生代分为eden区，Survivor from和Survivor to区，老年代为old区。</p>
<p><strong>1.对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。</strong> </p>
<p>Minor GC 后，又创建的新对象会继续往 Eden 区分配。于是，随着新对象的创建，Eden 的剩余内存空间就会越来越少，又会触发 Minor GC，此时，JVM 会对 Eden 区和 From Survivor 区中的对象进行存活判断，对于存活的对象，会转移到 To Survivor 区。下一次 Minor GC，存活的对象又会从 To 到 From，这样就总有一个 Survivor 区是空的，而另外一个是无碎片的。</p>
<p><strong>2.大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。</strong></p>
<p>这样做的目的是避免在 Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 </p>
<p>可以通过 <code>-XX:PretenureSizeThreshold</code> 参数设置直接分配大对象到老年代的阈值。如果对象的大小超过这个阈值，它将直接在老年代中分配。例如，如果想将阈值设置为 1MB（1024KB），可以这样设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:PretenureSizeThreshold=1048576</span><br></pre></td></tr></table></figure>

<p><strong>3.长期存活的对象进入老年代。</strong></p>
<p>虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次 Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC（从一个 Survivor 区转移到另外一个 Survivor 区时）那么对象的年龄加1，直到达到阀值对象进入老年区。 </p>
<p><strong>4.动态判断对象的年龄。</strong></p>
<p>如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的 一半，年龄大于或等于该年龄的对象可以直接进入老年代。 </p>
<p><strong>5.空间分配担保。</strong></p>
<p>整个流程如下：</p>
<ul>
<li>Minor GC 之前，JVM 会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果大于，则发起 Minor GC。</li>
<li>如果小于，则看 HandlePromotionFailure 有没有设置，如果没有设置，就发起 Full GC。</li>
<li>如果设置了 HandlePromotionFailure，则看老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果小于，就发起 Full GC。</li>
<li>如果大于，发起 Minor GC。Minor GC 后，看 Survivor 空间是否足够存放存活对象，如果不够，就放入老年代，如果够放，就直接存放 Survivor 空间。如果老年代都不够放存活对象，担保失败（Handle Promotion Failure），发起 Full GC。</li>
</ul>
<p><img src="whereis-the-object-8.png"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>判断是否需要进行垃圾回收的算法有<strong>引用标记算法和可达性分析算法</strong>，前者使用Java对象头的Reference Count属性，后者依靠引用关系，解决前者不能解决循环依赖的问题。</p>
<p>垃圾收集算法有标记清除算法（存在内存碎片化问题）、复制算法（内存分割出去不划算）、标记整理算法（需要改动引用对象地址，效率低）、分代收集算法（前三种的组合拳），其中学习了stop-to-world是什么，新生代和老年代是什么，复习了Java对象头和永久代，JVM运行时数据区。</p>
<p>垃圾收集器介绍了CMS、ParNew、G1等，其中，CMS和ParNew作为分区收集器，共同打配合清理堆内存。</p>
<p>基于分代收集的算法（组合拳），对象的分配规则由eden-&gt;Survivor-&gt;old区主键分配，其中根据不同的情况进行minor gc和full gc。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程：二、JMM、happens-before、volatile</title>
    <url>/2024/08/04/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9AJMM/</url>
    <content><![CDATA[<h1 id="一、内存模型（含八股内容）"><a href="#一、内存模型（含八股内容）" class="headerlink" title="一、内存模型（含八股内容）"></a>一、内存模型（含八股内容）</h1><h2 id="1-1-内存模型及并发问题"><a href="#1-1-内存模型及并发问题" class="headerlink" title="1.1 内存模型及并发问题"></a>1.1 内存模型及并发问题</h2><p>Java 内存模型（Java Memory Model，JMM）定义了 Java 程序中的变量、线程如何和主存以及工作内存进行交互的规则。它主要涉及到多线程环境下的共享变量可见性、指令重排等问题，是理解并发编程中的关键概念。</p>
<p>并发编程的线程之间存在两个问题：</p>
<ul>
<li>线程间如何通信？即：线程之间以何种机制来交换信息</li>
<li>线程间如何同步？即：线程以何种机制来控制不同线程间发生的相对顺序</li>
</ul>
<p>有两种并发模型可以解决这两个问题：</p>
<ul>
<li>消息传递并发模型</li>
<li>共享内存并发模型</li>
</ul>
<p>这两种模型之间的区别如下图所示：</p>
<p><img src="jmm-a610752d-ef73-47f2-b02c-6954eb3d62bf.png"></p>
<p>重要的事情说三遍</p>
<p><strong>Java 使用的是共享内存并发模型！！！！</strong></p>
<p><strong>Java 使用的是共享内存并发模型！！！！</strong></p>
<p><strong>Java 使用的是共享内存并发模型！！！！</strong></p>
<h2 id="1-2-须知：Java共享内存并发模型"><a href="#1-2-须知：Java共享内存并发模型" class="headerlink" title="1.2 须知：Java共享内存并发模型"></a>1.2 须知：Java共享内存并发模型</h2><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。 </p>
<p>例如线程 A 与 线程 B 之间如果要通信的话，那么就必须经历下面两个步骤： 1. 线程 A 把本地内存 A 更新过得共享变量刷新到主内存中去。 2. 线程 B 到主内存中去读取线程 A 之前更新过的共享变量，<strong>也就是说，线程A和线程B之间一定要通过主存。</strong></p>
<p><img src="jmm-f02219aa-e762-4df0-ac08-6f4cceb535c2.jpg" alt="共享内存"></p>
<h2 id="1-3-八股：本地内存和主存有什么区别？"><a href="#1-3-八股：本地内存和主存有什么区别？" class="headerlink" title="1.3 八股：本地内存和主存有什么区别？"></a>1.3 八股：本地内存和主存有什么区别？</h2><p>线程之间的共享变量存在于主存中，每个线程都有一个私有的本地内存，存储了该线程的读、写共享变量的副本。本地内存是 Java 内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等（比如cpu的三级缓存）。</p>
<h1 id="二、如何保证内存可见性？"><a href="#二、如何保证内存可见性？" class="headerlink" title="二、如何保证内存可见性？"></a>二、如何保证内存可见性？</h1><p>由于java用的是内存共享并发模型，那么我们就按照这个来说。线程的安全问题包括原子性、可见性、活跃性、有序性，这里就先讨论可见性。</p>
<p>可见性就是指，如果线程A在本地内存中更新了一个变量，那么线程B以及其他线程需要同步修改后的数据。如何同步修改后的数据？此时就是需要JMM，JMM控制主存和本地内存之间的交互，来提供内存可见性保证。</p>
<p>Java 中的 <code>volatile 关键字</code>可以保证多线程操作共享变量的可见性以及禁止指令重排序，<code>synchronized 关键字</code>不仅保证可见性，同时也保证了原子性（互斥性）。</p>
<p>在更底层，JMM 通过内存屏障来实现内存的可见性以及禁止重排序。为了程序员更方便地理解，设计者提出了 happens-before 的概念（下文会细讲），它更加简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则，以及这些规则的具体实现方法。</p>
<h1 id="三、JMM与重排序"><a href="#三、JMM与重排序" class="headerlink" title="三、JMM与重排序"></a>三、JMM与重排序</h1><p>前面提到了，JMM 定义了多线程之间如何互相交互的规则，主要目的是为了解决由于编译器优化、处理器优化和缓存系统等导致的可见性、原子性和有序性。</p>
<p>那我们接下来就来聊聊重排序以及它所带来的顺序问题。</p>
<h3 id="3-1-为什么指令重排可以提高性能？"><a href="#3-1-为什么指令重排可以提高性能？" class="headerlink" title="3.1 为什么指令重排可以提高性能？"></a>3.1 为什么指令重排可以提高性能？</h3><p>大家都知道，计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p>
<p>那可能有小伙伴就要问：<strong>为什么指令重排序可以提高性能？</strong></p>
<p>简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，<strong>流水线技术</strong>产生了，它的原理是指令 1 还没有执行完，就可以开始执行指令 2，而不用等到指令 1 执行结束后再执行指令 2，这样就大大提高了效率。</p>
<p>但是，流水线技术最害怕<strong>中断</strong>，恢复中断的代价是比较大的，所以我们要想尽办法不让流水线中断。指令重排就是减少中断的一种技术。</p>
<p>我们分析一下下面这段代码的执行情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = b + c;</span><br><span class="line">d = e - f ;</span><br></pre></td></tr></table></figure>

<p>先加载 b、c（<strong>注意，有可能先加载 b，也有可能先加载 c</strong>），但是在执行 <code>add(b,c)</code> 的时候，需要等待 b、c 装载结束才能继续执行，也就是需要增加停顿，那么后面的指令（加载 e 和 f）也会有停顿，这就降低了计算机的执行效率。</p>
<p>为了减少停顿，我们可以在加载完 b 和 c 后把 e 和 f 也加载了，然后再去执行 <code>add(b,c)</code>，这样做对程序（串行）是没有影响的，但却减少了停顿。</p>
<p>换句话说，既然 <code>add(b,c)</code> 需要停顿，那还不如去做一些有意义的事情（加载 e 和 f）。</p>
<p>综上所述，<strong>指令重排对于提高 CPU 性能十分必要，但也带来了乱序的问题。</strong></p>
<h3 id="3-2-重排序有哪几种？"><a href="#3-2-重排序有哪几种？" class="headerlink" title="3.2 重排序有哪几种？"></a>3.2 重排序有哪几种？</h3><p>指令重排一般分为以下三种：</p>
<ul>
<li><strong>编译器优化重排</strong>，编译器在<strong>不改变单线程程序语义</strong>的前提下，重新安排语句的执行顺序。</li>
<li><strong>指令并行重排</strong>，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果<strong>不存在数据依赖性</strong>(即后一个执行的语句无需依赖前面执行的语句的结果)，处理器可以改变语句对应的机器指令的执行顺序。</li>
<li><strong>内存系统重排</strong>，由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</li>
</ul>
<p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p>
<h1 id="四、happens-before-关系模型"><a href="#四、happens-before-关系模型" class="headerlink" title="四、happens-before 关系模型"></a>四、happens-before 关系模型</h1><h2 id="4-1-八股：什么是happens-before-关系模型？"><a href="#4-1-八股：什么是happens-before-关系模型？" class="headerlink" title="4.1 八股：什么是happens-before 关系模型？"></a>4.1 八股：什么是happens-before 关系模型？</h2><p>happens-before 关系的定义如下：</p>
<ol>
<li><p><strong>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</strong></p>
</li>
<li><p><strong>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</strong></p>
</li>
</ol>
<p>总之，<strong>如果操作 A happens-before 操作 B，那么操作 A 在内存上所做的操作对操作 B 都是可见的，不管它们在不在一个线程。</strong></p>
<h2 id="4-2-了解：happens-before-关系有哪些？"><a href="#4-2-了解：happens-before-关系有哪些？" class="headerlink" title="4.2 了解：happens-before 关系有哪些？"></a>4.2 了解：happens-before 关系有哪些？</h2><p>   在 Java 中，有以下天然的 happens-before 关系：</p>
<ul>
<li>程序顺序规则：一个线程中的每一个操作，happens-before 于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li>
<li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li>
<li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li>
<li>start 规则：如果线程 A 执行操作 <code>ThreadB.start()</code>启动线程 B，那么 A 线程的 <code>ThreadB.start()</code>操作 happens-before 于线程 B 中的任意操作。</li>
<li>join 规则：如果线程 A 执行操作 <code>ThreadB.join()</code>并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 <code>ThreadB.join()</code>操作成功返回。</li>
</ul>
<p>   举例：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// A操作</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// B操作</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b;<span class="comment">// C 操作</span></span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure>

<p>   根据以上介绍的 happens-before 规则，假如只有一个线程，那么不难得出：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>&gt; A happens-before B</span><br><span class="line"><span class="number">2</span>&gt; B happens-before C</span><br><span class="line"><span class="number">3</span>&gt; A happens-before C</span><br></pre></td></tr></table></figure>

<p>   注意，真正在执行指令的时候，其实 JVM 有可能对操作 A &amp; B 进行重排序，因为无论先执行 A 还是 B，他们都对对方是可见的，并且不影响执行结果。</p>
<p>   如果这里发生了重排序，这在视觉上违背了 happens-before 原则，但是 JMM 是允许这样的重排序的。</p>
<p>   所以，我们只关心 happens-before 规则，不用关心 JVM 到底是怎样执行的。只要确定操作 A happens-before 操作 B 就行了。</p>
<p>   重排序有两类，JMM 对这两类重排序有不同的策略：</p>
<ul>
<li>会改变程序执行结果的重排序，比如 A -&gt; C，JMM 要求编译器和处理器都禁止这种重排序。</li>
<li>不会改变程序执行结果的重排序，比如 A -&gt; B，JMM 对编译器和处理器不做要求，允许这种重排序。</li>
</ul>
<h1 id="五、volatile关键字"><a href="#五、volatile关键字" class="headerlink" title="五、volatile关键字"></a>五、volatile关键字</h1><h2 id="5-1-八股：volatile关键字的作用"><a href="#5-1-八股：volatile关键字的作用" class="headerlink" title="5.1 八股：volatile关键字的作用"></a>5.1 八股：volatile关键字的作用</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： </p>
<ol>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 </li>
<li>禁止进行指令重排序。 </li>
<li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。 </li>
<li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li>
<li>volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量的修改 可见性和原子性。</li>
<li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。 </li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li>
</ol>
<h2 id="5-2-八股：volatile禁止指令重排序（volatile和-happens-before）"><a href="#5-2-八股：volatile禁止指令重排序（volatile和-happens-before）" class="headerlink" title="5.2 八股：volatile禁止指令重排序（volatile和 happens-before）"></a>5.2 八股：volatile禁止指令重排序（volatile和 happens-before）</h2><p>在讲 JMM的时候，我们提到了指令重排，相信大家都还有印象，我们来回顾一下重排序需要遵守的规则：</p>
<ul>
<li>重排序不会对存在数据依赖关系的操作进行重排序。比如：<code>a=1;b=a;</code> 这个指令序列，因为第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</li>
<li>重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变。比如：<code>a=1;b=2;c=a+b</code> 这三个操作，第一步 (a&#x3D;1) 和第二步 (b&#x3D;2) 由于不存在数据依赖关系，所以可能会发生重排序，但是 c&#x3D;a+b 这个操作是不会被重排序的，因为需要保证最终的结果一定是 c&#x3D;a+b&#x3D;3。</li>
</ul>
<p>使用 volatile 关键字修饰共享变量可以禁止这种重排序。怎么做到的呢？</p>
<p>当我们使用 volatile 关键字来修饰一个变量时，Java 内存模型会插入内存屏障（一个处理器指令，可以对 CPU 或编译器重排序做出约束）来确保以下两点：</p>
<ul>
<li>写屏障（Write Barrier）：当一个 volatile 变量被写入时，写屏障确保在该屏障之前的所有变量的写入操作都提交到主内存。</li>
<li>读屏障（Read Barrier）：当读取一个 volatile 变量时，读屏障确保在该屏障之后的所有读操作都从主内存中读取。</li>
</ul>
<p>换句话说：</p>
<ul>
<li>当程序执行到 volatile 变量的读操作或者写操作时，在其前面操作的更改肯定已经全部进行，且结果对后面的操作可见；在其后面的操作肯定还没有进行；</li>
<li>在进行指令优化时，不能将 volatile 变量的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。</li>
</ul>
<h2 id="5-3-volatile不保证原子性"><a href="#5-3-volatile不保证原子性" class="headerlink" title="5.3 volatile不保证原子性"></a>5.3 volatile不保证原子性</h2><p>比如i++操作：</p>
<p>在Java（以及许多其他编程语言中），i++ 是一个后缀递增操作符，它对变量 i 执行一个复合操作，该操作可以分解为以下三个步骤（尽管在实际执行时这些步骤可能会被优化或合并，但从概念上讲）： </p>
<ol>
<li>读取（Load）：首先，从内存中读取变量 i 的当前值。这个值被加载到CPU的寄存器中，供后续操作使用。 </li>
<li>修改（Increment）：然后，将寄存器中的值增加1。这个步骤是在CPU内部完成的，不涉及内存的读写操作（除了可能涉及的缓存一致性协议）。 </li>
<li>写回（Store）：最后，将修改后的值写回到内存中变量 i 的位置。这一步确保了内存中 i 的值被更新为新的值。</li>
</ol>
<p> 需要注意的是，在多线程环境中，这三个步骤可能会被其他线程的类似操作打断，导致数据不一致的问题。特别是，如果两个线程几乎同时执行对同一个变量的 i++ 操作，它们可能会： 第一个线程读取了 i 的原始值（比如10）。 第二个线程也读取了 i 的相同原始值（因为第一个线程还没有写回新值）。 第一个线程增加1并将结果（11）写回内存。 第二个线程也增加1（基于它读取的旧值10），并将结果（也是11）写回内存，覆盖了第一个线程的结果。 </p>
<p>这就是为什么在多线程环境中，即使使用了 volatile 关键字来确保变量的可见性，i++ 这样的复合操作也仍然需要额外的同步机制来确保原子性。volatile 保证了每次读取 i 时都会从主内存中获取最新值，但它并不保证 i++ 操作的原子性。</p>
<p><strong>解决方式：</strong>使用<code>synchronized关键字（重入锁）</code>或者<code>lock接口的实现类ReentrantLock（重入锁）</code>进行加锁，总所周知学线程编程的时候都会学习的两个锁，可以保证原子性</p>
<h1 id="六、synchronized关键字"><a href="#六、synchronized关键字" class="headerlink" title="六、synchronized关键字"></a>六、synchronized关键字</h1><p>由于我写累了就不写基本用法了，就是修饰静态代码块，同步方法（实例方法），静态方法（类方法）三种用途，不懂的可以自己去查资料</p>
<p>重点放在关键字保证的线程安全上，<strong>synchronized关键字是允许指令重排的，也就是说，满足了 happens-before模型的结果一致原则的指令重排。</strong></p>
<p>另外，<strong>synchronized属于重入锁，这部分放到多线程和锁的内容去介绍。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程：三、多线程锁、java锁的实现</title>
    <url>/2024/08/05/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E4%B8%89%E3%80%81%E9%94%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大部分内容由网上搜索，有直接复制粘贴的内容，本篇博客整理我查找的内容，且加入我个人的理解和个人需要了解的知识进行搜索得到的内容，有错误请在评论区留言</p>
<h1 id="一、首先介绍一下锁"><a href="#一、首先介绍一下锁" class="headerlink" title="一、首先介绍一下锁"></a>一、首先介绍一下锁</h1><p>操作系统层面的锁： 操作系统通过锁机制来管理进程（或线程）对共享资源的访问，以防止数据竞争和保证数据一致性。 常见的操作系统锁包括互斥锁（Mutex）、读写锁（Read-Write Lock）、自旋锁（Spinlock）等，它们用于控制对临界区（Critical Section）的访问。 </p>
<blockquote>
<p>这里介绍一下“临界区”的概念。所谓“临界区”，指的是某一块代码区域，它同一时刻只能由一个线程执行。</p>
</blockquote>
<p>Java多线程的锁： Java中的锁是Java编程语言中用于实现多线程同步和互斥的机制。 Java提供了多种类型的锁，如synchronized关键字、ReentrantLock类、ReadWriteLock等，用于控制多线程对共享资源的并发访问。</p>
<p>首先需要明确的一点是：<strong>Java 多线程的锁都是基于对象的</strong>，Java 中的每一个对象都可以作为一个锁。在<a href="https://rengoku.top/2024/08/04/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9AJMM/">上一节</a>最后一点讲synchronized的时候有提到，synchronized可以修饰静态方法和实例方法，<strong>synchronized在这里其实就是加上了一个类锁。</strong></p>
<p>Class 对象是一种特殊的 Java 对象，代表了程序中的类和接口。Java 中的每个类型（包括类、接口、数组以及基础类型）在 JVM 中都有一个唯一的 Class 对象与之对应。这个 Class 对象被创建的时机是在 JVM 加载类时，由 JVM 自动完成。</p>
<p>Class 对象中包含了与类相关的很多信息，如类的名称、类的父类、类实现的接口、类的构造方法、类的方法、类的字段等等。这些信息通常被称为元数据（metadata）。</p>
<p>可以通过 Class 对象来获取类的元数据，甚至动态地创建类的实例、调用类的方法、访问类的字段等。这就是Java 的反射（Reflection）机制</p>
<p>所以我们常说的类锁，其实就是 Class 对象的锁。</p>
<p><strong>多线程锁的类型</strong></p>
<p>Java中常用的多线程锁类型有以下几种:</p>
<ol>
<li>synchronized关键字</li>
<li>ReentrantLock类</li>
<li>ReadWriteLock接口</li>
<li>StampedLock类</li>
<li>Atomic类</li>
</ol>
<p>这几个我会在第三大节里面介绍，首先先看基本锁的类型</p>
<h1 id="二、锁的分类"><a href="#二、锁的分类" class="headerlink" title="二、锁的分类"></a>二、锁的分类</h1><p>直接上一个图</p>
<p><img src="other-bukfsdjavassmtjstd-b2ded433-defd-4535-b767-fd2e5be0b5b9.png"></p>
<h1 id="1、乐观锁-VS-悲观锁"><a href="#1、乐观锁-VS-悲观锁" class="headerlink" title="1、乐观锁 VS 悲观锁"></a>1、乐观锁 VS 悲观锁</h1><h3 id="八股：乐观锁-VS-悲观锁"><a href="#八股：乐观锁-VS-悲观锁" class="headerlink" title="八股：乐观锁 VS 悲观锁"></a>八股：乐观锁 VS 悲观锁</h3><p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。</p>
<p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。<strong>Java 中，synchronized 关键字 是最典型的悲观锁。</strong></p>
<p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会加锁，只是在更新数据的时候会去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p>
<p>乐观锁在 Java 中是通过无锁编程来实现的，最常采用的是<strong>CAS 算法</strong>，<strong>Java 原子类</strong>的递增操作就通过 CAS 自旋实现的。</p>
<p><img src="other-bukfsdjavassmtjstd-840de182-83e2-4639-868a-bd5cc984575f.png"></p>
<p>根据上面的概念描述我们可以发现：</p>
<ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<h3 id="八股：CAS算法"><a href="#八股：CAS算法" class="headerlink" title="八股：CAS算法"></a>八股：CAS算法</h3><p>在2.1中提到，<strong>乐观锁采用的是无锁编程，底层有采用CAS算法，</strong>那么什么是CAS算法？</p>
<p>CAS（Compare-and-Swap）是一种乐观锁的实现方式，全称为“比较并交换”，是一种无锁的原子操作。</p>
<p>在并发编程中，我们都知道<code>i++</code>操作是非线程安全的，这是因为 <code>i++</code>操作不是原子操作，这个在volatile关键字里讲过，可以去翻一下</p>
<p>在 CAS 中，有这样三个值：</p>
<ul>
<li>V：要更新的变量(var)</li>
<li>E：预期值(expected)</li>
<li>N：新值(new)</li>
</ul>
<p>比较并交换的过程如下：</p>
<p>判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，于是当前线程放弃更新，什么都不做。</p>
<p>这里的<strong>预期值 E 本质上指的是“旧值”</strong>。</p>
<p>我们以一个简单的例子来解释这个过程：</p>
<ol>
<li>如果有一个多个线程共享的变量<code>i</code>原本等于 5，我现在在线程 A 中，想把它设置为新的值 6;</li>
<li>我们使用 CAS 来做这个事情；</li>
<li>首先我们用 i 去与 5 对比，发现它等于 5，说明没有被其它线程改过，那我就把它设置为新的值 6，此次 CAS 成功，<code>i</code>的值被设置成了 6；</li>
<li>如果不等于 5，说明<code>i</code>被其它线程改过了（比如现在<code>i</code>的值为 2），那么我就什么也不做，此次 CAS 失败，<code>i</code>的值仍然为 2。</li>
</ol>
<p>在这个例子中，<code>i</code>就是 V，5 就是 E，6 就是 N。</p>
<p>那有没有可能我在判断了<code>i</code>为 5 之后，正准备更新它的新值的时候，被其它线程更改了<code>i</code>的值呢？</p>
<p>不会的。因为 CAS 是一种原子操作，它是一种系统原语，是一条 CPU 的原子指令，从 CPU 层面已经保证它的原子性。</p>
<p><strong>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</strong></p>
<h3 id="了解：CAS算法如何实现原子操作？"><a href="#了解：CAS算法如何实现原子操作？" class="headerlink" title="了解：CAS算法如何实现原子操作？"></a>了解：CAS算法如何实现原子操作？</h3><h4 id="（1）实现原理"><a href="#（1）实现原理" class="headerlink" title="（1）实现原理"></a>（1）实现原理</h4><p>java底层实现CAS操作是使用native关键字调用c++的接口</p>
<p>在 Java 中，有一个<code>Unsafe</code>类（下文介绍什么是unsafe类），它在<code>sun.misc</code>包中。它里面都是一些<code>native</code>方法（下文也会介绍什么是native方法），其中就有几个是关于 CAS 的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset,Object expected, Object x)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset,<span class="type">int</span> expected,<span class="type">int</span> x)</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset,<span class="type">long</span> expected,<span class="type">long</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>Unsafe 对 CAS 的实现是通过 C++ 实现的，它的具体实现和操作系统、CPU 都有关系。</p>
<blockquote>
<p>Unsafe 是 Java 中一个非常特殊的类，它为 Java 提供了一种底层、”不安全”的机制来直接访问和操作内存、线程和对象。正如其名字所暗示的，Unsafe 提供了许多不安全的操作，因此它的使用应该非常小心，并限于那些确实需要使用这些底层操作的场景。我们在这里涉及到这个类基本上是需要native方法。</p>
</blockquote>
<blockquote>
<p><code>native</code>方法，简单的说就是由 Java 调用非 Java 代码的接口，被调用的方法是由非 Java 语言实现的，例如它可以由 C 或 C++语言来实现，并编译成 DLL，然后直接供 Java 进行调用。<code>native</code>方法是通过 JNI（<code>Java Native Interface</code>）实现调用的，从 Java 1.1 开始 JNI 标准就是 Java 平台的一部分，它允许 Java 代码和其他语言的代码进行交互。</p>
</blockquote>
<h4 id="（2）实现原子操作"><a href="#（2）实现原子操作" class="headerlink" title="（2）实现原子操作"></a>（2）实现原子操作</h4><p>JDK 提供了一些用于原子操作的类，在<code>java.util.concurrent.atomic</code>包下面。在 JDK 8 中，有以下这些类：</p>
<p>这里就做部分了解，需要深入了解可自行搜相关内容</p>
<p><img src="cas-20230731195315.png"></p>
<h3 id="八股：CAS-的三大问题"><a href="#八股：CAS-的三大问题" class="headerlink" title="八股：CAS 的三大问题"></a>八股：CAS 的三大问题</h3><p>尽管 CAS 提供了一种有效的同步手段，但也存在一些问题，主要有以下三个：ABA 问题、长时间自旋、多个共享变量的原子操作。</p>
<h4 id="（1）ABA-问题"><a href="#（1）ABA-问题" class="headerlink" title="（1）ABA 问题"></a>（1）ABA 问题</h4><p>所谓的 ABA 问题，就是一个值原来是 A，变成了 B，又变回了 A。<strong>而当前线程在CAS操作中错误地认为该变量没有被其他线程修改过，从而可能导致数据不一致或错误。</strong>这个时候使用 CAS 是检查不出变化的，但实际上却被更新了两次。</p>
<p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。从 JDK 1.5 开始，JDK 的 atomic 包里提供了一个类<code>AtomicStampedReference</code>类来解决 ABA 问题。</p>
<p>这个类的<code>compareAndSet</code>方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用 CAS 设置为新的值和标志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V   expectedReference,</span></span><br><span class="line"><span class="params">                              V   newReference,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> expectedStamp,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> newStamp)</span> &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">          casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来看参数：</p>
<ul>
<li>expectedReference：预期引用，也就是你认为原本应该在那个位置的引用。</li>
<li>newReference：新引用，如果预期引用正确，将被设置到该位置的新引用。</li>
<li>expectedStamp：预期标记，这是你认为原本应该在那个位置的标记。</li>
<li>newStamp：新标记，如果预期标记正确，将被设置到该位置的新标记。</li>
</ul>
<p>执行流程：</p>
<p>①、<code>Pair&lt;V&gt; current = pair;</code> 这行代码获取当前的 pair 对象，其中包含了引用和标记。</p>
<p>②、接下来的 return 语句做了几个检查：</p>
<ul>
<li><code>expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp</code>：首先检查当前的引用和标记是否和预期的引用和标记相同。如果二者中有任何一个不同，这个方法就会返回 false。</li>
<li>如果上述检查通过，也就是说当前的引用和标记与预期的相同，那么接下来就会检查新的引用和标记是否也与当前的相同。如果相同，那么实际上没有必要做任何改变，这个方法就会返回 true。</li>
<li>如果新的引用或者标记与当前的不同，那么就会调用 casPair 方法来尝试更新 pair 对象。casPair 方法会尝试用 newReference 和 newStamp 创建的新的 Pair 对象替换当前的 pair 对象。如果替换成功，casPair 方法会返回 true；如果替换失败（也就是说在尝试替换的过程中，pair 对象已经被其他线程改变了），casPair 方法会返回 false。</li>
</ul>
<h4 id="（2）长时间自旋"><a href="#（2）长时间自旋" class="headerlink" title="（2）长时间自旋"></a>（2）长时间自旋</h4><p>CAS 多与自旋结合。如果自旋 CAS 长时间不成功，会占用大量的 CPU 资源（存在一直自旋到最大次数后停止的情况，但是占用很多cpu资源）。</p>
<p>解决思路是让 JVM 支持处理器提供的<strong>pause 指令</strong>（还有其他的，可以再去搜一些内容）。</p>
<p>pause 指令能让自旋失败时 cpu 睡眠一小段时间再继续自旋，从而使得读操作的频率降低很多，为解决内存顺序冲突而导致的 CPU 流水线重排的代价也会小很多。</p>
<h4 id="（3）多个共享变量的原子操作"><a href="#（3）多个共享变量的原子操作" class="headerlink" title="（3）多个共享变量的原子操作"></a>（3）多个共享变量的原子操作</h4><p>当对一个共享变量执行操作时，CAS 能够保证该变量的原子性。但是对于多个共享变量，CAS 就无法保证操作的原子性，这时通常有两种做法：</p>
<ol>
<li>使用<code>AtomicReference</code>类保证对象之间的原子性，把多个变量放到一个对象里面进行 CAS 操作；</li>
<li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li>
</ol>
<h2 id="2、自旋锁-VS-自适应自旋锁"><a href="#2、自旋锁-VS-自适应自旋锁" class="headerlink" title="2、自旋锁 VS 自适应自旋锁"></a>2、自旋锁 VS 自适应自旋锁</h2><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>先了解一下临界资源：</p>
<p><strong>临界资源指的是多个进程&#x2F;线程共同访问的某类资源，如打印机、数据表格或变量等。由于这些资源同时只能被一个进程&#x2F;线程安全地使用，因此在并发编程中需要对它们的访问进行控制，以避免数据不一致或竞态条件的发生。</strong></p>
<p>突发提问，临界区是什么？不记得了看第一节介绍锁的地方吧</p>
<p><strong>自旋锁（Spinlock）</strong>是一种对<strong>临界资源</strong>进行互斥访问的手段，自旋锁的定义和工作原理如下：</p>
<p><strong>定义：</strong></p>
<p>自旋锁是一种锁机制，当一个线程尝试去获取某一把锁的时候，如果这个锁已经被另外一个线程占有了，那么此线程就无法获取这把锁，该线程会等待，间隔一段时间后再次尝试获取。这种采用循环加锁，等待锁释放的机制就称为自旋锁。</p>
<p><strong>工作原理：</strong></p>
<ul>
<li><strong>等待与重试</strong>：当线程发现锁被占用时，不是进入睡眠或阻塞状态，而是采用忙等待（busy waiting）的方式，即不断循环检查锁的状态，直到锁被释放。</li>
<li><strong>原子操作</strong>：在自旋锁的实现中，对锁状态的检查和修改必须是原子操作，以避免竞态条件。</li>
</ul>
<p><strong>自旋锁通过等待和不断重试的操作，避免了线程的cpu来回切换，减少开销。</strong>仔细一想，如果锁里面的代码一下子就执行完成，甚至比切换线程，切换CPU的状态还要快，不使用自旋锁是不是有点得不偿失了呢？</p>
<p><img src="other-bukfsdjavassmtjstd-be0964a8-856a-45c9-ab75-ce9505c2e237.png"></p>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是 10 次，可以使用<code>-XX:PreBlockSpin</code> 来更改）没有成功获得锁，就应当挂起线程。</p>
<p><strong>自旋锁的实现原理同样也是 CAS</strong>，AtomicInteger 中调用 unsafe 进行自增操作的源码中的 do-while 循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<p><img src="other-bukfsdjavassmtjstd-0756521c-becf-4657-ab42-1973d74e9c73.png"></p>
<h4 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h4><p><strong>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</strong>如果在同一个锁对象上，自旋刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功的，进而它将允许自旋等待更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h2 id="3、无锁、偏向锁、轻量级锁、重量级锁"><a href="#3、无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="3、无锁、偏向锁、轻量级锁、重量级锁"></a>3、无锁、偏向锁、轻量级锁、重量级锁</h2><p>这四种锁是专门针对 synchronized 的，我们在第三大节：JUC包下的锁中去介绍。</p>
<h2 id="4、可重入锁-VS-不可重入锁"><a href="#4、可重入锁-VS-不可重入锁" class="headerlink" title="4、可重入锁 VS 不可重入锁"></a>4、可重入锁 VS 不可重入锁</h2><p>可重入锁又名递归锁，是指同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提：锁的是同一个对象或者 class），不会因为之前已经获取过还没释放而阻塞。Java 中<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁，可重入锁的一个优点就是可以一定程度避免死锁。</p>
<p><strong>为什么可重入锁就可以在嵌套调用时自动获得锁呢？</strong></p>
<h3 id="（1）实现机制"><a href="#（1）实现机制" class="headerlink" title="（1）实现机制"></a>（1）实现机制</h3><p>可重入锁的实现通常依赖于以下几个关键点：</p>
<ol>
<li>锁计数器（Lock Counter）<ul>
<li>每个锁对象都维护一个计数器，用于记录该锁被当前线程持有的次数。</li>
<li>当线程首次获取锁时，计数器被初始化为1。</li>
<li>如果线程在持有锁的情况下再次尝试获取同一个锁，计数器将递增。</li>
</ul>
</li>
<li>锁的持有者（Lock Owner）<ul>
<li>锁对象还记录着当前持有该锁的线程。</li>
<li>只有锁的当前持有者线程才能增加锁的计数器（即重复获取锁）。</li>
</ul>
</li>
<li>锁释放（Lock Release）<ul>
<li>当线程退出被锁保护的代码区域时，它会释放锁。</li>
<li>释放锁时，锁的计数器会递减。</li>
<li>如果计数器减至0，则表示当前线程已经完全释放了锁，其他线程可以尝试获取该锁。</li>
</ul>
</li>
</ol>
<h3 id="（2）嵌套调用的自动加锁"><a href="#（2）嵌套调用的自动加锁" class="headerlink" title="（2）嵌套调用的自动加锁"></a>（2）嵌套调用的自动加锁</h3><p>之前我们说过 ReentrantLock 和 synchronized 都是重入锁，那么我们通过重入锁 ReentrantLock 以及非可重入锁 NonReentrantLock 的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p>
<p>首先<code>ReentrantLock</code>和<code> NonReentrantLock</code> 都继承了父类<code>AQS</code>（第三大节），其父类 AQS 中维护了一个同步状态 status 来计数重入次数，status 初始值为 0。</p>
<p>当线程在持有可重入锁的情况下进入嵌套调用（即一个被锁保护的方法或代码块内部调用了另一个被相同锁保护的方法或代码块）时，由于当前线程已经是锁的持有者，因此它可以自动增加锁的计数器，而无需等待锁的释放。这样，线程就可以无缝地进入内层被锁保护的区域，而不会导致死锁或阻塞。</p>
<p>非可重入锁则是在确定当前线程是持有锁的线程之后，直接将 status 置为 0，将锁释放。</p>
<p><img src="other-bukfsdjavassmtjstd-d6e12a34-c889-45e1-83bf-a4d7e36eedde.png"></p>
<h2 id="5、公平锁和非公平锁"><a href="#5、公平锁和非公平锁" class="headerlink" title="5、公平锁和非公平锁"></a>5、公平锁和非公平锁</h2><p>这里的“公平”，其实通俗意义来说就是“先来后到”，也就是 FIFO。如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。反之，那就是不公平的。</p>
<p>一般情况下，<strong>非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况</strong>。所以要根据实际的需求来选择非公平锁和公平锁。</p>
<p><code>ReentrantLock</code> 支持非公平锁和公平锁两种。</p>
<h2 id="6、读写锁和排它锁"><a href="#6、读写锁和排它锁" class="headerlink" title="6、读写锁和排它锁"></a>6、读写锁和排它锁</h2><p> <code>synchronized</code>和<code>ReentrantLock</code>，其实都是“排它锁”。也就是说，这些锁在同一时刻只允许一个线程进行访问。</p>
<p>而读写锁可以在同一时刻允许多个读线程访问。Java 提供了 <code>ReentrantReadWriteLock</code>类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。</p>
<h3 id="（1）介绍一下ReentrantReadWriteLock："><a href="#（1）介绍一下ReentrantReadWriteLock：" class="headerlink" title="（1）介绍一下ReentrantReadWriteLock："></a>（1）介绍一下ReentrantReadWriteLock：</h3><p><strong>ReentrantReadWriteLock</strong>：是Java中的一个读写锁实现，它允许多个线程同时读取共享资源（读读可以并发），但在写入时只允许一个线程独占（读写、写读、写写互斥）。这个锁支持重入，即同一个线程可以多次获取相同类型的锁。它提高了读操作的并发性，同时保证了写操作的独占性。</p>
<p><strong>我相信没学过ReentrantReadWriteLock的人肯定认为和ReentrantLock有什么关系。</strong></p>
<p>实际上什么关系都没有，ReentrantReadWriteLock和ReentrantLock之间并没有继承关系。它们各自独立实现，服务于不同的锁需求。ReentrantReadWriteLock实现了<code>ReadWriteLock</code>接口。这个接口提供了两个锁对象：读锁（ReadLock）和写锁（WriteLock），分别通过<code>readLock()</code>和<code>writeLock()</code>方法获取。</p>
<p>好了到这里，又有人想，<code>ReentrantReadWriteLock</code>实现了<code>ReadWriteLock</code>接口，而<code>ReentrantLock</code>实现了<code>Lock</code>接口，那么<code>ReadWriteLock</code>接口和<code>Lock</code>接口是不是继承关系？<strong>实际上也不是，都是JUC包下独立的接口。</strong></p>
<h3 id="（2）回归正题："><a href="#（2）回归正题：" class="headerlink" title="（2）回归正题："></a><strong>（2）回归正题：</strong></h3><p><strong>排它锁也叫独享锁</strong>，如果线程 T 对数据 A 加上排它锁后，则其他线程不能再对 A 加任何类型的锁。获得排它锁的线程既能读数据又能修改数据。</p>
<p>与之对应的，就是共享锁，指该锁可被多个线程所持有。如果线程 T 对数据 A 加上共享锁后，则其他线程只能对 A 再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<p>独享锁与共享锁也是通过<code>AQS</code>（第三大节介绍）来实现的，通过实现不同的方法，来实现独享或者共享。</p>
<p>下图为 <code>ReentrantReadWriteLock</code> 的部分源码：</p>
<p><img src="other-bukfsdjavassmtjstd-baa93e76-ac90-4955-8955-50dabc6efbdd.png"></p>
<p>我们看到ReentrantReadWriteLock有两把锁：ReadLock 和 WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现 ReadLock 和 WriteLock 是靠内部类 Sync 实现的锁。Sync 是 AQS（第三大节介绍） 的一个子类。</p>
<p>在 ReentrantReadWriteLock 里面，读锁和写锁的锁主体都是 Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以 ReentrantReadWriteLock 的并发性相比一般的互斥锁有了很大提升。</p>
<p><strong>那读锁和写锁的具体加锁方式有什么区别呢？</strong></p>
<p>AQS中的存储status字段，该字段用来描述有多少线程持有锁。</p>
<p>在独享锁中，这个值通常是 0 或者 1（如果是重入锁的话 state 值就是重入的次数），在共享锁中 state 就是持有锁的数量。但是ReentrantReadWriteLock 中有读、写两把锁，所以需要在一个整型变量 state 上分别描述读锁和写锁的数量（或者也可以叫状态）。</p>
<p>关于深入去探究status字段的切割等底层原理就不写了，可以自行参考，我相信你准备面试也看不完这个</p>
<h1 id="三、JUC包下的锁"><a href="#三、JUC包下的锁" class="headerlink" title="三、JUC包下的锁"></a>三、JUC包下的锁</h1><h2 id="1、抽象类AQS-AQLS-AOS"><a href="#1、抽象类AQS-AQLS-AOS" class="headerlink" title="1、抽象类AQS&#x2F;AQLS&#x2F;AOS"></a>1、抽象类AQS&#x2F;AQLS&#x2F;AOS</h2><h3 id="什么是AQS？"><a href="#什么是AQS？" class="headerlink" title="什么是AQS？"></a>什么是AQS？</h3><p>重要的事情说三遍</p>
<p><strong>AQS的全称为（AbstractQueuedSynchronizer）抽象的队列式的同步器</strong>，是并发编程中实现同步器的一个框架，用来存储<strong>同步状态（State）和线程队列（CLH队列的变体）</strong>。</p>
<p><strong>AQS的全称为（AbstractQueuedSynchronizer）抽象的队列式的同步器</strong>，是并发编程中实现同步器的一个框架，用来存储<strong>同步状态（State）和线程队列（CLH队列的变体）</strong>。</p>
<p><strong>AQS的全称为（AbstractQueuedSynchronizer）抽象的队列式的同步器</strong>，是并发编程中实现同步器的一个框架，用来存储<strong>同步状态（State）和线程队列（CLH队列的变体）</strong>。</p>
<p>我们需要特别记住<strong>同步状态（State）和线程队列（CLH队列的变体）。</strong></p>
<p>字面意思理解：</p>
<ol>
<li><p>是一个抽象类，也就是它定义了一些基础功能，会有很多子类去扩展他的功能。</p>
</li>
<li><p>是一个队列式的，也就是会用来协调多个线程的。</p>
</li>
<li><p>是一个同步器，那么是用来给多个线程同步某个数据或者某个状态的。</p>
</li>
</ol>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的同步器，比如 <strong>ReentrantLock、ReentrantReadWriteLock</strong>等等，都是基于 AQS 的。</p>
<p>AQS 里面的“资源”是用一个<code>int</code>类型的数据来表示的，有时候业务需求的资源数超出了<code>int</code>的范围，所以在 JDK 1.6 中，多了一个<strong>AQLS</strong>（AbstractQueuedLongSynchronizer）。它的代码跟 AQS 几乎一样，只是把资源的类型变成了<code>long</code>类型。AQS 和 AQLS 都继承了一个类叫<strong>AOS</strong>（AbstractOwnableSynchronizer）。这个类也是在 JDK 1.6 中出现的。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构有两个，同步状态status和节点node</p>
<h4 id="同步状态status"><a href="#同步状态status" class="headerlink" title="同步状态status"></a>同步状态status</h4><p>AQS 内部使用了一个volatile的变量 state 来作为资源的标识。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The synchronization state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br></pre></td></tr></table></figure>

<p>同时定义了几个获取和改变 state 的 protected 方法，子类可以覆盖这些方法来实现自己的逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getState()</span><br><span class="line">setState()</span><br><span class="line">compareAndSetState()</span><br></pre></td></tr></table></figure>

<p>这三种操作均是原子操作，其中 compareAndSetState 的实现依赖于 Unsafe类 的 <code>compareAndSwapInt()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步状态值</span></span><br><span class="line"><span class="comment"> * 使用volatile修饰，保证多线程修改的可见性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取同步状态值</span></span><br><span class="line"><span class="comment"> * 使用final修饰，子类不能覆盖，只能调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改同步状态值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CAS修改state值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h4><p>AQS 内部使用了一个先进先出（FIFO）的双端队列，并使用了两个引用 head 和 tail 用于标识队列的头部和尾部。</p>
<p>但它并不直接储存线程，而是储存拥有线程的 Node 节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">/**共享模式*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">/**独占模式*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**标记线程由于中断或超时，需要被取消，即踢出队列*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**线程需要被唤醒*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**线程正在等待一个条件*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**传播 当前节点执行释放release操作后，需要通知到其他线程*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// waitStatus只取上面CANCELLED、SIGNAL、CONDITION、PROPAGATE四种取值之一</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列元素需要关联一个线程对象</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示下一个waitStatus值为CONDITION的节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否当前结点是处于共享模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回前一个节点，如果没有前一个节点，则抛出空指针异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="comment">// 获取前一个节点的指针</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="comment">// 如果前一个节点不存在</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则返回</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化头节点使用</span></span><br><span class="line">    Node() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  当有线程需要入队时，那么就创建一个新节点，然后关联该线程对象，由addWaiter()方法调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一个线程需要等待一个条件阻塞了，那么就创建一个新节点，关联线程对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Node 我们可以实现两种队列：</p>
<p>1）一是通过 prev 和 next 实现 CLH（Craig, Landin, and Hagersten）队列（线程同步队列、双向队列）。</p>
<p>在 CLH 锁中，每个等待的线程都会有一个关联的 Node，每个 Node 有一个 prev 和 next 指针。当一个线程尝试获取锁并失败时，它会将自己添加到队列的尾部并自旋，等待前一个节点的线程释放锁。类似下面这样。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CLHLock &#123;</span><br><span class="line">    private volatile Node tail;</span><br><span class="line">    private ThreadLocal&lt;Node&gt; myNode = ThreadLocal.withInitial(Node::new);</span><br><span class="line">    private ThreadLocal&lt;Node&gt; myPred = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void lock() &#123;</span><br><span class="line">        Node node = myNode.get();</span><br><span class="line">        node.locked = true;</span><br><span class="line">        // 把自己放到队尾，并取出前面的节点</span><br><span class="line">        Node pred = tail;</span><br><span class="line">        myPred.set(pred);</span><br><span class="line">        while (pred.locked) &#123;</span><br><span class="line">            // 自旋等待</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void unlock() &#123;</span><br><span class="line">        Node node = myNode.get();</span><br><span class="line">        node.locked = false;</span><br><span class="line">        myNode.set(myPred.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Node &#123;</span><br><span class="line">        private volatile boolean locked;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）二是通过 nextWaiter 实现 <code>Condition</code>上的等待线程队列（单向队列），这个 Condition 主要用在 <code>ReentrantLock</code>类中。</p>
<h2 id="2、接口-Condition-Lock-ReadWriteLock"><a href="#2、接口-Condition-Lock-ReadWriteLock" class="headerlink" title="2、接口 Condition&#x2F;Lock&#x2F;ReadWriteLock"></a>2、接口 Condition&#x2F;Lock&#x2F;ReadWriteLock</h2><p>locks 包下共有三个接口：<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>。</p>
<p>其中，Lock 和 ReadWriteLock 从名字就可以看得出来，分别是锁和读写锁的意思。Lock 接口里面有一些获取锁和释放锁的方法声明，而 ReadWriteLock 里面只有两个方法，分别返回“读锁”和“写锁”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lock 接口中有一个方法可以获得一个Condition：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>之前我们提到过每个对象都可以用<code>Object</code>的<strong>wait&#x2F;notify</strong>方法来实现<strong>等待&#x2F;通知机制</strong>。而 Condition 接口也提供了类似 Object 的方法，可以配合<strong>Lock</strong>来实现等待&#x2F;通知模式。使用Condition监视器的理由可以认为线程等待队列可以是多个，而object只能是一个。</p>
<h2 id="3、ReentrantLock类"><a href="#3、ReentrantLock类" class="headerlink" title="3、ReentrantLock类"></a>3、ReentrantLock类</h2><p>ReentrantLock 是 Lock 接口的默认实现，实现了锁的基本功能。</p>
<p>从名字上看，它是一个“可重入”锁，从源码上看，它内部有一个抽象类<code>Sync</code>，继承了 <code>AQS</code>，自己实现了一个同步器。</p>
<p>同时，ReentrantLock 内部有两个非抽象类<code>NonfairSync</code>和<code>FairSync</code>，它们都继承了 Sync。从名字上可以看得出，分别是”非公平同步器“和”公平同步器“的意思。这意味着 ReentrantLock 可以支持”公平锁“和”非公平锁“。</p>
<p>通过看这两个同步器的源码可以发现，它们的实现都是”独占“的。都调用了 AOS 的<code>setExclusiveOwnerThread</code>方法，所以 ReentrantLock 的锁是”独占“的，也就是说，它的锁都是”排他锁“，不能共享。</p>
<p>在 ReentrantLock 的构造方法里，可以传入一个<code>boolean</code>类型的参数，来指定它是否是一个公平锁，默认情况下是非公平的。这个参数一旦实例化后就不能修改，只能通过<code>isFair()</code>方法来查看。</p>
<p><strong>根据第二大节中的内容，ReentrantLock 是可重入锁、公平锁和非公平锁、排它锁。</strong></p>
<h2 id="4、synchronized关键字"><a href="#4、synchronized关键字" class="headerlink" title="4、synchronized关键字"></a>4、synchronized关键字</h2><p>在Java中，<code>synchronized</code> 关键字用于控制多个线程对共享资源的访问，其底层实现涉及多种锁状态，这些状态根据竞争情况逐步升级，以提高锁的获取与释放效率。我查到的资料说，在jdk1.6之前所有锁都是操作系统提供的重量级锁，后续对synchronized进行优化，直到现在出现了<strong>四个锁状态</strong>，<strong>由低到高</strong>（即锁的要求越来越高）分别是<strong>无锁状态、偏向锁、轻量级锁状态、重量级锁状态。</strong></p>
<h3 id="（1）无锁状态"><a href="#（1）无锁状态" class="headerlink" title="（1）无锁状态"></a>（1）无锁状态</h3><p><strong>定义</strong>：<br>无锁状态是指没有对资源进行锁定，所有的线程都能访问并尝试修改同一个资源，但同时只有一个线程能修改成功。无锁的特点是修改操作会在循环内进行，线程会不断地尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>无需使用锁机制，适用于线程冲突较少的场景。</li>
<li>线程通过自旋（CAS）来尝试访问资源，直至成功。</li>
</ul>
<h3 id="（2）偏向锁状态"><a href="#（2）偏向锁状态" class="headerlink" title="（2）偏向锁状态"></a>（2）偏向锁状态</h3><p><strong>定义</strong>：<br>偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗，即提高性能。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>偏向锁的目标是减少无竞争且只有一个线程使用锁的情况下的性能消耗。</li>
<li>JVM使用CAS操作把线程ID记录到对象的<strong>Mark Word（等下介绍）</strong>当中，并修改标识位，当前线程就拥有了这把锁。</li>
<li>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</li>
</ul>
<h3 id="（3）轻量级锁状态"><a href="#（3）轻量级锁状态" class="headerlink" title="（3）轻量级锁状态"></a>（3）轻量级锁状态</h3><p><strong>定义</strong>：<br>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁。其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>轻量级锁是介于偏向锁和重量级锁之间的锁实现。</li>
<li>通过CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，如果成功，则线程拥有锁。</li>
<li>适用于线程竞争不激烈且同步块执行时间较短的场景。</li>
<li>如果多个线程竞争锁，轻量级锁可能会升级为重量级锁。</li>
</ul>
<h3 id="（4）重量级锁状态"><a href="#（4）重量级锁状态" class="headerlink" title="（4）重量级锁状态"></a>（4）重量级锁状态</h3><p><strong>定义</strong>：<br>重量级锁是指当多个线程竞争同一个锁时，锁的状态会升级为重量级锁。此时，除了锁的拥有者外，其余线程都会处于阻塞状态。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>重量级锁通过对象内部的监视器锁（monitor）实现，依赖于操作系统的Mutex Lock。</li>
<li>线程阻塞和唤醒的开销较大，适用于线程竞争激烈的场景。</li>
<li>当轻量级锁的自旋次数达到一定阈值时，如果仍未获得锁，则会升级为重量级锁。</li>
</ul>
<h3 id="引发问题"><a href="#引发问题" class="headerlink" title="引发问题"></a>引发问题</h3><p>好，现在看到这里大部分的无锁偏、向锁、轻量级锁、重量级锁内容就可以解释清楚了，但是博客写到这里的时候，我就在思考，<strong>synchronized的锁底层并没有使用AQS这样的抽象队列同步器，为什么synchronized可以实现可重入锁，排它锁的功能？</strong></p>
<p>首先我们需要了解，java中的锁存放在哪里，上面的提到的Mark Word是什么？</p>
<h3 id="Java锁的位置、什么是Mark-Word？"><a href="#Java锁的位置、什么是Mark-Word？" class="headerlink" title="Java锁的位置、什么是Mark Word？"></a>Java锁的位置、什么是Mark Word？</h3><p>首先我们来看看一个对象的“锁”是存放在什么地方的。</p>
<p>每个 Java 对象都有一个对象头。如果是非数组类型，则用 2 个字宽来存储对象头，如果是数组，则会用 3 个字宽来存储对象头。在 32 位处理器中，一个字宽是 32 位；在 64 位虚拟机中，一个字宽是 64 位。对象头的内容如下表所示：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>32&#x2F;64bit</td>
<td>Mark Word</td>
<td>存储对象的 hashCode 或锁信息等</td>
</tr>
<tr>
<td>32&#x2F;64bit</td>
<td>Class Metadata Address</td>
<td>存储到对象类型数据的指针</td>
</tr>
<tr>
<td>32&#x2F;64bit</td>
<td>Array length</td>
<td>数组的长度（如果是数组）</td>
</tr>
</tbody></table>
<p>我们主要来看看 Mark Word 的格式：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>29 bit 或 61 bit</th>
<th>1 bit 是否是偏向锁？</th>
<th>2 bit 锁标志位</th>
</tr>
</thead>
<tbody><tr>
<td>无锁</td>
<td></td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程 ID</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>10</td>
</tr>
<tr>
<td>GC 标记</td>
<td></td>
<td>此时这一位不用于标识偏向锁</td>
<td>11</td>
</tr>
</tbody></table>
<p>可以看到，当对象状态为偏向锁时，<code>Mark Word</code>存储的是偏向的线程 ID；当状态为轻量级锁时，<code>Mark Word</code>存储的是指向线程栈中<code>Lock Record</code>的指针；当状态为重量级锁时，<code>Mark Word</code>为指向堆中的 monitor（监视器）对象的指针。</p>
<blockquote>
<p>在 Java 中，监视器（monitor）是一种同步工具，用于保护共享数据，避免多线程并发访问导致数据不一致。在 Java 中，每个对象都有一个内置的监视器。</p>
</blockquote>
<p>监视器包括两个重要部分，一个是锁，一个是等待&#x2F;通知机制，后者是通过 Object 类中的<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>等方法实现的。</p>
<blockquote>
<p>我在下文会提到 Object 类中的<code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code>等方法，可以看下我学习多线程碰到的问题。</p>
</blockquote>
<p>好了，现在可以回答为什么synchronized可以实现可重入锁，排它锁的功能？</p>
<h3 id="可重入锁的实现"><a href="#可重入锁的实现" class="headerlink" title="可重入锁的实现"></a>可重入锁的实现</h3><p>synchronized是可重入锁，这意味着同一个线程可以多次获取同一个对象锁，而不会导致死锁。synchronized实现可重入锁的机制主要依赖于对象头中的锁计数器（或称为锁记录器、锁状态等，具体实现可能因JVM版本和平台而异）：</p>
<blockquote>
<p>根据我查到的资料，锁计数器是一个抽象的概念，在对象头中并非是以一个单独的字段出现，而是在Mark Word中以锁信息的方式存储在内，并且这些信息具体实现可能因JVM版本和平台而异。</p>
</blockquote>
<ol>
<li><strong>锁计数器</strong>：每个对象都有一个与之关联的锁计数器，用于记录当前持有该对象锁的线程重入的次数。</li>
<li><strong>加锁</strong>：当一个线程首次获取锁时，JVM会将锁计数器的值设置为1，并将锁的持有者设置为当前线程。如果同一个线程再次尝试获取该锁，锁计数器会递增，而不是阻塞线程。</li>
<li><strong>解锁</strong>：当线程退出同步代码块时，锁计数器会递减。只有当锁计数器的值减为0时，锁才会被完全释放，此时其他线程才能获取该锁。</li>
</ol>
<p>通过这种机制，synchronized确保了同一个线程可以多次进入同步代码块而不会导致死锁，同时也保证了在锁被完全释放之前，其他线程无法进入该同步代码块。</p>
<h3 id="排他锁的实现"><a href="#排他锁的实现" class="headerlink" title="排他锁的实现"></a>排他锁的实现</h3><p>synchronized实现的锁本质上是排他锁（互斥锁），即在同一时刻，只有一个线程能够持有锁并访问被保护的资源。这是通过JVM的监视器锁（monitor lock）机制实现的：</p>
<ol>
<li><strong>监视器锁</strong>：每个Java对象都可以关联一个监视器锁（monitor）。当线程进入同步代码块时，它会尝试获取与同步代码块对象相关联的监视器锁。</li>
<li><strong>加锁与解锁</strong>：如果监视器锁未被其他线程持有，则当前线程将获取锁并继续执行同步代码块。如果锁已被其他线程持有，则当前线程将被阻塞，直到锁被释放。线程退出同步代码块时，会释放锁，允许其他线程获取锁并执行同步代码块。</li>
</ol>
<h3 id="讲一个我学习多线程时碰到的问题"><a href="#讲一个我学习多线程时碰到的问题" class="headerlink" title="讲一个我学习多线程时碰到的问题"></a>讲一个我学习多线程时碰到的问题</h3><p>这个问题是关于重量级锁的内容。当时我学习Object类的wait方法、notify方法（包括notifyAll，下文可能会省略）这些关于线程的方法的时候，我没有使用synchronized关键字包裹代码，类似的结构像这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;wait之前: &quot;</span>);</span><br><span class="line">        obj.wait(); <span class="comment">//所有可能会引起线程阻塞等到的方法都会拋出InterruptedException受查异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;wait之后: &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我相信大家学习的时候一定学到了<strong>Object类的wait方法、notify方法是为了让线程中出让锁，或是唤醒等待状态下的线程</strong>，但是前提条件都是加了锁，否则哪里来的出让锁和抢夺cpu一说？</p>
<p>我们再把这三个方法说得细致一些：当一个线程调用了一个对象的 <code>wait()</code> 方法时，它会释放该对象的监视器锁，并进入该对象的等待集合中等待。直到其他线程调用了该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法，并且当前线程重新获得了该对象的监视器锁之后，它才会从 <code>wait()</code> 方法返回，并继续执行。这也就是<strong>重量级锁</strong>中我们说到的内容。</p>
<p>由于 <code>notify()</code> 和 <code>notifyAll()</code> 是用来唤醒等待在该对象监视器上的线程的，因此它们必须在持有该对象监视器锁的同步代码块或同步方法中调用。否则，编译器会报错，因为如果没有持有监视器锁，那么线程就没有权限调用这些方法。</p>
<p><img src="Snipaste_2024-08-07_01-22-20.png"></p>
<p>如果还没有获取到锁就尝试解锁，运行后就会抛出非法的锁状态异常。这里的代码抛出该异常正是这个原因：wait方法内部有一步重要的操作：先解锁，再阻塞等待。</p>
<p>因此，在使用wait方法 前，必须先加锁，把wait方法写到synchronized代码块内部。 同时，Java也规定调用notify方法也必须在synchronized代码块中。</p>
<p>并且，加锁的锁对象必须要与调用wait方法的锁对象是同一个。如果加锁对象与调用wait方法的对象不是同一个，也会抛出<code>IllgalMonitorStateException</code> 异常。</p>
<h2 id="5、ReentrantReadWriteLock"><a href="#5、ReentrantReadWriteLock" class="headerlink" title="5、ReentrantReadWriteLock"></a>5、ReentrantReadWriteLock</h2><p><code>ReentrantReadWriteLock</code>是 <code>ReadWriteLock</code> 接口的默认实现。它与 ReentrantLock 的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。</p>
<blockquote>
<p>在这里只介绍内部结构，可重入锁、非公平锁和公平锁看第二大节</p>
</blockquote>
<p>ReentrantReadWriteLock 内部的结构大概是这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"><span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> &#123;</span><br><span class="line">            sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法，初始化两个锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantReadWriteLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>() : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">    readerLock = <span class="keyword">new</span> <span class="title class_">ReadLock</span>(<span class="built_in">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> <span class="title class_">WriteLock</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取读锁和写锁的方法</span></span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.WriteLock <span class="title function_">writeLock</span><span class="params">()</span> &#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"><span class="keyword">public</span> ReentrantReadWriteLock.ReadLock  <span class="title function_">readLock</span><span class="params">()</span>  &#123; <span class="keyword">return</span> readerLock; &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它同样是内部维护了两个同步器。且维护了两个 Lock 的实现类 ReadLock 和 WriteLock。从源码可以发现，这两个内部类用的是外部类的同步器。</p>
<h2 id="6、拓展：StampedLock"><a href="#6、拓展：StampedLock" class="headerlink" title="6、拓展：StampedLock"></a>6、拓展：StampedLock</h2><p>在第一大节的结尾，有提到这个锁，对于普通学习多线程的同学来说我认为见的都很少，但是我看的博客有介绍这个锁的性能，所以我也就简单的说说~</p>
<p><code>StampedLock</code> 类是 Java 8 才发布的，也是 Doug Lea 大神所写，有人称它为锁的性能之王。</p>
<p>StampedLock 没有实现 Lock 接口和 ReadWriteLock 接口，但它实现了“读写锁”的功能，并且性能比 ReentrantReadWriteLock 更高。StampedLock 还把读锁分为了“乐观读锁”和“悲观读锁”两种。</p>
<p>感兴趣可以自行搜索，在这里的博客就只介绍面向八股的比较常见的锁啦</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程：四、详解ConcurrentHashMap构成</title>
    <url>/2024/08/06/java%EF%BC%9A%E8%AF%A6%E8%A7%A3ConcurrentHashMap/</url>
    <content><![CDATA[<h1 id="一、JDK-1-7"><a href="#一、JDK-1-7" class="headerlink" title="一、JDK 1.7"></a>一、JDK 1.7</h1><h2 id="1-1-加锁机制"><a href="#1-1-加锁机制" class="headerlink" title="1.1 加锁机制"></a>1.1 加锁机制</h2><p>ConcurrentHashMap 在 JDK 1.7 中，提供了一种粒度更细的加锁机制，这种机制叫分段锁「Lock Striping」。整个哈希表被分为多个段，每个段都独立锁定。读取操作不需要锁，写入操作仅锁定相关的段。这减小了锁冲突的几率，从而提高了并发性能。</p>
<p>这种机制的优点：在并发环境下将实现更高的吞吐量，而在单线程环境下只损失非常小的性能。</p>
<p>可以这样理解分段锁，就是<strong>将数据分段，对每一段数据分配一把锁</strong>。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>有些方法需要跨段，比如 <code>size()</code>、<code>isEmpty()</code>、<code>containsValue()</code>，它们可能需要锁定整个表而不仅仅是某个段，这需要按顺序锁定所有段，操作完后，再按顺序释放所有段的锁。如下图：</p>
<p><img src="map-20230816155810.png" alt="jdk1.7之前的构成图"></p>
<h2 id="1-2-八股：jdk1-7之前的构成"><a href="#1-2-八股：jdk1-7之前的构成" class="headerlink" title="1.2 八股：jdk1.7之前的构成"></a>1.2 八股：jdk1.7之前的构成</h2><p>敲重点！字体加粗了务必记好。</p>
<p>ConcurrentHashMap 是由 <strong>Segment 数组结构和 HashEntry 数组</strong>构成的。Segment 是一种可重入的锁 <code>ReentrantLock</code>，HashEntry 则用于存储键值对数据。</p>
<p>一个 ConcurrentHashMap 里包含<strong>一个 Segment 数组，数组中都是segment对象</strong>，Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 里包含一个 <strong>HashEntry 数组</strong>，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁（可重入锁）。</p>
<p><strong>HashEntry到底是什么？</strong></p>
<p>我自己搜的时候都在介绍hashentry是数组，但是搜到的都是类似链表的结构，包括在1.1节中的图片看上去都是链表，这是怎么回事？</p>
<p>其实，<code>HashEntry</code>本身是一个<strong>结构体（或内部类，同样segment也是内部类）</strong>，实际上是每个<code>Segment</code>内部的一个数组，用于封装键值对数据，并可能包含指向下一个<code>HashEntry</code>的引用以形成链表结构，用于处理哈希冲突。但由于哈希冲突的存在，这个数组的每个位置可能不仅仅是一个<code>HashEntry</code>对象，而是一个由<code>HashEntry</code>对象组成的链表（或更复杂的结构，如红黑树，但这在JDK 1.7中不是默认的）。</p>
<p><code>ConcurrentHashMap</code>使用链表来存储这些具有相同索引值的键值对。具体来说，每个数组位置（在JDK 1.7中实际上是<code>Segment</code>内部的数组，而在JDK 1.8及以后是<code>Node</code>数组）存储的是链表的头节点。如果发生哈希冲突，新的键值对会被添加到这个链表的末尾。</p>
<p>接下来看看Segment的结构组成：</p>
<p>单一的 Segment 结构如下：</p>
<p><img src="map-20230816160155.png"></p>
<p>像这样的 Segment 对象，在 ConcurrentHashMap 集合中有多少个呢？有 2 的 N 次方个，共同保存在一个名为 segments 的数组当中。 因此整个 ConcurrentHashMap 的结构如下：</p>
<p><img src="map-20230816160223.png"></p>
<p>可以说，ConcurrentHashMap 是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。</p>
<p>Case1：不同 Segment 的并发写入（可以并发执行）</p>
<p><img src="map-20230816160301.png"></p>
<p>Case2：同一 Segment 的一写一读（可以并发执行）</p>
<p><img src="map-20230816160316.png"></p>
<p>Case3：同一 Segment 的并发写入</p>
<p><img src="map-20230816160331.png"></p>
<h1 id="二、JDK1-8往后"><a href="#二、JDK1-8往后" class="headerlink" title="二、JDK1.8往后"></a>二、JDK1.8往后</h1><p>而在 JDK 1.8 中，ConcurrentHashMap 主要做了两个优化：</p>
<ul>
<li>同<code>HashMap</code> 一样，链表也会在长度达到 8 的时候转化为红黑树，这样可以提升大量冲突时候的查询效率；</li>
<li>以某个位置的头结点（链表的头结点或红黑树的 root 结点）为锁，**配合自旋+CAS(乐观锁)**避免不必要的锁开销，进一步提升并发性能。</li>
</ul>
<p><img src="map-20230816155924.png"></p>
<p>相比 JDK1.7 中的 ConcurrentHashMap，JDK1.8 中的 ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS + synchronized 来保证并发安全性，整个容器只分为一个 Segment，即 table 数组。</p>
<p>JDK1.8 中的 ConcurrentHashMap 对节点 Node 类中的共享变量，和 JDK1.7 一样，使用 volatile 关键字，保证多线程操作时，变量的可见性。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis：持久层技术、ORM框架</title>
    <url>/2024/07/06/mybatis/</url>
    <content><![CDATA[<h1 id="回顾-JDBC开发"><a href="#回顾-JDBC开发" class="headerlink" title="回顾 JDBC开发"></a>回顾 JDBC开发</h1><ol>
<li><p>优点：简单易学,上手快, 非常灵活构建SQL，效率高</p>
</li>
<li><p>缺点：代码繁琐，难以写出高质量的代码（例如：资源的释放，SQL注入安全性等）</p>
</li>
</ol>
<p>开发者既要写业务逻辑，又要写对象的创建和销毁，必须管底层具体数据库的语法</p>
<p>（例如：分页）。</p>
<ol start="3">
<li>适合于超大批量数据的操作，速度快</li>
</ol>
<p>性能：jdbc(80%代码只完成20%的事) &gt; mybatis &gt; hibernate:(from Employee) &gt; jpa</p>
<h1 id="什么是mybatis，有什么特点"><a href="#什么是mybatis，有什么特点" class="headerlink" title="什么是mybatis，有什么特点"></a>什么是mybatis，有什么特点</h1><ol>
<li><p>基于上述二种支持，我们需要在中间找到一个平衡点呢？结合它们的优点，摒弃它们的缺点，这就是myBatis，现今myBatis被广泛的企业所采用。 </p>
</li>
<li><p>MyBatis，前身ibatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。</p>
</li>
<li><p>iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）</p>
</li>
<li><p>持久层技术：</p>
</li>
</ol>
<p>​		<strong>jdbc&#x2F;dbutils&#x2F;springDAO</strong></p>
<p>​		ORM ( Object Relationship Mapping)框架：ORM 框架是持久化框架有<strong>mybatis、hibernate、springORM、Java Persistence API (JPA)、toplink、EJB3 EntityBean</strong></p>
<p>​	<a href="http://www.mybatis.cn/archives/2391.html"><a href="http://www.mybatis.cn/">MyBatis中文官网</a></a></p>
<h1 id="1-准备Maven-Pom-xml"><a href="#1-准备Maven-Pom-xml" class="headerlink" title="1.准备Maven Pom.xml"></a>1.准备Maven Pom.xml</h1><p> 在IntelliJ IDEA中配置 <em>pom.xml</em> 引入类库，这样在创建项目时直接引用类库即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 常量声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jdk版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 模块的依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mysql driver --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- apache libraries --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 类字节增强库：getter/setter, constructor method etc... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="2-创建POJO实体类"><a href="#2-创建POJO实体类" class="headerlink" title="2. 创建POJO实体类"></a>2. 创建POJO实体类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span> <span class="comment">// lombok类库 生成getter, setter, toString</span></span><br><span class="line"><span class="comment">// @ToString            //生成toString()</span></span><br><span class="line"><span class="comment">// @AllArgsConstructor  //全参数构造</span></span><br><span class="line"><span class="comment">// @NoArgsConstructor   //默认构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="comment">//lombok类库：用注解为实体类的属性生成getter/setter及构造函数等</span></span><br><span class="line">    <span class="keyword">private</span> Integer empno; <span class="comment">//Integer=null, int=0</span></span><br><span class="line">    <span class="keyword">private</span> String ename;</span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line">    <span class="keyword">private</span> Integer mgr;</span><br><span class="line">    <span class="keyword">private</span> Date hiredate;</span><br><span class="line">    <span class="keyword">private</span> Double sal;</span><br><span class="line">    <span class="keyword">private</span> Double comm;</span><br><span class="line">    <span class="keyword">private</span> Integer deptno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-创建-mybatis-config-xml配置文件"><a href="#3-创建-mybatis-config-xml配置文件" class="headerlink" title="3. 创建 mybatis-config.xml配置文件"></a>3. 创建 mybatis-config.xml配置文件</h1><p>在 <code>src/main/resources</code> 目录下新建<code>mybatis-config.xml</code> 配置文件，内容如下：</p>
<ol>
<li><p>（可选）配置相关属性：<code>&lt;properties resource=&quot;jdbc.properties&quot;/&gt; </code> 引入连接信息</p>
</li>
<li><p>（可选）配置实体类别名：<code>&lt;typeAliases&gt; ... &lt;/typeAliases&gt;</code></p>
</li>
</ol>
<ol start="3">
<li><p>配置连接池环境:  <code>&lt;environments default=&quot;...&quot;&gt; ... &lt;/environments&gt;</code></p>
</li>
<li><p>注册SQL Mapper映射文件：</p>
</li>
</ol>
<h2 id="jdbc-properties"><a href="#jdbc-properties" class="headerlink" title="jdbc.properties"></a>jdbc.properties</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/scott?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<h2 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a><strong>mybatis-config.xml</strong></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载外部的属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置不同的数据库环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开发环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注册实体映射文件，里面写SQL --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="**&lt;typeAliases&gt;**类型别名"></a>**&lt;typeAliases&gt;**类型别名</h2><p>类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。例如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 为包内的类命名别名：Employee 或 employee --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.glut.mybatismapper.entity&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：<typeAliases>加在<properties>元素的后面，<environments>元素的前面。</environments></properties></typeAliases></strong></p>
<h2 id="特性配置"><a href="#特性配置" class="headerlink" title="**&lt;settings&gt;**特性配置"></a>**&lt;settings&gt;**特性配置</h2><p>MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。具体配置项参考 Mybatis中文参考手册。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 二级缓存开关; 这个配置使全局的映射器启用或禁用二级缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：<settings>加在<properties>元素的后面，<typeAliases>元素的前面。</typeAliases></properties></settings></strong></p>
<h1 id="4-创建-SqlSessionFactory"><a href="#4-创建-SqlSessionFactory" class="headerlink" title="4. 创建 SqlSessionFactory"></a>4. 创建 SqlSessionFactory</h1><ul>
<li><p>通过加载核心配置文件创建SqlSessionFactory实例，SqlSessionFactory是一个应用程序内全局单一的实例，支持多线程安全操作</p>
</li>
<li><p>通过SqlSessionFactory 获得 SqlSession 操作数据库，所有的数据库操作通过SqlSession 完成。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">      <span class="comment">// 加载核心配置文件</span></span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">      <span class="comment">// sql会话工厂，此对象类似 DataSource</span></span><br><span class="line">      <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 得到sql会话对象,它封装了Connection， 此对象类似 java.sql.Connection</span></span><br><span class="line">      <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">      System.out.println(sqlSession.getConnection());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行查询</span></span><br><span class="line">      <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> sqlSession.selectList(<span class="string">&quot;名字空间 + 语句 ID&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-编写XML映射文件"><a href="#5-编写XML映射文件" class="headerlink" title="5. 编写XML映射文件"></a>5. 编写XML映射文件</h1><p>SQL语句元素有：</p>
<ul>
<li>select</li>
<li>insert</li>
<li>update</li>
<li>delete</li>
<li>sql</li>
</ul>
<p>Mybatis XML映射文件中可用来生成动态 SQL 的 XML 元素有：</p>
<ul>
<li>where</li>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
<li>bind</li>
</ul>
<p><strong>创建一个包：com.lanqiao.mapper</strong></p>
<ol>
<li><p>创建 XML 映射文件，编写sql语句</p>
</li>
<li><p>编写结果映射配置:  <resultMap id type="实体类全类名"></resultMap></p>
</li>
<li><p>主要的XML元素:</p>
</li>
</ol>
<h2 id="5-1-根元素"><a href="#5-1-根元素" class="headerlink" title="5.1 **&lt;mapper&gt;**根元素"></a>5.1 **&lt;mapper&gt;**根元素</h2><ul>
<li>namespace: 命名空间，通常是接口映射的全类名。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-2-与-元素"><a href="#5-2-与-元素" class="headerlink" title="5.2 **&lt;select&gt; ** 与 **&lt;where&gt;**元素"></a>5.2 **&lt;select&gt; ** 与 **&lt;where&gt;**元素</h2><p><code>&lt;select&gt;</code>元素用来编写select语句。</p>
<p><code>&lt;where&gt;</code>元素会生成一个 <code>WHERE</code>关键字。</p>
<ul>
<li><p><code>&lt;select resultType=&quot;POJO全类名&quot;&gt;</code>: 自动查询结果映射，要求结果集的列与实体类的属性名一致不区分大小写。</p>
</li>
<li><p><code>&lt;select resultMap=&quot;REF_ResultMap_ID&quot;&gt;</code>：手动结果映射，这种是推荐结果映射方式，这种方式比较灵活，而合适多表查询的结果映射。</p>
</li>
<li><p><code>&lt;bind name=&quot;变量名&quot; value=&quot;&quot;&gt;</code>: 绑定生成新变量在后面用于</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">     SELECT * FROM EMP WHERE EMPNO=#&#123;empno,jdbcType=INTEGER&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Employee&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;baseResultMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM EMP</span><br><span class="line">    <span class="comment">&lt;!-- 动态WHERE, 会生成一个 WHERE关键字,并且会消除条件中多余的 AND 或 OR关键字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在Java 里把 %JAMES% 拼好 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;if test=&quot;ename != null&quot;&gt;AND ENAME like #&#123;ename&#125;&lt;/if&gt; --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;enamePattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + ename + &#x27;%&#x27;&quot;</span>/&gt;</span></span><br><span class="line">        AND ENAME like #&#123;enamePattern&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null and job.trim().length()&gt;0&quot;</span>&gt;</span>AND JOB=trim(#&#123;job&#125;)<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span>&lt;![CDATA[ AND SAL&lt;=#&#123;sal&#125; ]]&gt;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptnoList != null&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;deptnoList&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">open</span>=<span class="string">&quot;AND DEPTNO in(&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">          #&#123;deptno&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：以上where 条件中<code>SAL &lt;=#&#123;sal&#125;</code>  的小于号是 XML 的无字符，需要放在XML CDATA 节点内，</strong></p>
<p><strong><code>&lt;![CDATA[ AND SAL&lt;=#&#123;sal&#125; ]]&gt;</code></strong></p>
<h2 id="5-3-结果映射元素"><a href="#5-3-结果映射元素" class="headerlink" title="5.3 **&lt;resultMap&gt;**结果映射元素"></a>5.3 **&lt;resultMap&gt;**结果映射元素</h2><p><code>&lt;resultMap&gt;</code>元素用来将查询结果集映射到实体。<code>&lt;resultMap&gt;</code>内部有以下几个主要元素：</p>
<ul>
<li><p><code>&lt;id&gt;</code>元素专门用于<em>映射主键字段</em></p>
<ul>
<li>javaType: 映射的 Java 属性类型，可以mybatis 预定义的类型别名（在第 8 节）或类型的全类名。</li>
<li>jdbcType: jdbc的类型名称（在第 7 节）。</li>
<li>typeHandler：类型处理器。无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。Mybatis 已定义了一些默认的类型处理器。</li>
</ul>
</li>
<li><p><code>&lt;result&gt;</code>元素用于映射普通字段。<result>元素的属性与<id>元素的的属性一样。</id></result></p>
</li>
<li><p><code>&lt;association&gt;</code>元素用于M:1多对一关联中映射 1方的实体</p>
</li>
<li><p><code>&lt;collection&gt;</code> 元素用于1:M一对多关联中映射 M方的实体</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lanqiao.domain.Employee&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;empno&quot;</span> <span class="attr">column</span>=<span class="string">&quot;empno&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;job&quot;</span> <span class="attr">column</span>=<span class="string">&quot;job&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;mgr&quot;</span> <span class="attr">column</span>=<span class="string">&quot;mgr&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;hiredate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hiredate&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DATE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sal&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sal&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;comm&quot;</span> <span class="attr">column</span>=<span class="string">&quot;comm&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="5-3-1-多对一关联映射"><a href="#5-3-1-多对一关联映射" class="headerlink" title="5.3.1 **&lt;association&gt;**多对一关联映射"></a>5.3.1 **&lt;association&gt;**多对一关联映射</h3><p>常用的两种实体关联映射有：</p>
<ul>
<li><strong>M:1（多对一关联映射）</strong></li>
<li><strong>1:1（一对一关联映射）</strong></li>
</ul>
<p>实体的 M:1(多对一)关联中使用<code>&lt;association&gt;&lt;/association&gt;</code>映射，关联元素处理“有一个”类型的关系，如一个员工属于一个部门。</p>
<p><strong>多对一关联有以下两种映射方式：</strong></p>
<ol>
<li><strong>(推荐）嵌套结果</strong></li>
</ol>
<p>​	使用嵌套结果映射来处理重复的联合结果的子集。首先让我们来查看这个元素的属性。所有的结果集你都会看到，它和普通的只由 <code>select </code>和 <code>resultMap</code> <em>属性</em>的结果映射不同。</p>
<p>​	<em>嵌套结果要求使用一条SQL语句查询出实体与关联实体（关联表）的数据，效率好。</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Employee&quot;</span>&gt;</span></span><br><span class="line">  省略其它字段的映射....</span><br><span class="line">  <span class="comment">&lt;!-- 1.嵌套结果（推荐使用）: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Department&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DEPTNO&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DNAME&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span> <span class="attr">column</span>=<span class="string">&quot;LOC&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 或者也可以引用另一个名字空间下的结果映射，这样可以减少一些映射配置</span></span><br><span class="line"><span class="comment">  &lt;association property=&quot;dept&quot; </span></span><br><span class="line"><span class="comment">      resultMap=&quot;com.lanqiao.mapper.DepartmentMapper.baseResultMap&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;/association&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>嵌套查询</strong></li>
</ol>
<p><em>嵌套查询 (性能差)</em>: 通过执行另外一个 SQL 映射语句来返回预期的复杂类型(JavaBean)。也就是说每个关联的实体都通过一条单独的 SQL来查询。</p>
<p>这种方式很简单, 但是对于大型数据集合和列表将不会表现很好。问题就是我们熟知的 <strong>“N+1 查询问题”</strong>。</p>
<blockquote>
<p><strong>（面试题）</strong>在mybatis的查询中什么是<strong>N+1</strong>次查询，即嵌套查询中的<strong>N+1</strong>问题：这种关联会发生<strong>N+1</strong>次查询问题。N指的是执行了多少条SQL语句获取关联实体，1指的是主查询。如下映射所示：</p>
</blockquote>
<ul>
<li><p>一条语句为查询员工实体：</p>
<p><code>select * from scott.emp</code>  </p>
<p>你执行了一个单独的 SQL 语句来获取员工结果列表(<strong>就是“+1”</strong>)。</p>
</li>
<li><p>N条语句为查询每个员工关联的部门实体</p>
<p>对返回的每条记录, 你执行了一个查询语句来为每个实体加载细节(<strong>就是“N”</strong>)。</p>
<p>当一条语句查询出员工的结果集时，员工结果集中关联的每个部门 (10,20,30,40) 都会导致执行了N 条 SQL语句查询部门实体，<em>已被查询出的部门实体会被缓存在mybatis的一级缓存 SqlSession中</em>：</p>
<p><code>select * from  scott.dept=10;</code>   </p>
<p><code>select * from scott.dept=20;</code>  </p>
<p><code>......</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseResultMap_2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用单独的语句查询关联实体，column=&quot;deptno&quot;员工表外键 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectDeptByPrimaryKey&quot;</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDeptByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">&quot;deptResultMap&quot;</span>&gt;</span></span><br><span class="line">  	select * from dept where deptno=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-3-2-一对多关联映射"><a href="#5-3-2-一对多关联映射" class="headerlink" title="5.3.2 **&lt;collection&gt;**一对多关联映射"></a>5.3.2 **&lt;collection&gt;**一对多关联映射</h3><p>1:M（一对多）关联使用<code>&lt;collection ofType=&quot;元素类型&quot; column=&quot;外键字段&quot;&gt;&lt;/collection&gt;</code>元素，要映射Many端结果到List集合中，我们使用集合元素。</p>
<p>映射集合也有两种方式：</p>
<ul>
<li><p><strong>1（推荐使用）嵌套结果</strong></p>
<p>​    <code>&lt;collection property=&quot;属性名&quot; ofType=&quot;集合元素的类型&quot; column=&quot;外键列&quot;&gt;</code></p>
<p>​    <code>&lt;/collection&gt;</code></p>
<p>​    结果映射引用了<code>EmployeeMapper.xml</code> 中的 <code>baseResultMap</code> 结果映射配置.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;departemnt&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span>       <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span>    <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span>      <span class="attr">column</span>=<span class="string">&quot;loc&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;employeeList&quot;</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">ofType</span>=<span class="string">&quot;employee&quot;</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resultMap</span>=<span class="string">&quot;com.lanqiao.mapper.EmployeeMapper.baseResultMap&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>2. 嵌套查询</strong></p>
<p>通过在<code>&lt;collection&gt;&lt;/collection&gt;</code>元素上指定<code>select=&quot;查询 Many端实体的语句&quot; </code>属性，</p>
<p>该属性会使用当前实体的主键（Many端为外键）来执行另一条查询语句获取Many端实体，并将获取到的Many端实体存入集合中。</p>
<p>​    <code>&lt;collection property=&quot;属性名&quot; ofType=&quot;属性类型&quot; column=&quot;外键列&quot; select=&quot;查询 Many端实体的语句&quot;&gt;</code></p>
<p>​    <code>&lt;/collection&gt;</code></p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseResultMap_2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;departemnt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span>       <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span>    <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span>      <span class="attr">column</span>=<span class="string">&quot;loc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;employeeList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">select</span>=<span class="string">&quot;selectEmployeeByDeptno&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByDeptno&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultMap</span>=<span class="string">&quot;com.lanqiao.mapper.EmployeeMapper.baseResultMap&quot;</span>&gt;</span></span><br><span class="line">   select *</span><br><span class="line">   from emp</span><br><span class="line">   where deptno=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>优点：编写<strong>SQL</strong>简单，无需做多表的连接查询；关联的实体通过单独的<strong>SQL</strong>语句查询并单独封装。<br> 缺点：执行了<strong>N+1</strong>条件语句。性能差</em></p>
<h2 id="5-4-通用-SQL-片段"><a href="#5-4-通用-SQL-片段" class="headerlink" title="5.4 **&lt;sql&gt;**通用 SQL 片段"></a>5.4 **&lt;sql&gt;**通用 SQL 片段</h2><p><em>通用 SQL片段</em>，可被其他语句引用的可重用语句块。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">  empno,ename,job,mgr,hiredate,sal,comm,deptno,header</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    from emp</span><br><span class="line">    where  empno = #&#123;empno,jdbcType=INTEGER&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="5-5-元素"><a href="#5-5-元素" class="headerlink" title="5.5 **&lt;if&gt;**元素"></a>5.5 **&lt;if&gt;**元素</h2><p><code>&lt;if&gt;</code>元素用以根据条件判断生成动态SQL。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1.在程序里把 %JAMES% 拼好 </span></span><br><span class="line"><span class="comment">		emp.setEname(&quot;%J%&quot;);</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span></span><br><span class="line">    AND ENAME like #&#123;ename&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">&lt;!-- 2.在XML里把 % 拼好 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;enamePattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + ename + &#x27;%&#x27;&quot;</span>/&gt;</span></span><br><span class="line">    AND ENAME like #&#123;enamePattern&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- SQL中遇到小于号用 CDATA 元素包裹起来。大于号可以直接用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[ AND SAL&lt;=#&#123;sal&#125;  ]]&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- trim(#&#123;job&#125;) 是mysql的trim()函数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null and job.trim().length()&gt;0&quot;</span>&gt;</span></span><br><span class="line">    AND JOB=trim(#&#123;job&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h2 id="5-6-元素"><a href="#5-6-元素" class="headerlink" title="5.6 **&lt;choose&gt;**元素"></a>5.6 **&lt;choose&gt;**元素</h2><p>分支结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 类似 java的 switch --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span> <span class="comment">&lt;!-- java switch case --&gt;</span></span><br><span class="line">      sql语句</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span> <span class="comment">&lt;!-- java switch default --&gt;</span></span><br><span class="line">       sql语句</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="5-7-元素"><a href="#5-7-元素" class="headerlink" title="5.7**&lt;foreach&gt;**元素"></a>5.7**&lt;foreach&gt;**元素</h2><p><code> &lt;foreach&gt;</code>元素通过遍历集合来产生动态 SQL。</p>
<ul>
<li>java 代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">// @Data = @Getter + @Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="comment">//省略其它属性</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//用于查询条件的多个部门号</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; deptnoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>xml 映射</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptnoList != null&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;deptnoList&quot;</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">open</span>=<span class="string">&quot;AND DEPTNO in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">    #&#123;deptno&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-8-元素"><a href="#5-8-元素" class="headerlink" title="5.8**&lt;trim&gt;**元素"></a>5.8**&lt;trim&gt;**元素</h2><p><code>&lt;trim&gt;</code> 元素用于删除空格或删除指定字符，并添加上指定的前缀字符 和 后缀字符。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;加上前缀字符&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;加上的后缀字符&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">prefixOverrides</span>=<span class="string">&quot;被删除的前缀字符&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;被删除的后缀字符&quot;</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span>ename,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>job,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;mgr != null&quot;</span>&gt;</span>mgr,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例：用来前置<code>SET</code>关键字和清除最后的逗号</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update_2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    update emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span>ENAME=#&#123;ename&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>JOB=#&#123;job&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span>SAL=#&#123;sal&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comm != null&quot;</span>&gt;</span>COMM=#&#123;comm&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empno != null&quot;</span>&gt;</span>EMPNO=#&#123;empno&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-9-元素、set元素"><a href="#5-9-元素、set元素" class="headerlink" title="5.9**&lt;update&gt;**元素、set元素"></a>5.9**&lt;update&gt;**元素、set元素</h2><p><code>&lt;set&gt;</code>元素会前置一个<code>SET</code>关键字，<em>同时会删除最后多余的逗号</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">  update emp</span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span>ENAME=#&#123;ename&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>JOB=#&#123;job&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span>SAL=#&#123;sal&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comm != null&quot;</span>&gt;</span>COMM=#&#123;comm&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empno != null&quot;</span>&gt;</span>EMPNO=#&#123;empno&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-10-元素"><a href="#5-10-元素" class="headerlink" title="5.10**&lt;insert&gt;**元素"></a>5.10**&lt;insert&gt;**元素</h2><p>insert语句没有resultMap，默认返回整数即插入的行数.<br><em>如果某些字段允许为 null 时，安全的做法就是对这样的列做 空值处理，这不是 mybaits 需要的，而是不同数据的驱动需要。</em></p>
<ul>
<li><p><code>useGeneratedKeys=&quot;true&quot;</code> : 说明主键值由数据库生成</p>
</li>
<li><p><code>keyProperty=&quot;empno&quot; </code>: 自动生成的主键值赋给 POJO 的哪个属性</p>
</li>
<li><p><code>keyColumn=&quot;empno&quot;</code>: 自动生成主键值的列</p>
</li>
</ul>
<p><strong>示例 1：使用 JDBC null 值处理</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;empno&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;empno&quot;</span>&gt;</span></span><br><span class="line">    insert into emp(ename, job, mgr, hiredate, sal, comm, deptno)</span><br><span class="line">    values (#&#123;ename&#125;,#&#123;job,jdbcType=VARCHAR&#125;,#&#123;mgr,jdbcType=INTEGER&#125;,#&#123;hiredate,jdbcType=DATE&#125;,#&#123;sal,jdbcType=DOUBLE&#125;,#&#123;comm,jdbcType=DOUBLE&#125;,#&#123;deptno,jdbcType=INTEGER&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：使用&lt;trim&gt;元素</strong></p>
<p><trim prefix="加上前缀字符" suffix="加上的后缀字符" prefixoverrides="被删除的前缀字符" suffixoverrides="被删除的后缀字符"></trim></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态 insert语句，就是说页面过来有值的字段生成SQL,无值的字段不生成SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert_2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">  insert into emp(</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span>ename,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>job,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;mgr != null&quot;</span>&gt;</span>mgr,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hiredate != null&quot;</span>&gt;</span>hiredate,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span>sal,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comm != null&quot;</span>&gt;</span>comm,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptno != null&quot;</span>&gt;</span>deptno,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span>)</span><br><span class="line">  values(</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span>#&#123;ename&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>#&#123;job&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;mgr != null&quot;</span>&gt;</span>#&#123;mgr&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hiredate != null&quot;</span>&gt;</span>#&#123;hiredate&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span>#&#123;sal&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comm != null&quot;</span>&gt;</span>#&#123;comm&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptno != null&quot;</span>&gt;</span>#&#123;deptno&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span>)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="6-接口映射器"><a href="#6-接口映射器" class="headerlink" title="6. 接口映射器"></a>6. 接口映射器</h1><p>映射器接口执行SQL语句的规则：</p>
<ol>
<li><p>XML 映射文件 *.xml的名字空间(<em>namespace</em>)必须和<em>映射器接口全类名一致</em>,必须放在与映射器接口相同的包下。</p>
<p>接口映射器类全名：<code>org.glut.mybatis.mapper.EmployeeMapper</code> (名字空间)</p>
</li>
</ol>
<ul>
<li>接口映射器 Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.glut.mybatis.mapper;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> Employee <span class="title function_">selectByPrimaryKey</span><span class="params">(Integer empno)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>XML映射文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.glut.mybatis.mapper.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">&quot;Employee&quot;</span>&gt;</span></span><br><span class="line">      select * from emp where empno=#&#123;id&#125;</span><br><span class="line">  	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>selectByPrimaryKey(Integer empno) </code>方法名对应 *.xml中的语句ID</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">....</span>&gt;</span></span><br><span class="line">  SQL....</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>selectByPrimaryKey(Integer empno)</code>参数类型对应SQL语句所需的参数类型</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">....</span>&gt;</span></span><br><span class="line">    SQL....</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>Employee selectByPrimaryKey(Integer empno)</code>返回值  对应 SQL语句的查询结果类型</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">resultType</span>=<span class="string">&quot;Employee&quot;</span> <span class="attr">....</span>&gt;</span></span><br><span class="line">    SQL....</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p><em>如果是 insert,update,delete 操作那么方法声明返回 int 类型</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(Employee parameter)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(Employee parameter)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Integer empno)</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在<code>mybatis-config.xml</code> 配置文件中配置接口映射器</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/EmployeeMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;package name=&quot;XML映射文件所在包&quot;/&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在程序中使用接口映射器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> SqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过EmployeeMapper接口全类名 与 EmployeeMapper.xml文件中的命名空间匹配.</span></span><br><span class="line"><span class="comment">* 调用的select() 方法其方法名“select”为 EmployeeMapper.xml文件中的语句ID.</span></span><br><span class="line"><span class="comment">* select()方法返回类型与 sql语句的查询结果匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.selectByPrimaryKey(<span class="number">1234</span>);</span><br></pre></td></tr></table></figure>

<h1 id="7-支持的-JDBC-类型"><a href="#7-支持的-JDBC-类型" class="headerlink" title="7.支持的 JDBC 类型"></a>7.支持的 JDBC 类型</h1><p>为了未来的参考,MyBatis 通过包含的 <em>jdbcType枚举型</em>,支持下面的 JDBC 类型。 </p>
<p><code>java.sql.Types</code>中定义的常量。</p>
<table>
<thead>
<tr>
<th><strong>BIT</strong></th>
<th><strong>FLOAT</strong></th>
<th><strong>CHAR</strong></th>
<th><strong>TIMESTAMP</strong></th>
<th>OTHER</th>
<th>UNDEFINED</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>REAL</td>
<td><strong>VARCHAR</strong></td>
<td>BINARY</td>
<td><strong>BLOG</strong></td>
<td>NVARCHAR</td>
</tr>
<tr>
<td>SMALLINT</td>
<td><strong>DOUBLE</strong></td>
<td>LONGVARCHAR</td>
<td>VARBINARY</td>
<td><strong>CLOB</strong></td>
<td>NCHAR</td>
</tr>
<tr>
<td><strong>INTEGER</strong></td>
<td><strong>NUMERIC</strong></td>
<td><strong>DATE</strong></td>
<td>LONGVARBINARY</td>
<td><strong>BOOLEAN</strong></td>
<td>NCLOB</td>
</tr>
<tr>
<td>BIGINT</td>
<td><strong>DECIMAL</strong></td>
<td>TIME</td>
<td>NULL</td>
<td>CURSOR</td>
<td>ARRAY</td>
</tr>
</tbody></table>
<h1 id="8-支持的-Java类型"><a href="#8-支持的-Java类型" class="headerlink" title="8. 支持的 Java类型"></a>8. 支持的 Java类型</h1><p>mybatis已经为许多常见的 Java 类型内建了相应的<em>类型别名</em>。它们都是大小写不敏感的，<em>需要注意的是由基本类型名称重复导致的特殊处理“带下划线”</em>。</p>
<table>
<thead>
<tr>
<th><em>别名</em></th>
<th><em>映射的Java类型</em></th>
</tr>
</thead>
<tbody><tr>
<td><strong>_byte</strong></td>
<td>byte</td>
</tr>
<tr>
<td><strong>_long</strong></td>
<td>long</td>
</tr>
<tr>
<td><strong>_short</strong></td>
<td>short</td>
</tr>
<tr>
<td><strong>_int</strong></td>
<td>int</td>
</tr>
<tr>
<td><strong>_integer</strong></td>
<td>int</td>
</tr>
<tr>
<td><strong>_double</strong></td>
<td>double</td>
</tr>
<tr>
<td><strong>_float</strong></td>
<td>float</td>
</tr>
<tr>
<td><strong>_boolean</strong></td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashmap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
<tr>
<td>iterator</td>
<td>Iterator</td>
</tr>
</tbody></table>
<h1 id="9-expr-与-expr-的区别"><a href="#9-expr-与-expr-的区别" class="headerlink" title="9. #{expr}与 ${expr} 的区别"></a>9. #{expr}与 ${expr} 的区别</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#&#123;ename&#125;: mybatis会将该表达解析成预译语句的 ？号（占位符）。</span><br><span class="line">$&#123;ename&#125;: mybatis不将这种表达式解析成预编译语句的 ？号，而是将它直接作为值来处理。这种语法不安全会有SQL注入攻击的风险。</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> ename <span class="keyword">like</span> <span class="string">&#x27;$&#123;ename&#125;&#x27;</span>  #生成<span class="comment">--&gt; and ename like &#x27;%J%&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">order</span> <span class="keyword">by</span> $&#123;orderBy&#125;  # orderBy是 Java 里的一个属性</span><br></pre></td></tr></table></figure>



<h1 id="10-SqlSession-持久化操作"><a href="#10-SqlSession-持久化操作" class="headerlink" title="10. SqlSession 持久化操作"></a>10. SqlSession 持久化操作</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession.selectList(<span class="string">&quot;语句ID&quot;</span> [, parameter]);</span><br><span class="line">SqlSession.selectOne(<span class="string">&quot;语句ID&quot;</span> [, parameter]);</span><br><span class="line">SqlSession.insert(<span class="string">&quot;语句ID&quot;</span>, parameter);</span><br><span class="line">SqlSession.delete(<span class="string">&quot;语句ID&quot;</span>, parameter);</span><br><span class="line">SqlSession.update(<span class="string">&quot;语句ID&quot;</span>, parameter);</span><br><span class="line">T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; cls)</span>; <span class="comment">//获取接口映射器</span></span><br></pre></td></tr></table></figure>

<p>parameter 参数对象为调用 SQL语句时所需的占位符参数，一般为 POJO对象。</p>
<p>#11.（重要）mybatis工作流程</p>
<ol>
<li><p>通过<code>Reader</code>对象读取<code>mybatis-config.xml</code>配置文件(该文本的位置和名字可任意)</p>
</li>
<li><p>通过<code>SqlSessionFactoryBuilder</code>对象创建<code>SqlSessionFactory</code>（类似<code>javax.sql.DataSource</code>）对象。</p>
</li>
</ol>
<p>注：如果要在应用程序中使用二级缓存那么可利用第三方的缓存（ehcache等），mybatis提供集成方案。</p>
<ol start="3">
<li>从<code>SqlSessionFactory</code>中获取<code>SqlSession</code>（封装了<code>java.sql.Connection</code>）对象，将<code>sqlSession</code>称为一级缓存。</li>
</ol>
<p><em>说明：</em></p>
<h2 id="SessionFactoryBuilder"><a href="#SessionFactoryBuilder" class="headerlink" title="SessionFactoryBuilder"></a><strong>SessionFactoryBuilder</strong></h2><p><em>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory</em>，就不再需要它了。因此 <code>SqlSessionFactoryBuilder</code> 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 <code>SqlSessionFactoryBuilder</code> 来创建多个 <code>SqlSessionFactory </code>实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a><strong>SqlSessionFactory</strong></h2><p><code>SqlSessionFactory</code><em>的缓存称为：二级（全局）缓存</em></p>
<p><code>SqlSessionFactory</code> 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 <code>SqlSessionFactory</code> 的最佳实践是在应用运行期间不要重复创建多次，多次重建 <code>SqlSessionFactory</code> 被视为一种代码“坏味道（bad smell）”。因此<code> SqlSessionFactory</code> 的最佳作用域是应用程序作用域级。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a><strong>SqlSession</strong></h2><p><code>SqlSession</code><em>的缓存称为：一级（线程级、事务级）缓存</em></p>
<p>每个线程都应该有它自己的 <code>SqlSession</code> 实例。<code>SqlSession</code> 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将<code> SqlSession</code> 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 <code>SqlSession</code> 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 <code>HttpSession</code>。如果你现在正在使用一种 Web 框架，要考虑 <code>SqlSession</code> 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 <code>SqlSession</code>，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。</p>
<ol>
<li><p>事务开始，在mybatis中事务是默认开启的, 但自动提交是关闭的。</p>
</li>
<li><p>通过<code>SqlSession</code>对象读取<code>EmployeeMapper.xm</code>l映射文件中的操作语句ID，从而读取sql语句。</p>
</li>
<li><p>事务提交。</p>
<ul>
<li><p><code>sqlSession.commit() </code>： 提交事务</p>
</li>
<li><p><code>sqlSession.rollback()</code>：回滚事务</p>
</li>
</ul>
</li>
<li><p>关闭<code>SqlSession</code>对象，释放数据库连接，提高数据库连接的重用性。让mybatis能响应更多的用户请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用try-finally 结构自动关闭 SqlSession</span></span><br><span class="line"><span class="keyword">try</span> ( <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MybatisUtil.getSqlSession() ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="11-二级缓存配置"><a href="#11-二级缓存配置" class="headerlink" title="11. 二级缓存配置"></a>11. 二级缓存配置</h1><p><strong>SqlSession</strong>级的缓存称为一级缓存、事务级缓存、线程级缓存。</p>
<p><strong>SqlSessionFactory</strong>级的缓存称为二级缓存、应用级缓存、全局缓存。Mybatis除了自身提供二级缓存的实现外，同时也提供对第三方缓存的支持，如：<em>Redis, Ehcache, Memory Cache</em>等。</p>
<h2 id="11-1-修改mybatis-config-xml"><a href="#11-1-修改mybatis-config-xml" class="headerlink" title="11.1 修改mybatis-config.xml"></a>11.1 修改mybatis-config.xml</h2><p><em>默认二级缓存是开启的</em>，如果要启用二级缓存，需要在mybatis-config.xml文件中加入下面设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!--  设置日志的实现方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个配置使全局的映射器启用或禁用二级缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="11-2-在SQL-Mapper映射文件中"><a href="#11-2-在SQL-Mapper映射文件中" class="headerlink" title="11.2 在SQL Mapper映射文件中"></a>11.2 在SQL Mapper映射文件中</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 缓存实体，此元素只对当前名字空间内的实体查询有效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;LRU&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">size</span>=<span class="string">&quot;1024&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--也可让某查询不使用二经缓存，只需在&lt;selec&gt;元素中使用useCache=“true” </span></span><br><span class="line"><span class="comment">     flushCache=&quot;false&quot; </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;integer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    Select_statement</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><cache> 这个简单语句的效果如下:</cache></p>
<ul>
<li><p><em>映射语句文件中的所有 <code>select</code> 语句将会被缓存</em>。</p>
</li>
<li><p><em>映射语句文件中的所有 <code>insert,update</code> 和 <code>delete</code> 语句会刷新缓存</em>。</p>
</li>
<li><p>缓存会使用 Least Recently Used (LRU,最近最少使用的)算法来收回。</p>
</li>
<li><p>根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序来刷新。</p>
</li>
<li><p>缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。</p>
</li>
<li><p>缓存会被视为是 read&#x2F;write(可读&#x2F;可写)的缓存,意味着对象检索不是共享的,而且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。</p>
</li>
</ul>
<p>可用的<em>收回策略</em>(<code>eviction</code>)有： </p>
<ul>
<li><p><em>LRU –  最近最少使用的</em>：移除最长时间不被使用的对象。 </p>
</li>
<li><p><em>FIFO –  先进先出</em>：按对象进入缓存的顺序来移除它们。 </p>
</li>
<li><p><em>SOFT –  软引用</em>：移除基于垃圾回收器状态和软引用规则的对象。 </p>
</li>
<li><p><em>WEAK –  弱引用</em>：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p>
</li>
</ul>
<p><strong>默认的是</strong> LRU收回策略。</p>
<ul>
<li><p>flushInterval（刷新间隔）可以被设置为任意的正整数，而且它们代表一个合理的<strong>毫秒</strong>形式的时间段。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。 </p>
</li>
<li><p>size（引用数目）可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目。默认值1024。 </p>
</li>
<li><p>readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。</p>
</li>
</ul>
<h2 id="11-3-实体类实现java-io-Serializable接口"><a href="#11-3-实体类实现java-io-Serializable接口" class="headerlink" title="11.3 实体类实现java.io.Serializable接口"></a>11.3 实体类实现java.io.Serializable接口</h2><p><strong>如果二级缓存想要命中实现，则必须要将上一次<strong><strong>sqlSession commit</strong></strong>之后才能生效**</strong>;**</p>
<p>缓存实体，只对当前名字空间内的实体查询有效。默认数据被缓存在java.io.tmpdir (JVM的一个属性)</p>
<p><strong>注意：</strong></p>
<ol>
<li><p>多表连接查询时关联实体不做缓存</p>
</li>
<li><p>mybatis的缓存是基于SQL语句id（namespace + select_id）做标识的</p>
</li>
<li><p>查询后要调用<strong>SqlSession.commit();</strong> 数据才会被缓存</p>
</li>
</ol>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>软件技术</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建一个博客？本站搭建博客花费了多少精力？</title>
    <url>/2024/07/14/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%9F%E6%9C%AC%E7%AB%99%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E8%8A%B1%E8%B4%B9%E4%BA%86%E5%A4%9A%E5%B0%91%E7%B2%BE%E5%8A%9B%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="哇塞-终于费劲心思把这个博客建好了"><a href="#哇塞-终于费劲心思把这个博客建好了" class="headerlink" title="哇塞~终于费劲心思把这个博客建好了"></a>哇塞~终于费劲心思把这个博客建好了</h1><p>哇塞~终于费劲心思把这个博客建好了，我要写一篇博客记录这个过程以及如何实现的。</p>
<p>本博客基于hexo搭建起来，起因也是我专业的朋友给我推送了这个视频，晚上睡不着觉突然又刷到了，于是第二天就开始马上着手准备~</p>
<h1 id="1-hexo"><a href="#1-hexo" class="headerlink" title="1.hexo"></a>1.hexo</h1><p>众所周知搭建一个博客的有hexo，以及其他我不用的框架，使用博客框架搭建起来非常快，而不是需要真的说去写一个前后端来实现，对非计算机专业的同学要求也不是那么高（如果你需要实现主题样式那就很高了），所以hexo真的是十分的nice啊~</p>
<p>不过需要去另外会用git，安装nodeJS，直接给它拿下</p>
<p><img src="1.png"></p>
<p><img src="Snipaste_2024-07-14_17-18-28.png"></p>
<p>当初按照下来的步骤很简单，不过在git上确实有问题，有时候<code>git bash命令</code>下载失败，有时候<code>npm命令</code>查找不到，单单装hexo下来就费劲了很多脑子~</p>
<p>仔细一想nodeJs我已经用nvm做版本管理了，才记得把hexo生成的文件夹扔到nvm下才生效，又花费了一点时间</p>
<p><img src="Snipaste_2024-07-14_17-15-03.png"></p>
<p>ok，咱也是直接拿下</p>
<p><img src="Snipaste_2024-07-14_17-20-01.png"></p>
<h1 id="2-主题样式"><a href="#2-主题样式" class="headerlink" title="2.主题样式"></a>2.主题样式</h1><p>接下来访问本地hexo成功以后就是选择主题了，hexo官方截止2024年7月14日有407个主题，每隔一段时间都会有开发者将自己的主题扔上去</p>
<p><img src="Snipaste_2024-07-14_17-23-07.png"></p>
<p><img src="Snipaste_2024-07-14_17-24-22.png"></p>
<p>最终我选择了当前的solitude主题，看上去比较符合我的要求，就这个了</p>
<p><img src="Snipaste_2024-07-14_17-25-15.png"></p>
<p>接下来也就是用git把代码拉到本地就行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-theme-solitude</span><br></pre></td></tr></table></figure>

<p><img src="Snipaste_2024-07-14_17-26-00.png"></p>
<p>下载下来了以后其实和你现在看到的我的博客大差不差了，主要是需要逐步的添加功能</p>
<h1 id="3-评论区如何实现"><a href="#3-评论区如何实现" class="headerlink" title="3.评论区如何实现"></a>3.评论区如何实现</h1><p>博客的留言板是需要配置界面的，可以看文档手册；最主要的是如何实现帖子的评论区，实现以后留言板用同一个就好</p>
<p><img src="Snipaste_2024-07-14_17-29-48.png"></p>
<p><img src="Snipaste_2024-07-14_17-32-24.png"></p>
<p>在文档中，提供了多个实现评论区的方式</p>
<p><img src="Snipaste_2024-07-14_17-33-31.png"></p>
<p>我用的是vercel + twikoo。twikoo有个很优秀的地方，就是输入qq邮箱可以获取到本人的qq信息，也可以评论后有回复的信息通过qq邮箱发送，就和B站抖音一样，也可以配置反垃圾处理等等功能十分优秀；vercel作为云部署的后端部分，加上<strong>MongoDB</strong>存储数据即可。</p>
<p><img src="Snipaste_2024-07-14_17-36-14.png"></p>
<p>不过缺点就是vercel和MongoDB的网站确实很难进，取决于你科学上网的实力了，不好的魔法开了也很费时间</p>
<p><img src="Snipaste_2024-07-14_17-38-27.png"></p>
<p><img src="Snipaste_2024-07-14_17-39-17.png"></p>
<p>此时还有一个最大的问题就是vercel是被墙了的，需要科学上网，不然进去非常慢，此时教程有说使用一个个人域名替换他就快很多，就是图中domains的地方</p>
<h1 id="4-购买域名"><a href="#4-购买域名" class="headerlink" title="4.购买域名"></a>4.购买域名</h1><p>这个就比较简单，华为云，腾讯云，阿里云都提供了购买域名的途径，而且一年下来10+块钱就可以了，比如说本站的域名在阿里云已经被我注册了。</p>
<p><strong>不过购买域名需要实名等等个人信息核查，最长需要一天，</strong>其他没什么问题。</p>
<p><img src="Snipaste_2024-07-14_17-43-58.png"></p>
<p>随便挑一个，然后把vercel里面的域名换掉就行了</p>
<p><img src="Snipaste_2024-07-14_17-45-08.png"></p>
<p>OK，在主题的yaml文件打开评论区就实现了</p>
<h1 id="5-博客ai"><a href="#5-博客ai" class="headerlink" title="5.博客ai"></a>5.博客ai</h1><p>这个主题可以使用的ai有两个，这个弄起来也比较简单，跟着弄就可以了，没啥难度</p>
<p><img src="Snipaste_2024-07-14_17-46-15.png"></p>
<p>postai一个月18！！！！！！！钱包好痛</p>
<p><img src="Snipaste_2024-07-14_17-50-52.png"></p>
<p>博客的聊天机器人和摘要ai都可以用了</p>
<p><img src="Snipaste_2024-07-14_17-51-45.png"></p>
<p><img src="Snipaste_2024-07-14_17-52-02.png"></p>
<h1 id="6-页面图片"><a href="#6-页面图片" class="headerlink" title="6.页面图片"></a>6.页面图片</h1><p>一开始我是打算用阿里云OSS的，不过免费的容量很小，果断放弃；</p>
<p><img src="Snipaste_2024-07-14_17-54-24.png"></p>
<p>再来打算使用图床，麻烦，放弃，反正我不用</p>
<p><img src="Snipaste_2024-07-14_17-57-00.png"></p>
<p>存本地，简单实用（其实一开始不确定可不可以存本地）</p>
<p><img src="Snipaste_2024-07-14_17-56-26.png"></p>
<p>有些图片也不是存本地的，其实可以去网页偷一下，比如mbti的那个，仔细一看连接是16人格官网的，看了他们的源代码也是部署到公网上，那么自然也可以直接引用他们的</p>
<p><img src="Snipaste_2024-07-14_18-00-01.png"></p>
<p>偷，都可以偷</p>
<p><img src="Snipaste_2024-07-14_18-02-18.png"></p>
<h1 id="7-矢量图标库"><a href="#7-矢量图标库" class="headerlink" title="7.矢量图标库"></a>7.矢量图标库</h1><p>你不得不说阿里巴巴矢量图标库很好用，这些都是从里面下的。下载得到的图片可以是svg格式的，你也可以换jpg&#x2F;png</p>
<p><img src="Snipaste_2024-07-14_18-05-26.png"></p>
<p>我特别喜欢影视飓风，干脆把他们公司的口号搜一下也有</p>
<p><img src="Snipaste_2024-07-14_18-06-01.png"></p>
<p>svg格式的图片有一个效果，就是图片的背景可以跟随主题背景变化</p>
<p><img src="Snipaste_2024-07-14_18-11-31.png"></p>
<p><img src="Snipaste_2024-07-14_18-11-51.png"></p>
<p><img src="2.png"></p>
<h1 id="8-公网访问"><a href="#8-公网访问" class="headerlink" title="8.公网访问"></a>8.公网访问</h1><p>在hexo下载到本地后，只能部署到本地，但是为了让大家都能访问得到需要放到公网上，因此围绕这个的实践就此展开….</p>
<h2 id="8-1-云服务器"><a href="#8-1-云服务器" class="headerlink" title="8.1 云服务器"></a>8.1 云服务器</h2><p>云服务器就是一台云端的服务器，可以在华为云、腾讯云、阿里云中购买，这个服务器具备公网ip，大家是可以访问到的。</p>
<p>以我的为例，我在阿里云免费试用了三个月，什么都好，就是我用不惯，部署一个博客有种大炮打蚊子的感觉</p>
<p><img src="Snipaste_2024-07-14_18-16-49.png"></p>
<p>而且，当时公网ip我还没有配置域名，泄露了一下就DDoS了（俗称恶意访问ip，访问量超过限制）</p>
<p><img src="DDoS.png"></p>
<p>在finalshell里面配置nginx等也非常麻烦，改一次就弄一次，上传文件也要挺久的，不推荐</p>
<p><img src="Snipaste_2024-07-14_18-20-59.png"></p>
<h2 id="8-2-githubpage"><a href="#8-2-githubpage" class="headerlink" title="8.2 githubpage"></a>8.2 githubpage</h2><p>这个真福音，但是也是真的慢。githubpage面向静态页面的功能，专门为部署博客这种静态页面而设计。但是众所周知，github是被墙的，所以部署到github上直接访问io文件特别慢，我自己进都半天。gitee原本是有这个功能的，但是现在封了，另选方法。</p>
<p><img src="Snipaste_2024-07-14_18-23-57.png"></p>
<h2 id="8-3-改用vercel部署"><a href="#8-3-改用vercel部署" class="headerlink" title="8.3 改用vercel部署"></a>8.3 改用vercel部署</h2><p>这个可行度取决于科学上网的实力。</p>
<p><img src="Snipaste_2024-07-14_18-27-26.png"></p>
<p>不过我用这个的时候版本问题搞得我头大，有时候我都推送上来了但是都不更新这个版本。</p>
<p><img src="Cache_7fd171c3712b5284.jpg" alt="版本问题"></p>
<p>无所谓了，我现在也没用这个了，我把域名映射关掉了</p>
<p><img src="Snipaste_2024-07-14_18-30-43.png" alt="取消vercel对域名的映射"></p>
<h2 id="8-4-cdn加速"><a href="#8-4-cdn加速" class="headerlink" title="8.4 cdn加速"></a>8.4 cdn加速</h2><p>cdn，context distributed network，内容分发网络，说白了就是就近访问cdn节点，不需要跨一系列的计算机网络到达提供服务的服务器，理论上可行的</p>
<p>但是阿里云这个需要icp备案，要求云产品下面需要有实例（比如买了一个云服务器），劝退我了</p>
<p><img src="Snipaste_2024-07-14_18-35-09.png" alt="ICP备案"></p>
<p>第二个就是用cloudflare给的dns服务器，亲测只能说拉了依托大的。免费版的链接换进阿里云了以后花了两天都没给他换完，进行测速的时候基本上占比进展特别慢，而且多次搞这个还让我一个域名报废了，重定向次数过多。</p>
<p><img src="Snipaste_2024-07-14_18-38-06.png"></p>
<h2 id="8-5-4everland"><a href="#8-5-4everland" class="headerlink" title="8.5 4everland"></a>8.5 4everland</h2><p>在掘金看到的一篇博客：<a href="https://juejin.cn/post/7009209925024874526?enable_transcoding_confirm=true">忘了缓慢的GithubPage，免费加速你的Hexo静态博客吧 - 掘金 (juejin.cn)</a></p>
<p>真神降临。动手尝试真的可以，现在进来都不那么慢了。甚至不需要再推仓库，正常的推送静态资源到github以后这里也会更新，所以只需要把4everland的映射绑定到域名上就可以了。现在进来的速度那么快都是因为用了4everland部署的哈哈，强烈推荐</p>
<p><img src="Snipaste_2024-07-14_18-42-54.png"></p>
<p>至此，基本没什么问题了</p>
<h1 id="9-来访者api"><a href="#9-来访者api" class="headerlink" title="9.来访者api"></a>9.来访者api</h1><p>这个定位的功能用一个博主的api，可以直接定位所在地或者ip，不知道准不准确。不过不需要害怕暴露ip，真正定位的是MAC地址而非是你的ip，下次切个网啥的就换掉了~</p>
<p><img src="Snipaste_2024-07-14_18-43-49.png"></p>
<h1 id="至最后"><a href="#至最后" class="headerlink" title="至最后"></a>至最后</h1><p>搭建出来确实累，不过可以有一个记录的地方啦，就当做个人的qq空间或者朋友圈吧~博客的最后至看到这里的每位朋友，正如本站的介绍：</p>
<p><strong>这里与大多数垂直类的技术博客不同，这里的种类会非常的繁杂，有技能的教程干货、有生活上的吐槽和妙招、有话题上的思考和想法。一般我研究什么、发现了什么都会分享在这里。</strong><br><strong>这些就是创造这个小站的本意，也是我分享生活的方式。有幸能和你相遇在这里，相信我们能共同留下一段美好记忆~</strong></p>
]]></content>
      <categories>
        <category>生活记录</category>
      </categories>
      <tags>
        <tag>软件技术</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统：（一）快速学习存储器</title>
    <url>/2024/07/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一、CPU"><a href="#一、CPU" class="headerlink" title="一、CPU"></a>一、CPU</h2><h3 id="1、冯诺依曼模型"><a href="#1、冯诺依曼模型" class="headerlink" title="1、冯诺依曼模型"></a>1、冯诺依曼模型</h3><p>在 1945 年冯诺依曼和其他计算机科学家们提出了计算机具体实现的报告，其遵循了图灵机的设计，而且还提出用电子元件构造计算机，并约定了用二进制进行计算和存储。</p>
<p>最重要的是定义计算机基本结构为 5 个部分，分别是<strong>运算器、控制器、存储器、输入设备、输出设备</strong>，这 5 个部分也被称为<strong>冯诺依曼模型</strong>。</p>
<p><img src="Von_Neumann_architecture.svg"></p>
<p><strong>运算器、控制器是在中央处理器（CPU）里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，</strong>比如键盘就是输入设备，显示器就是输出设备。</p>
<p>存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。所以，它们之间的关系如下图：</p>
<p><img src="%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.webp"></p>
<hr>
<h4 id="1-1-内存"><a href="#1-1-内存" class="headerlink" title="1.1 内存"></a>1.1 内存</h4><h4 id="1-什么是内存？"><a href="#1-什么是内存？" class="headerlink" title="1.什么是内存？"></a>1.什么是内存？</h4><p><strong>内存是硬件，是用于存放数据的硬件。</strong></p>
<p>程序执行前需要先放到内存中才能被CPU处理。</p>
<p>内存是与CPU沟通的桥梁，计算机中所有程序的运行都要依靠内存，内存对计算机的影响非常大。</p>
<p><strong>主存储器，内存，内存条，内部存储器是一个东西</strong>。这很重要，不然看到后面概念都混淆。</p>
<h4 id="2-内存的作用"><a href="#2-内存的作用" class="headerlink" title="2.内存的作用"></a>2.内存的作用</h4><p><strong>内存，用于存放CPU中的运算数据以及硬盘等外部存储设备交换的数据。</strong></p>
<p>CPU一般会把需要运算的数据调到主存中进行运算，运算完后CPU将结果再传出来。</p>
<p>我们的程序和数据都是存储在内存，存储的区域是线性的。</p>
<p>在计算机数据存储中，存储数据的基本单位是<strong>字节（byte）</strong>，1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。</p>
<p>内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。</p>
<hr>
<h4 id="1-2-中央处理器（CPU）"><a href="#1-2-中央处理器（CPU）" class="headerlink" title="1.2 中央处理器（CPU）"></a>1.2 中央处理器（CPU）</h4><p>中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：</p>
<ul>
<li>32 位 CPU 一次可以计算 4 个字节；</li>
<li>64 位 CPU 一次可以计算 8 个字节；</li>
</ul>
<p>这里的 32 位和 64 位，通常称为 CPU 的位宽，代表的是 CPU 一次可以计算（运算）的数据量。</p>
<p>之所以 CPU 要这样设计，是为了能计算更大的数值，如果是 8 位的 CPU，那么一次只能计算 1 个字节 <code>0~255</code> 范围内的数值，这样就无法一次完成计算 <code>10000 * 500</code> ，于是为了能一次计算大数的运算，CPU 需要支持多个 byte 一起计算，所以 CPU 位宽越大，可以计算的数值就越大，比如说 32 位 CPU 能计算的最大整数是 <code>4294967295</code>。</p>
<p>CPU 内部还有一些组件，常见的有<strong>寄存器、控制单元和逻辑运算单元</strong>等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。</p>
<p><strong>寄存器是计算机中央处理器（CPU）内部的一种高速存储单元，用于临时存储数据和指令。</strong></p>
<p><strong>为什么有了内存还需要寄存器？</strong></p>
<p>因为内存离 CPU 太远了，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。</p>
<hr>
<h4 id="1-3-输入、输出设备"><a href="#1-3-输入、输出设备" class="headerlink" title="1.3 输入、输出设备"></a>1.3 输入、输出设备</h4><p>输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。</p>
<hr>
<h3 id="2、线路位宽与-CPU-位宽（操作系统32位和64位）"><a href="#2、线路位宽与-CPU-位宽（操作系统32位和64位）" class="headerlink" title="2、线路位宽与 CPU 位宽（操作系统32位和64位）"></a>2、线路位宽与 CPU 位宽（操作系统32位和64位）</h3><p>数据是如何通过线路传输的呢？其实是通过操作电压，低电压表示 0，高压电压则表示 1。</p>
<p>如果构造了高低高这样的信号，其实就是 101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。</p>
<p>这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。</p>
<p>为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。</p>
<p>CPU 想要操作「内存地址」就需要「地址总线」：</p>
<ul>
<li>如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）；</li>
<li>如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。</li>
</ul>
<p>那么，想要 CPU 操作 4G 大的内存，那么就需要 32 条地址总线，因为 <code>2 ^ 32 = 4G</code>。</p>
<p>知道了线路位宽的意义后，我们再来看看 CPU 位宽。</p>
<p>CPU 的位宽最好不要小于线路位宽，比如 32 位 CPU 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 CPU 最好和 32 位宽的线路搭配，因为 32 位 CPU 一次最多只能操作 32 位宽的地址总线和数据总线。</p>
<p>如果用 32 位 CPU 去加和两个 64 位大小的数字，就需要把这 2 个 64 位的数字分成 2 个低位 32 位数字和 2 个高位 32 位数字来计算，先加个两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位，就能算出结果了，可以发现 32 位 CPU 并不能一次性计算出加和两个 64 位数字的结果。</p>
<p>对于 64 位 CPU 就可以一次性算出加和两个 64 位数字的结果，因为 64 位 CPU 可以一次读入 64 位的数字，并且 64 位 CPU 内部的逻辑运算单元也支持 64 位数字的计算。</p>
<p>但是并不代表 64 位 CPU 性能比 32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以<strong>如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来</strong>。</p>
<p>另外，32 位 CPU 最大只能操作 4GB 内存，就算装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为 <code>2^64</code>（256T）</p>
<h2 id="二、存储器的层次结构"><a href="#二、存储器的层次结构" class="headerlink" title="二、存储器的层次结构"></a>二、存储器的层次结构</h2><h3 id="层次结构介绍"><a href="#层次结构介绍" class="headerlink" title="层次结构介绍"></a>层次结构介绍</h3><p>计算机的两类存储器，一是外部存储器，二是内部存储器。<strong>常见的外部存储器主要是磁盘，磁盘又分为硬盘和软盘，而内部存储器就是常说的内存。</strong></p>
<p><strong>小林coding层次结构：</strong></p>
<img src="%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" style="zoom: 80%;">

<p><strong>OS教材：</strong></p>
<img src="OS%E7%9A%84%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1.png" style="zoom: 80%;">

<h3 id="聚焦CPU内部："><a href="#聚焦CPU内部：" class="headerlink" title="聚焦CPU内部："></a>聚焦CPU内部：</h3><p>我们想象中一个场景，大学期末准备考试了，你前去图书馆临时抱佛脚。那么，在看书的时候，我们的大脑会思考问题，也会记忆知识点，另外我们通常也会把常用的书放在自己的桌子上，当我们要找一本不常用的书，则会去图书馆的书架找。</p>
<p>我们可以把 CPU 比喻成我们的大脑，大脑正在思考的东西，就好比 CPU 中的<strong>寄存器</strong>，处理速度是最快的，但是能存储的数据也是最少的，毕竟我们也不能一下同时思考太多的事情，除非你练过。</p>
<p>我们大脑中的记忆，就好比 <strong>CPU Cache</strong>，中文称为 CPU 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。</p>
<p>CPU Cache 通常会分为 <strong>L1、L2、L3 三层</strong>，其中 L1 Cache 通常分成「数据缓存」和「指令缓存」，L1 是距离 CPU 最近的，因此它比 L2、L3 的读写速度都快、存储空间都小。我们大脑中短期记忆，就好比 L1 Cache，而长期记忆就好比 L2&#x2F;L3 Cache。</p>
<p>寄存器和 CPU Cache 都是在 CPU 内部，跟 CPU 挨着很近，因此它们的读写速度都相当的快，但是能存储的数据很少，毕竟 CPU 就这么丁点大。</p>
<p><img src="%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.webp"></p>
<h3 id="聚焦CPU外部："><a href="#聚焦CPU外部：" class="headerlink" title="聚焦CPU外部："></a>聚焦CPU外部：</h3><p>知道 CPU 内部的存储器的层次分布，我们放眼看看 CPU 外部的存储器。</p>
<p>当我们大脑记忆中没有资料的时候，可以从书桌或书架上拿书来阅读，那我们桌子上的书，就好比<strong>内存</strong>，我们虽然可以一伸手就可以拿到，但读写速度肯定远慢于寄存器，那图书馆书架上的书，就好比<strong>硬盘</strong>，能存储的数据非常大，但是读写速度相比内存差好几个数量级，更别说跟寄存器的差距了。</p>
<p>硬盘有如下的内容：</p>
<p><strong>机械硬盘（HDD）</strong><br>机械硬盘是计算机中的一种数据存储设备，它使用旋转的盘片和移动的磁头来读写数据。机械硬盘通常比固态硬盘容量更大，价格更便宜，但是速度相对较慢，且比较容易受到机械损伤的影响。机械硬盘通常用于存储大量数据和长期存储。</p>
<p><strong>固态硬盘（SSD）</strong><br>固态硬盘是一种新型的数据存储设备，它使用闪存芯片来读写数据。固态硬盘比机械硬盘速度更快，能够更快地启动计算机和打开文件，且比较抗震抗摔，寿命也更长。但是，固态硬盘价格相对较高，容量相对较小。</p>
<p>在第一节介绍内存的时候，曾说内存就是主存，<strong>但是严格的说，内存包括主存(内存条,基于DRAM)与高速缓存(Cache,基于SRAM)两部分。</strong></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="1-CPU的寄存器"><a href="#1-CPU的寄存器" class="headerlink" title="1. CPU的寄存器"></a>1. CPU的寄存器</h4><p><strong>定义与功能</strong></p>
<ol>
<li><p>寄存器是CPU内部的高速存储单元，用于暂时存储CPU运算过程中的数据和指令。</p>
</li>
<li><p>它们具有极快的访问速度，能够减少CPU对内存的访问次数，提高程序执行效率。</p>
</li>
</ol>
<h4 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h4><p><strong>定义与功能</strong></p>
<ol>
<li><p>内存（RAM，随机存取存储器）是计算机系统中用于存储数据和程序的临时存储器。</p>
</li>
<li><p>提供了较大的存储容量，但相对于CPU的访问速度较慢。</p>
</li>
</ol>
<p><strong>与CPU的关系</strong></p>
<ol>
<li><p>CPU通过内存总线与内存进行通信，以读取和写入数据。</p>
</li>
<li><p>当CPU需要执行程序时，它会从内存中读取指令和数据到寄存器中进行处理。</p>
</li>
</ol>
<h4 id="3-高速缓存（Cache）"><a href="#3-高速缓存（Cache）" class="headerlink" title="3. 高速缓存（Cache）"></a>3. 高速缓存（Cache）</h4><p><strong>定义与功能</strong></p>
<ol>
<li><p>高速缓存是位于CPU和内存之间的一种存储器层次结构，用于存储CPU频繁访问的数据和指令。</p>
</li>
<li><p>它通过减少CPU对内存的访问次数来提高计算机系统的性能。</p>
</li>
</ol>
<p><strong>多级缓存结构</strong></p>
<ol>
<li><p>通常包括L1、L2、L3等多级缓存，其中L1缓存距离CPU最近且速度最快，L2、L3缓存则更大但速度稍慢。</p>
</li>
<li><p>这种多级缓存结构旨在利用容量、速度和成本之间的平衡，以提供更好的性能。</p>
</li>
</ol>
<h4 id="4-寄存器、内存与高速缓存之间的联系"><a href="#4-寄存器、内存与高速缓存之间的联系" class="headerlink" title="4. 寄存器、内存与高速缓存之间的联系"></a>4. 寄存器、内存与高速缓存之间的联系</h4><p><strong>数据传输</strong></p>
<ol>
<li><p>当CPU执行程序时，它会从内存中读取指令和数据到寄存器中进行处理。</p>
</li>
<li><p>如果这些指令和数据已经存储在高速缓存中，则CPU可以直接从缓存中读取，减少了对内存的访问次数。</p>
</li>
</ol>
<p><strong>性能提升</strong></p>
<ol>
<li><p>寄存器和高速缓存的存在大大提高了CPU的数据访问速度，从而提升了计算机系统的整体性能。</p>
</li>
<li><p>它们通过减少CPU对内存的依赖，降低了内存访问的延迟和能耗。</p>
</li>
</ol>
<p><strong>协同工作</strong></p>
<ol>
<li><p>寄存器、内存和高速缓存之间通过复杂的协同工作机制，共同支持CPU的高效运行。</p>
</li>
<li><p>寄存器提供快速的数据访问能力，高速缓存减少了对内存的访问次数，而内存则提供了较大的存储容量以支持复杂的程序和数据结构。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统：（二）原码，反码，补码，计算丢失精度</title>
    <url>/2024/07/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2%E4%B8%8D%E7%AD%89%E4%BA%8E0-3/</url>
    <content><![CDATA[<h1 id="1-原码"><a href="#1-原码" class="headerlink" title="1.原码"></a>1.原码</h1><p>对于一个数， 计算机要使用一定的编码方式进行存储。<strong>原码， 反码， 补码</strong>是机器存储一个具体数字的编码方式。<strong>在计算机中数据存储都是以二进制的形式表示数据，那么将一个十进制数转换为其二进制形式称为其原码。</strong>二进制最左边的是符号位，0为正，1为负。</p>
<p>计算机中存储的最小单元是<code>字节</code>，字节以二进制存储数据，一个字节对应<code>8个比特位</code>。也就是说一个字节的最大值的二进制表示形式为<code>0111 1111</code>，其中第一个0为符号位，最大值对应十进制就是127。最小值为<code>1111 1111</code>，十进制为-127。</p>
<h1 id="2-反码"><a href="#2-反码" class="headerlink" title="2.反码"></a>2.反码</h1><p><strong>当前讨论的反码和补码都是讨论负数，正数的反码和补码等于其原码</strong></p>
<p>在原码为负数的情况进行相加，会出现运算结果不一致的情况，例如<code>1000 0001</code>，加1，那么理论得到的结果应该是<code>1000 0000</code>（十进制0），实际得到的是100000010（十进制-2）。</p>
<p>为了解决原码不能计算负数，遵循以下反码的计算规则：正数反码不变，负数的反码在原码的基础上，符号位不变，0变1,1变0。计算完后再取反码就可以得到负数的运算结果。</p>
<p><strong>但是在跨0计算的时候会存在误差：例如-5+6得0（当前讨论一个字节，多出去的1直接忽略）</strong></p>
<p><img src="%E5%8F%8D%E7%A0%81%E9%97%AE%E9%A2%981.png" alt="反码原理以及反码存在的问题"></p>
<h1 id="3-补码"><a href="#3-补码" class="headerlink" title="3.补码"></a>3.补码</h1><p><strong>当前讨论的反码和补码都是讨论负数，正数的反码和补码等于其原码</strong></p>
<p>为了针对0在二进制中有两个表示形式，引出使用补码进行计算，<strong>即负数的补码等于负数的反码+1</strong></p>
<p><img src="%E8%A1%A5%E7%A0%81.png" alt="负数补码等于其反码+1"></p>
<p>由于原码的0占了两个反码，在修改成补码后会多出一个数字，二进制数字为<code>1000 0000</code>，即-128，所以规定-128的补码为<code>1000 0000</code>。</p>
<p><img src="-128%E7%9A%84%E8%A1%A5%E7%A0%81.png" alt="-128补码"></p>
<p><strong>在计算机中存储和计算都采用补码</strong>，所以即使-128没有原码和反码也不碍事（在1个字节的情况下）。</p>
<h1 id="4-Java中的隐式转换和强制转换（拓展）"><a href="#4-Java中的隐式转换和强制转换（拓展）" class="headerlink" title="4.Java中的隐式转换和强制转换（拓展）"></a>4.Java中的隐式转换和强制转换（拓展）</h1><p>隐式转换直接加0</p>
<p><img src="Snipaste_2024-07-30_16-19-43.png" alt="隐式转换"></p>
<p>强制转换直接删掉字节前面的全部内容，得到补码进行计算（<strong>在计算机中存储和计算都采用补码</strong>）</p>
<p><img src="Snipaste_2024-07-30_16-20-57.png" alt="强制转换"></p>
<p>b的值就是二进制-1后取反，得到原码，最后是-56。因为b是补码形式的二进制数据。</p>
<h1 id="5-其他运算符（拓展）"><a href="#5-其他运算符（拓展）" class="headerlink" title="5.其他运算符（拓展）"></a>5.其他运算符（拓展）</h1><p><img src="%E9%80%BB%E8%BE%91%E4%B8%8E.png" alt="逻辑与"></p>
<p>左移一次乘2，右移一次除2。</p>
<p><img src="%E5%B7%A6%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="左移"></p>
<h1 id="6-十进制转二进制"><a href="#6-十进制转二进制" class="headerlink" title="6.十进制转二进制"></a>6.十进制转二进制</h1><p>小数部分的转换不同于整数部分，它采用的是乘2取整法，将十进制中的小数部分乘以2作为二进制的一位，然后继续取小数部分乘以2作为下一位，直到不存在小数为止。</p>
<p><img src="%E5%8D%81%E8%BF%9B%E5%88%B6%E5%B0%8F%E6%95%B0%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.webp" alt="十进制转二进制"></p>
<p>但是，并不是所有小数都可以用二进制表示，前面提到的0.625小数是一个特例，刚好通过乘2取整法的方式完整的转换成二进制。<br>如果我们用相同的方式，来把0.1 转换成二进制，过程如下:</p>
<p><img src="%E6%97%A0%E9%99%90%E5%B0%8F%E6%95%B0.webp"></p>
<p>所以只能无限接近0.1而取不到0.1的值，所以算出来就不是0.3</p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：（一）排序算法</title>
    <url>/2024/07/03/%E7%AE%97%E6%B3%95%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序必备图示网站"><a href="#排序必备图示网站" class="headerlink" title="排序必备图示网站"></a>排序必备图示网站</h1><p>一个链接看完所有排序算法的图示：<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">排序算法图示</a></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>核心思想: </p>
<ol>
<li>相邻的元素两两比较，大的放右边，小的放左边。</li>
<li>第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推。</li>
<li>如果数组中有n个数据，总共我们只要执行n- 1轮的代码就可以。</li>
</ol>
<p>重点在于冒泡排序的优化：</p>
<p>第二层for循环中可以-i，进而提高效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoBubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//-1防止索引越界</span></span><br><span class="line">            <span class="comment">///-i提高效率</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用递归实现冒泡排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort(arr, arr.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归实现冒泡排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length-<span class="number">1</span>; left++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left + <span class="number">1</span>] &lt; arr[left]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">                arr[left] = arr[left + <span class="number">1</span>];</span><br><span class="line">                arr[left + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            bubbleSort(arr, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序使用双指针法的对撞指针，定义start指针（左指针）和end指针（右指针）查找指针指向的数组元素和baseNumber的关系</p>
<p>在第一轮的排序中，通过方法会确定基准数的位置，接下来按照基准数的位置将会划分以基准数为中间的左右两个区间，再对两个区间进行递归（递归时不断的二分区间）完成排序。</p>
<p>注意点：</p>
<ol>
<li>end指针一定要先动</li>
<li>递归需要定义出口</li>
<li>baseNumber需要在出口后定义否则可能索引越界</li>
<li>递归的地方是quickSort(arr, i, start - 1)和quickSort(arr, start + 1, j);</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">doQuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 1、输入数组个数和数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[number];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、调用快速排序</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、打印排序结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">//1、确定基准数、左指针、右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归函数的出口</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*baseNumber应该放在判断结束之后*/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">baseNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、当end指针在start指针右边，或者是两个指针没有重合时都需要进行循环</span></span><br><span class="line">        <span class="keyword">while</span> (end != start) &#123;</span><br><span class="line">            <span class="comment">// 当end指针指向的数字比baseNumber小的时候，end指针停止</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[end] &lt; baseNumber || end &lt;= start) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当start指针指向的数字比baseNumber大的时候，start指针停止</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[start] &gt; baseNumber || end &lt;= start) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//此时运行到这里，两个指针指向的位置已经确定了，交换两个指针对应的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 退出最外层循环后，start,end指向同一个位置，即baseNumber的位置，基准数归位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        arr[start] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一轮排序结束，开始递归</span></span><br><span class="line">        quickSort(arr, i, start - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, start + <span class="number">1</span>, j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在baseNumber定义之前设置递归出口</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="1、合并有序数组"><a href="#1、合并有序数组" class="headerlink" title="1、合并有序数组"></a>1、合并有序数组</h2><p>将数组内的两个区间内的有序元素进行合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以将该数组看为{1,5,6}和{2,3,7,8}，合并后仍然用原来的空间存储数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>假设已知两个数组的范围，第一个是l到lEnd，第二个是rEnd到rEnd，那么合并两个的代码如下：</p>
<p>其中l和r变量不仅充当范围的作用，还是一个指针，指向当前元素的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> lEnd, <span class="type">int</span> r, <span class="type">int</span> rEnd, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l;<span class="comment">//temp数组的索引</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd &amp;&amp; r &lt;= rEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;</span><br><span class="line">                temp[k++] = arr[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = arr[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd) &#123;</span><br><span class="line">            temp[k++] = arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= rEnd) &#123;</span><br><span class="line">            temp[k++] = arr[r++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，我们使用一个中间数组temp去存储变量，k的值去记录temp的索引，比较两个区间的值，小的就放进temp数组就可以了。</p>
<p><strong>下面两个while循环的作用是什么？</strong></p>
<p>如果说第一个区间的l指针已经走到了末尾，那么第二个区间的r指针肯定没有走到结尾。又因为两个区间都是排好序的，所以第二个区间剩下的元素肯定都是比第一个区间的数字要大的，直接拼接到temp数组后面就行了。也就是说，两个while循环还可以换成以下写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (l &gt; lEnd) &#123;</span><br><span class="line">    System.arraycopy(arr, r, temp, k, rEnd - r + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &gt; rEnd) &#123;</span><br><span class="line">    System.arraycopy(arr, l, temp, k, lEnd - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、使用合并数组实现归并排序-递归"><a href="#2、使用合并数组实现归并排序-递归" class="headerlink" title="2、使用合并数组实现归并排序(递归)"></a>2、使用合并数组实现归并排序(递归)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoMergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 1、输入数组个数和数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[number];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义初始数组的区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、调用sort方法进行排序</span></span><br><span class="line">        mergeSort(arr, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 3、归并排序讲究分治的思想，对于拿到的一个数组，不断的进行对半拆分，直到每个区间都拆到只剩1个元素后再对两个区间合并</span></span><br><span class="line"><span class="comment">         * 合并的时候进行排序，不断的递归</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 定义临时数组存储数据，如果在split中创建的话每次递归都会创建一个数组，所以写在这里</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        split(arr, left, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = Arrays.copyOfRange(arr, left, right + <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、治：当区间中只有一个元素的时候认为数组有序（提供递归的出口）</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4、分：不断的将每一个区间进行拆分，直到拆到一个区间只有一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//算平均值</span></span><br><span class="line"></span><br><span class="line">        split(arr, left, mid, temp);<span class="comment">//递归</span></span><br><span class="line">        split(arr, mid + <span class="number">1</span>, right, temp);<span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、合</span></span><br><span class="line">        merge(arr, left, mid, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        System.arraycopy(temp, left, arr, left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> lEnd, <span class="type">int</span> r, <span class="type">int</span> rEnd, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l;<span class="comment">//temp数组的索引</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd &amp;&amp; r &lt;= rEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;</span><br><span class="line">                temp[k++] = arr[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = arr[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd) &#123;</span><br><span class="line">            temp[k++] = arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= rEnd) &#123;</span><br><span class="line">            temp[k++] = arr[r++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>比较难的地方：</strong></p>
<ol>
<li><p>split方法比较难理解，我用代码输出一下拆分的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// split方法</span></span><br><span class="line"><span class="type">int</span>[] array = Arrays.copyOfRange(arr, left, right + <span class="number">1</span>);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入案例</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分过程</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">9</span>]</span><br><span class="line">[<span class="number">3</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">8</span>]</span><br><span class="line">[<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">4</span>]</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure>

<p>可以看到流程是这样的（数据不一样）：<img src="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif">只有拆分到最小的时候（就是区间只有一个元素的时候)，递归结束，到merge方法进行合并。而merge中就实现排序的方法逻辑。</p>
</li>
<li><p>在merge方法中，我设置了temp数组的索引k值。之前我写的是k&#x3D;0，而不是k&#x3D;l，这里是不对的。为什么不对？</p>
<p>其实在整个归并的过程中，两个子数组归并到上一级的数组的时候，temp数组是要进行覆盖之前的元素的，而上一级的数组排序的时候，应该为两个子数组的最左边的那个范围。</p>
<p>我们拿split的例子来说，得到两个子数组[9,3]和[7,2]的时候，l的值是0，那么排序的时候k应该从0开始，得到两个子数组[8,5]和[1,4]的时候，i的值应该对应8索引，然后赋值到temp索引中。所以merge方法的k索引取决于扔进去的两个区间的最左边的范围。<img src="temp%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95.png" style="zoom:80%;"></p>
</li>
<li><p>范围上都是left到mid，mid+1到right</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">split(arr, left, mid, temp);<span class="comment">//递归</span></span><br><span class="line">split(arr, mid + <span class="number">1</span>, right, temp);<span class="comment">//递归</span></span><br><span class="line">merge(arr, left, mid, mid + <span class="number">1</span>, right, temp);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>再看一个不分多个方法写的版本，其实思路都是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoMergeSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">24</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        MergeSort2(arr, left, right, temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">MergeSort2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="comment">// 看看分治成功了没有</span></span><br><span class="line">        <span class="type">int</span>[] array = Arrays.copyOfRange(arr, left, right + <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.治</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.分</span></span><br><span class="line">        MergeSort2(arr, left, mid, temp);</span><br><span class="line">        MergeSort2(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp[k++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                temp[k++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.arraycopy(temp, left, arr, left, right - left + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><img src="%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png"></p>
<p>首先找到排好序的部分，标记排好序的最右边的索引，然后从无序的第一个开始，和排序好的部分最右边的比较，如果无序的第一个元素比排好序的最大的元素相比要小，那么就把这个元素一直往左边移动，直到排好序的元素比这个移动的元素要小为止。</p>
<p>插入的思想在于遍历无序的部分，不断的和有序的部分比较，不断的往左边移动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">insertdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//1.拿到无序的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                startIndex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(startIndex);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.遍历从startIndex开始的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//提高效率，一直用i，完成一轮以后又要走空代码（while不会成立），效率低</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//交换数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                <span class="comment">//i要一直指向移动的那个数字</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="面试常考排序算法"><a href="#面试常考排序算法" class="headerlink" title="面试常考排序算法"></a>面试常考排序算法</h1><p><a href="https://blog.csdn.net/qq_45792749/article/details/124410972">面试常考的排序算法</a></p>
<h1 id="acWing代码模板"><a href="#acWing代码模板" class="headerlink" title="acWing代码模板"></a>acWing代码模板</h1><p><a href="https://www.acwing.com/blog/content/31431/">【Java版本】常用代码模板1——基础算法 + 模板题参考实现 - AcWing</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：（三）数据结构——链表</title>
    <url>/2024/07/06/%E7%AE%97%E6%B3%95%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h1><p><img src="%E9%93%BE%E8%A1%A8%E5%88%86%E7%B1%BB.png"></p>
<h1 id="1-单向链表-包含头指针"><a href="#1-单向链表-包含头指针" class="headerlink" title="1. 单向链表(包含头指针)"></a>1. 单向链表(包含头指针)</h1><h2 id="1-1-单向链表实现"><a href="#1-1-单向链表实现" class="headerlink" title="1.1 单向链表实现"></a>1.1 单向链表实现</h2><p>单向链表为一个SingleLinkedList类，里面包含Node内部类（封装，不向外暴露底层实现细节），一个节点记录下一个节点的地址值，是一个指针，在java中其实就是引用对象（一个引用数据类型记录的是地址值，所以Node类中使用Node作为变量，实际上是下一个节点的地址）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-头插法添加元素"><a href="#1-2-头插法添加元素" class="headerlink" title="1.2 头插法添加元素"></a>1.2 头插法添加元素</h2><p>链表不为空的时候，插入的节点的地址值应该指向原本链表中的第一个节点，head刚好记录的就是第一个节点的地址值，所以将head指针的值赋值给新节点node。再将创建出来的node节点赋值给head指针，代表head指向新插入的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 1.链表为空的情况</span></span><br><span class="line">          head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 2.链表不为空</span></span><br><span class="line">          <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, head);</span><br><span class="line">          head = node;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再将头插法简化一下，其实一行的代码就搞定了。在上面的代码的else语句中，其实两行代码是冗余的，可以放idea里面让编译器提示；另外如果head是null的情况下，下面的代码也可以同时包含if-else的逻辑。不过写上面的吧，看得懂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">     head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, head);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-遍历链表"><a href="#1-3-遍历链表" class="headerlink" title="1.3 遍历链表"></a>1.3 遍历链表</h2><h3 id="1-3-1-while循环实现遍历"><a href="#1-3-1-while循环实现遍历" class="headerlink" title="1.3.1 while循环实现遍历"></a>1.3.1 while循环实现遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环链表</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loopList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head;<span class="comment">//head头指针默认就是null（引用数据类型没有初始化就是null）,除非添加元素</span></span><br><span class="line">      <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;当前链表元素的值：&quot;</span> + now.value);</span><br><span class="line">          now = now.next;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>编写测试类：在链表同一级包下创建类TestSingleLinkedList1，使用@Test注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSingleLinkedList1</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span><span class="comment">//Maven导入的测试类包</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SingleLinkedList1</span> <span class="variable">singleLinkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList1</span>();</span><br><span class="line">        singleLinkedList1.addFirst(<span class="number">1</span>);</span><br><span class="line">        singleLinkedList1.addFirst(<span class="number">2</span>);</span><br><span class="line">        singleLinkedList1.addFirst(<span class="number">3</span>);</span><br><span class="line">        singleLinkedList1.addFirst(<span class="number">4</span>);</span><br><span class="line">        singleLinkedList1.loopList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//当前链表元素的值：4</span></span><br><span class="line"><span class="comment">//当前链表元素的值：3</span></span><br><span class="line"><span class="comment">//当前链表元素的值：2</span></span><br><span class="line"><span class="comment">//当前链表元素的值：1</span></span><br></pre></td></tr></table></figure>



<h3 id="1-3-2-迭代器实现遍历"><a href="#1-3-2-迭代器实现遍历" class="headerlink" title="1.3.2 迭代器实现遍历"></a>1.3.2 迭代器实现遍历</h3><p>我把其他部分代码删了，只留下迭代器的部分。</p>
<p>类实现迭代器的接口，需要重写iterator方法（神金才选择变成抽象类），接着 return new Iterator&lt;&gt;()，以匿名内部类的形式重写hasNext方法和next方法，hasNext就是判断<code>当前元素</code>（记好，是当前元素，不要因为有next命名以为是下一个）是否存在，next方法对当前元素进行自己的处理逻辑，<code>并且移动迭代器指针</code>。OK，next方法直接返回节点的值（value），直接测试类输出就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList1</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> node != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> node.value;</span><br><span class="line">                node = node.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SingleLinkedList1</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList1</span>();</span><br><span class="line">    list2.addFirst(<span class="number">1</span>);</span><br><span class="line">    list2.addFirst(<span class="number">2</span>);</span><br><span class="line">    list2.addFirst(<span class="number">3</span>);</span><br><span class="line">    list2.addFirst(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Integer element : list2) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>



<h3 id="1-3-3-递归遍历"><a href="#1-3-3-递归遍历" class="headerlink" title="1.3.3 递归遍历"></a>1.3.3 递归遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop2</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(node.value);</span><br><span class="line">    loop2(node.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-4-尾插法添加元素"><a href="#1-4-尾插法添加元素" class="headerlink" title="1.4 尾插法添加元素"></a>1.4 尾插法添加元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加元素（尾差法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果head为空，那么直接赋值新节点后退出，否则循环链表到最后节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.遍历链表到最后一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//2.代码运行到这里的时候说明now=null，说明当前是没有值的</span></span><br><span class="line">                <span class="comment">//3.创建新对象赋值给now，使得now指针指向新节点node</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">                now.next = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SingleLinkedList1</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList1</span>();</span><br><span class="line">        list1.addFirst(<span class="number">1</span>);</span><br><span class="line">        list1.addFirst(<span class="number">2</span>);</span><br><span class="line">        list1.addFirst(<span class="number">3</span>);</span><br><span class="line">        list1.addFirst(<span class="number">4</span>);</span><br><span class="line">        list1.addLast(<span class="number">5</span>);</span><br><span class="line">        list1.loopList();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当前链表元素的值：4</span></span><br><span class="line"><span class="comment">//当前链表元素的值：3</span></span><br><span class="line"><span class="comment">//当前链表元素的值：2</span></span><br><span class="line"><span class="comment">//当前链表元素的值：1</span></span><br><span class="line"><span class="comment">//当前链表元素的值：5</span></span><br></pre></td></tr></table></figure>



<h2 id="1-5-获取索引"><a href="#1-5-获取索引" class="headerlink" title="1.5 获取索引"></a>1.5 获取索引</h2><p>由于链表中不存在index属性，所以将在获取索引的时候（就是遍历链表的时候自己设置一个）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找链表中的第index个节点</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">findIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head; now != <span class="literal">null</span>; i++,now = now.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// now为null时退出循环，所以返回null，代表查不到这个node节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValueByFindIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SingleLinkedList1</span> <span class="variable">list4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList1</span>();</span><br><span class="line">    list4.addFirst(<span class="number">1</span>);</span><br><span class="line">    list4.addFirst(<span class="number">2</span>);</span><br><span class="line">    list4.addFirst(<span class="number">3</span>);</span><br><span class="line">    list4.addFirst(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> list4.getValueByFindIndex(<span class="number">1</span>);</span><br><span class="line">    System.out.println(index1);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> list4.getValueByFindIndex(<span class="number">5</span>);</span><br><span class="line">    System.out.println(index2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-任意位置插入元素"><a href="#1-6-任意位置插入元素" class="headerlink" title="1.6 任意位置插入元素"></a>1.6 任意位置插入元素</h2><p>如果index超过索引范围，抛异常。最后两行findIndex方法的循环条件是now !&#x3D; null（1.5for循环中的条件），所以只会在链表的有效范围内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">           addFirst(value);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 插入的位置是index，那么需要让index位置上一个节点指向插入点，插入点指向上一个元素原来指向的节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);<span class="comment">//上一个节点</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//输入的index超过链表范围</span></span><br><span class="line">       <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果查到的node节点他不是空的，说明是在链表中间到末尾最后一个的位置，可以插入</span></span><br><span class="line">       node.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, node.next);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SingleLinkedList1</span> <span class="variable">list5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList1</span>();</span><br><span class="line"><span class="comment">//        list5.addFirst(1);</span></span><br><span class="line"><span class="comment">//        list5.addFirst(2);</span></span><br><span class="line"><span class="comment">//        list5.addFirst(3);</span></span><br><span class="line"><span class="comment">//        list5.addFirst(4);</span></span><br><span class="line"></span><br><span class="line">        list5.insert(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        list5.loopList();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-删除节点"><a href="#1-7-删除节点" class="headerlink" title="1.7 删除节点"></a>1.7 删除节点</h2><p>删除节点只需要改一个节点的next，只需要把需要删除的节点的上一个节点指向需要删除的节点的下一个元素就行了，说得有些拗口，画个图</p>
<p>假设我要删除2元素，那么只需要让1元素指向3就行了，<strong>2元素指向什么元素和链表无关</strong>。ok可能会担心内存的问题，因为没有node节点2了。其实在java中存在gc机制，不会导致内存之类的问题。</p>
<p><img src="%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.png"></p>
<p>删除的时候有三种情况</p>
<ol>
<li><p>如果删除的是索引0，findIndex(index - 1)中的参数是-1，也是null，假设索引0确实存在元素，直接使用如下代码是不合理的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//待删除的上一个节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">preNode</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span> (preNode == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>因为index-1是应该指的是head指针，而不是计算出来的-1。所以单独判断一种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除索引0的情况</span></span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(<span class="number">0</span>);</span><br><span class="line">               head = node.next;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;索引0位置不存在元素&quot;</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>如果删除的元素的上一个元素不存在，则说明超出了链表范围，抛异常</p>
</li>
<li><p>如果删除的元素不存在，和第二种情况一样，抛异常</p>
</li>
</ol>
<p>只有满足2，3情况，才能让 <code>Node next = node.next;    preNode.next = next</code>跑起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//删除索引0的情况</span></span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(<span class="number">0</span>);</span><br><span class="line">               head = node.next;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;索引0位置不存在元素&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//待删除的上一个节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">preNode</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span> (preNode == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//待删除的节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> preNode.next;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//待删除的下一个节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line"></span><br><span class="line">       preNode.next = next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-8-整个链表的源码"><a href="#1-8-整个链表的源码" class="headerlink" title="1.8 整个链表的源码"></a>1.8 整个链表的源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SingleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList1</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> node != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> node.value;</span><br><span class="line">                node = node.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（头插法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1.链表为空的情况</span></span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.链表不为空</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, head);</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//while循环链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loopList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表元素的值：&quot;</span> + now.value);</span><br><span class="line">            now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（尾差法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果head为空，那么直接赋值新节点后退出，否则循环链表到最后节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.遍历链表到最后一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//2.代码运行到这里的时候说明now=null，说明当前是没有值的</span></span><br><span class="line">                <span class="comment">//3.创建新对象赋值给now，使得now指针指向新节点node</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">                now.next = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找链表中的第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head; now != <span class="literal">null</span>; i++, now = now.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">                <span class="keyword">return</span> now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValueByFindIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            addFirst(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入的位置是index，那么需要让index位置上一个节点指向插入点，插入点指向上一个元素原来指向的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);<span class="comment">//上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入的index超过链表范围</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果查到的node节点他不是空的，说明是在链表中间到末尾最后一个的位置，可以插入</span></span><br><span class="line">        node.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, node.next);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//删除索引0的情况</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(<span class="number">0</span>);</span><br><span class="line">                head = node.next;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;索引0位置不存在元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待删除的上一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">preNode</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (preNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//待删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> preNode.next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//待删除的下一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line"></span><br><span class="line">        preNode.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-单向链表（带哨兵）"><a href="#2-单向链表（带哨兵）" class="headerlink" title="2. 单向链表（带哨兵）"></a>2. 单向链表（带哨兵）</h1><p>在第一节中，head指向的要么是null，要么是链表的第一个元素，但是在增删查中，总是需要判断head指针指向的是不是null，或者删除中是否满足findIndex方法的逻辑等，这样判断确实有些麻烦</p>
<p>现在让链表中插入一个哨兵节点（sentinel），让head指针指向它，可以省去部分node是否为null的判断。哨兵节点的value随便是什么都可以，遍历的时候不要遍历哨兵节点就行了。</p>
<p><img src="%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SingleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表（带哨兵）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList2</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">//头指针指向哨兵节点，value是什么随便填写，因为不属于链表的元素，也不打算遍历哨兵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">114514</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> node != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> node.value;</span><br><span class="line">                node = node.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（头插法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//哨兵后的第一个元素节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//插入的节点指向原本哨兵后的第一个节点的同时让哨兵指向插入的节点</span></span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//while循环链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loopList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历的起点变了，从head变成head.next开始，意思就是从哨兵往后的第一个节点开始，不包括哨兵</span></span><br><span class="line">        <span class="comment">// head = new node(value,node)了以后head指向哨兵，head.next就是哨兵的下一个</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表元素的值：&quot;</span> + now.value);</span><br><span class="line">            now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（尾插法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//哨兵的尾插法不需要进行非空判断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.遍历链表到最后一个节点</span></span><br><span class="line">        <span class="comment">// 遍历的起点变了，从head变成new node(value,node)哨兵节点了，因为head=new node(value,node)，所以直接写head就是哨兵</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//2.代码运行到这里的时候说明now=null，说明当前是没有值的</span></span><br><span class="line">                <span class="comment">//3.创建新对象赋值给now，使得now指针指向新节点node</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">                now.next = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找链表中的第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for循环遍历的起点变了，从head变成head.next开始，意思就是从哨兵往后的第一个节点开始，不包括哨兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head.next; now != <span class="literal">null</span>; i++, now = now.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">                <span class="keyword">return</span> now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValueByFindIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//哨兵机制也不用改动，防止输入的index范围超出链表的长度</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//哨兵机制下上一个节点可以使用findIndex方法，不需要单独判断index=0，原本是打算直接使用findIndex方法找上一个节点的</span></span><br><span class="line">        <span class="comment">//使用方法的时候如果是0索引得到的是-1，是一种特殊情况，现在有了哨兵就不需要单独判断0了</span></span><br><span class="line"><span class="comment">//        if (index == 0) &#123;</span></span><br><span class="line"><span class="comment">//            addFirst(value);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入的位置是index，那么需要让index位置上一个节点指向插入点，插入点指向上一个元素原来指向的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);<span class="comment">//上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入的index超过链表范围</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果查到的node节点他不是空的，说明是在链表中间到末尾最后一个的位置，可以插入</span></span><br><span class="line">        node.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, node.next);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 哨兵机制下和insert方法的理由同理，可以不用单独判断index=0的情况</span></span><br><span class="line">        <span class="comment">//删除索引0的情况</span></span><br><span class="line"><span class="comment">//        if (index == 0) &#123;</span></span><br><span class="line"><span class="comment">//            if (head != null) &#123;</span></span><br><span class="line"><span class="comment">//                Node node = findIndex(0);</span></span><br><span class="line"><span class="comment">//                head = node.next;</span></span><br><span class="line"><span class="comment">//                return;</span></span><br><span class="line"><span class="comment">//            &#125; else throw new IllegalArgumentException(&quot;索引0位置不存在元素&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//待删除的上一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">preNode</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (preNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//待删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> preNode.next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//待删除的下一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line"></span><br><span class="line">        preNode.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-双向链表（带哨兵）"><a href="#3-双向链表（带哨兵）" class="headerlink" title="3. 双向链表（带哨兵）"></a>3. 双向链表（带哨兵）</h1><p><img src="%E5%8F%8C%E5%90%91%E5%93%A8%E5%85%B5.png">双向链表的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表（带哨兵）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedList1</span> &#123;</span><br><span class="line">    <span class="comment">// 头哨兵</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">// 尾哨兵</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表的无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedList1</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">114514</span>, <span class="literal">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">114514</span>, <span class="literal">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 上一个节点指针</span></span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="comment">// 值</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="comment">// 下一个节点指针</span></span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各种方法都写在一块儿了，根据图来写方法就行了，增删查的方法：</p>
<p>双向链表特有的，也是优势的方法就是<code>尾插</code>和<code>尾删</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DoublyLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表（带哨兵）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedList1</span> &#123;</span><br><span class="line">    <span class="comment">// 头哨兵</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">// 尾哨兵</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表的无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedList1</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">114514</span>, <span class="literal">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">114514</span>, <span class="literal">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 上一个节点指针</span></span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="comment">// 值</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="comment">// 下一个节点指针</span></span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找链表中的第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为遍历的时候从head哨兵开始，但是实际链表中不把head哨兵算在索引内，因此index=-1开始</span></span><br><span class="line">        <span class="comment">// index=-1代表的节点是head哨兵</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head; p != tail; p = p.next, i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//1.通过findIndex去搜索索引的位置</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 判断index是否在链表中存在，prev存在，那么就可以插入，因为findIndex不会遍历头尾哨兵</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;输入的index：\&quot;&quot;</span> + index + <span class="string">&quot;\&quot;不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> findNode(index);</span><br><span class="line">        <span class="comment">//2.创建插入的节点对象</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        <span class="comment">//3.插入的新节点的上一个节点，next指向新节点</span></span><br><span class="line">        prev.next = node;</span><br><span class="line">        <span class="comment">//4.插入的新节点的下一个节点，prev指向新节点</span></span><br><span class="line">        next.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（头插法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        insert(<span class="number">0</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//1.通过findIndex去搜索索引的位置</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;输入的index：\&quot;&quot;</span> + index + <span class="string">&quot;\&quot;不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.待删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> prev.next;</span><br><span class="line">        <span class="keyword">if</span> (node == tail) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;输入的index：\&quot;&quot;</span> + index + <span class="string">&quot;\&quot;不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.待删除的下一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//将需要删除的节点的上一个节点指向需要删除的节点的下一个节点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（尾插法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(tail.prev, value, tail);</span><br><span class="line">        tail.prev.next = node;</span><br><span class="line">        tail.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素（尾删）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="keyword">if</span> (lastNode == head) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;当前删除元素为tailSentinel，不能使用尾删法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> lastNode.prev;</span><br><span class="line">        prev.next = tail;</span><br><span class="line">        tail.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据索引获取链表元素值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValueByFindIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findNode(index);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="4-环形链表"><a href="#4-环形链表" class="headerlink" title="4. 环形链表"></a>4. 环形链表</h1><img src="%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.png" style="zoom: 120%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LoopDoublyLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopDoublyLinkedList1</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node sentinel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p != sentinel;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环链表的无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoopDoublyLinkedList1</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">Node</span>(sentinel, <span class="number">0</span>, sentinel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">//上一个节点</span></span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="comment">//节点的值</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="comment">//下一个节点</span></span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//节点类的有参构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(sentinel, value, sentinel.next);</span><br><span class="line">        sentinel.next = node;</span><br><span class="line">        sentinel.next.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> sentinel.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(lastNode, value, sentinel);</span><br><span class="line">        lastNode.next = lastNode;</span><br><span class="line">        sentinel.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头删法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sentinel.next == sentinel) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;头删不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">remove</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> remove.next;</span><br><span class="line">        sentinel.next = next;</span><br><span class="line">        next.prev = sentinel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾删法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">remove</span> <span class="operator">=</span> sentinel.prev;</span><br><span class="line">        <span class="keyword">if</span> (remove == sentinel) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;尾删不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> remove.prev;</span><br><span class="line">        prev.next = sentinel;</span><br><span class="line">        sentinel.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据值进行删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findByValue(value);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> node.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findByValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="keyword">while</span> (p != sentinel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.value == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：（二）二分查找</title>
    <url>/2024/07/03/%E7%AE%97%E6%B3%95%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="一、基础二分查找"><a href="#一、基础二分查找" class="headerlink" title="一、基础二分查找"></a>一、基础二分查找</h1><p><a href="https://leetcode.cn/problems/binary-search/description/">力扣704：二分查找</a></p>
<p>左闭右闭区间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// nums[mid] &gt; target</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左闭右开区间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// nums[mid] &gt; target</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>left和right的含义（贼他妈重点，区分两个写法的区间到底怎么写）：</strong></p>
<p>作为<strong>区间</strong>[left,right]或者[left,right)；作为指针指向元素。</p>
<p>在左闭右闭区间中，left&lt;&#x3D;right，right是有可能指向target的，但是left&lt;right，<strong>right只是边界</strong>，right不可能是target。因此在左闭右闭区间的时候，right&#x3D;arr.length-1，而左闭右开区间right&#x3D;arr.length。</p>
<img src="%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E8%8D%89%E7%A8%BF.jpg" style="zoom:120%;">





<p><strong>二分查找注意点：</strong></p>
<ol>
<li><p><strong>单单只看左闭右闭区间，while循环中到底是left&lt;right还是left&lt;&#x3D;right？</strong></p>
<p>可以有一个具体的例子，当查找的数字是左边界的时候，left&lt;right会漏掉一次查询。因为left和right共同指向一个位置的时候不满足while条件，所以退出循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿草稿纸自己写一下，别只看不动笔的</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">24</span>&#125;;</span><br><span class="line">target = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>int mid &#x3D; left + ((right - left) &gt;&gt; 1)是什么？为什么不是直接相加除2？</strong></p>
<p>超过int类型的范围以后会变负数。右移运算符&gt;&gt;1相当于转换成二进制除2，需要补一下原码，反码，补码的内容，懒得写了。</p>
</li>
</ol>
<h1 id="二、二分查找寻找插入点"><a href="#二、二分查找寻找插入点" class="headerlink" title="二、二分查找寻找插入点"></a>二、二分查找寻找插入点</h1><p>这个在力扣上也是有题目的：<a href="https://leetcode.cn/problems/search-insert-position/submissions/544277320/">力扣35：二分查找寻找插入点</a></p>
<p>来看一个最简单的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// target = 0 or 2 or 4 or 6</span></span><br></pre></td></tr></table></figure>

<p>其实不难看出就是4种情况，基于mid分两边，左边是target&#x3D;0,2，或者是右边target&#x3D;4,6，因为都是查不到的，那么肯定在左闭右闭的写法中，right和left指针会发生重合，无非就是在看0，2两个情况左右两个指针怎么动罢了，由稿纸一眼法得出，left指针的值就是需要插入的位置</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (min&lt;=max) &#123;</span><br><span class="line">            mid = (max + min) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 说明在target应该在右边</span></span><br><span class="line">                min = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                <span class="comment">// 说明target应该在左边</span></span><br><span class="line">                max = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到插入的位置</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="三、二分查找重复元素的处理"><a href="#三、二分查找重复元素的处理" class="headerlink" title="三、二分查找重复元素的处理"></a>三、二分查找重复元素的处理</h1><h3 id="3-1-重复元素LeftMost"><a href="#3-1-重复元素LeftMost" class="headerlink" title="3.1 重复元素LeftMost"></a>3.1 重复元素LeftMost</h3><p>leftMost：查找元素最左边的索引</p>
<p>无非就是找到target以后记录索引，而不是return。</p>
<p>代码：我写的是target一定在arr中存在的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// leftMost</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= arr[mid]) &#123;</span><br><span class="line">                temp = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果target不存在，这个写法得出来的是target插入的位置</p>
<h3 id="3-2-重复元素RigthMost"><a href="#3-2-重复元素RigthMost" class="headerlink" title="3.2 重复元素RigthMost"></a>3.2 重复元素RigthMost</h3><p>和上面一样，直接往右边一直找就完事儿了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">               temp = mid;</span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">               right = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-3-重复元素中target不一定存在的情况返回最左边索引"><a href="#3-3-重复元素中target不一定存在的情况返回最左边索引" class="headerlink" title="3.3 重复元素中target不一定存在的情况返回最左边索引"></a>3.3 重复元素中target不一定存在的情况返回最左边索引</h3><p>其实在3.1中那样写if语句不包括target不一定在arr中的情况，因为我默认他可以找到的话，我会一直进行temp&#x3D;mid赋值，然而如果不存在target还进行赋值的话返回的不会是-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        temp = binarySearch3(arr, left, right, target, temp);</span><br><span class="line"></span><br><span class="line">        System.out.println(temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch4</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target, <span class="type">int</span> temp)</span> &#123;</span><br><span class="line">        <span class="comment">// leftMost</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                temp = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-4-重复元素中target不一定存在返回时插入位置"><a href="#3-4-重复元素中target不一定存在返回时插入位置" class="headerlink" title="3.4 重复元素中target不一定存在返回时插入位置"></a>3.4 重复元素中target不一定存在返回时插入位置</h3><p>看到3.1的代码就是了。为什么那样写可以在找到重复元素的同时（target存在）可以找到插入的位置？</p>
<p>原因是因为在找target的过程中，每次都给temp赋值，我们已经知道这段代码永远会去找最左边的值了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (target &lt;= arr[mid]) &#123;</span><br><span class="line">    temp = mid;</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且左闭右闭，left&#x3D;right最后一步的时候，mid的值取平均值后和left、right相等，temp&#x3D;mid记录的就是重复元素最左边的位置，刚好这个位置就是插入的位置了。</p>
<p>寻找插入位置我认为不需要判断leftmost或者rightmost，得到的结果都一样，我改了一下数组，看数组和输出结果就行了，用的都是leftMost的方法</p>
<img src="%E4%B8%8D%E5%AD%98%E5%9C%A8target%E8%8E%B7%E5%8F%96%E6%8F%92%E5%85%A5%E7%B4%A2%E5%BC%951.png" style="zoom:120%;">



<img src="%E4%B8%8D%E5%AD%98%E5%9C%A8target%E8%8E%B7%E5%8F%96%E6%8F%92%E5%85%A5%E7%B4%A2%E5%BC%952.png" style="zoom:80%;">



<h3 id="3-5-练习"><a href="#3-5-练习" class="headerlink" title="3.5 练习"></a>3.5 练习</h3><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">力扣34：查找排序数组中元素的第一个位置和最后一个位置</a></p>
<p>简单死了，就是查一个leftMost和rightMost，返回就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> leftMost(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> rightMost(nums, target);</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;left, right&#125;;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">leftMost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMost</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (i + j) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftMost = mid;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftMost == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftMost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rightMost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMost</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (i + j) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightMost = mid;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rightMost == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightMost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h3><p>在第三节里面，讨论了二分时有重复元素的情况，<strong>使用方法查找重复元素最左边或者最右边的索引，以及通过leftMost的样例代码寻找不存在元素的插入索引位置。</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：（四）递归</title>
    <url>/2024/07/09/%E7%AE%97%E6%B3%95%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h1 id="一、递归的解决思想"><a href="#一、递归的解决思想" class="headerlink" title="一、递归的解决思想"></a>一、递归的解决思想</h1><ol>
<li>确定是否用递归求解</li>
<li>推导递归关系，是否存在父问题和子问题的关系，以及递归的结束条件</li>
</ol>
<p>深入到最底层的过程叫递，从里层往外叫归。在递归的过程中，外层函数的局部变量仍可用。</p>
<h1 id="二、递归的解题思路（重点）"><a href="#二、递归的解题思路（重点）" class="headerlink" title="二、递归的解题思路（重点）"></a>二、递归的解题思路（重点）</h1><ol>
<li><p><strong>递归函数的定义</strong></p>
<ul>
<li>明确函数的使命</li>
<li>明确原问题和子问题</li>
<li>兼顾原问题和子问题</li>
</ul>
</li>
<li><p><strong>基础情况处理</strong></p>
<ul>
<li>数据规模较小的时候直接返回答案</li>
</ul>
</li>
<li><p><strong>递归调用</strong></p>
<ul>
<li><p>超级操作</p>
</li>
<li><p>看成整体，忽略细节</p>
</li>
<li><p>相信他一定可以完成使命</p>
</li>
</ul>
</li>
<li><p><strong>递归到当前层</strong></p>
<ul>
<li>微操作，处理逻辑</li>
</ul>
</li>
</ol>
<h1 id="三、递归必看视频（重点）"><a href="#三、递归必看视频（重点）" class="headerlink" title="三、递归必看视频（重点）"></a>三、递归必看视频（重点）</h1><p><a href="https://www.bilibili.com/video/BV1C14y1V77j/?spm_id_from=333.337.search-card.all.click">【递归2】如何治疗晕递归?B站UP五点七边动态展示递归</a></p>
<h1 id="四、单路递归"><a href="#四、单路递归" class="headerlink" title="四、单路递归"></a>四、单路递归</h1><h2 id="1-求阶层"><a href="#1-求阶层" class="headerlink" title="1.求阶层"></a>1.求阶层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * f(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递：父问题是求n的阶层，子问题则是求n-1的阶层，下一个子问题是求(n-1)-1的阶层…….，最后是求n&#x3D;1时，n的阶层</p>
<p>归：知道n&#x3D;1时的阶层，求n&#x3D;2的阶层，2*(n-1)，开始寻找规律，归回n。</p>
<p>递归方法是return n * f(n - 1);我换一个写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span>  n * f(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归方法的上部分，包括递归方法，进行递，就是不断往深处找，直到找到条件为止，下面部分就是归，处理逻辑，处理求阶层的逻辑，然后返回。</p>
<h2 id="2-反向打印字符串"><a href="#2-反向打印字符串" class="headerlink" title="2.反向打印字符串"></a>2.反向打印字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;spring spring 春天 春天&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> printInReflect(str, index);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">printInReflect</span><span class="params">(String str, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(index);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> printInReflect(str, index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c + s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>递归方法上面，包括递归方法，char c &#x3D; str.charAt(index);printInReflect(str, index - 1);就是进行递的过程，不断的往反方向去找，直到找到这个字符串最左边的位置为止。归的过程就是找到最左边的字符以后String s &#x3D; printInReflect(str, index - 1);返回一个空的，接下来返回c字符（第一次递归方法）。return以后回到左边开始第二个字符，因为char c &#x3D; str.charAt(index);中c已经是左边第二个字符了，String s &#x3D; printInReflect(str, index - 1);中s在第一次递归方法中已经返回了左边第一个字符，所以拼接。return c + s也有讲究，s是子的问题，应该放在最右边，归的时候子的字符都在右边才能达到反向拼接的效果。</p>
<h2 id="3-递归二分查找"><a href="#3-递归二分查找" class="headerlink" title="3.递归二分查找"></a>3.递归二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">24</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> binarySearch(left, right, arr, target);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左闭右闭区间，使用递归实现二分查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(mid + <span class="number">1</span>, right, arr, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(left, mid - <span class="number">1</span>, arr, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回顾一下二分查找：</p>
<p>在一个有序、不重复元素的数组中，通过双指针不断的进行二分数组的查找过程，查到数据返回数组索引值，否则返回-1</p>
<p>递的过程：不断进行二分。归的过程只有两个可能，要么是-1，要么是mid。mid的值，要么是过程中取平均值的时候使得arr[mid]&#x3D;target，要么就是left，right指向同一个值时（即递归的最后一步，也是二分查找的最后一步），mid取平均值使得arr[mid]&#x3D;target，如果还是不返回mid，那么就是-1了</p>
<h2 id="4-递归冒泡排序"><a href="#4-递归冒泡排序" class="headerlink" title="4.递归冒泡排序"></a>4.递归冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort(arr, arr.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归实现冒泡排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length-<span class="number">1</span>; left++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left + <span class="number">1</span>] &lt; arr[left]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">                arr[left] = arr[left + <span class="number">1</span>];</span><br><span class="line">                arr[left + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            bubbleSort(arr, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-递归插入排序"><a href="#5-递归插入排序" class="headerlink" title="5.递归插入排序"></a>5.递归插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//需要自行把有序索引边界算出来，此处省略</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">border</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//无序区间的第一个索引值</span></span><br><span class="line">        insertSort(arr, border);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归实现插入排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> border)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (border == arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextBorder</span> <span class="operator">=</span> border + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (border &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[border - <span class="number">1</span>] &gt; arr[border]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[border - <span class="number">1</span>];</span><br><span class="line">                arr[border - <span class="number">1</span>] = arr[border];</span><br><span class="line">                arr[border] = temp;</span><br><span class="line">                border--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        insertSort(arr, nextBorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="五、多路递归1"><a href="#五、多路递归1" class="headerlink" title="五、多路递归1"></a>五、多路递归1</h1><h2 id="1-详解斐波那契数列"><a href="#1-详解斐波那契数列" class="headerlink" title="1.详解斐波那契数列"></a>1.详解斐波那契数列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上图说话：</p>
<p><img src="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%9B%BE%E8%A7%A3.png"></p>
<p>求f（4）时，需要求解f（3）和f（2），从f（3）开始求解f（2）和f（1），f（2）求f（1）和f（0）…一直多路递归，其实就是<strong>二叉树的后序遍历</strong>。</p>
<p><strong>在多路递归中，拆成几个子问题就是拆成几个叉的数。</strong></p>
<h2 id="2-爬楼梯"><a href="#2-爬楼梯" class="headerlink" title="2.爬楼梯"></a>2.爬楼梯</h2><p>楼梯有n阶，爬到楼顶可以一次跳一阶，也可以一次跳两阶，只能向上走一共多少种爬法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实是斐波那契数列题目的变种。</p>
<p>假设我要爬20阶，无非就是在18阶的时候决定我要怎么跳，19阶的时候我要怎么跳。</p>
<p>在19阶的时候，我只能跨一步，所以爬到19阶的时候只能是f（19），爬到18阶的时候，到20阶有两个选择，第一种，就是18-&gt;19-&gt;20，第二种就是18-&gt;20。但是第一种其实已经包括到19阶的爬法中了，如果18-&gt;19-&gt;20，就相当于19-&gt;20只能跨一步。所以第一种排除，只有第二种，18到20跨两步。所以取决于f(18)的爬楼梯次数。f(n)&#x3D;f(n-1)+f(n-2)。</p>
<p>再回到本篇博客最初的思想，就是从子问题开始分析，我要爬一阶，1种；二阶，2种；三阶，3种；四阶，5种，对子问题寻找规律，也会得到这个式子。</p>
<h1 id="六、优化递归斐波那契数列"><a href="#六、优化递归斐波那契数列" class="headerlink" title="六、优化递归斐波那契数列"></a>六、优化递归斐波那契数列</h1><p><img src="%E4%BC%98%E5%8C%96.png"></p>
<p>在算法中，颜色相同的地方需要重复计算，斐波那契数列本身的时间复杂度也是来到了$$O(n)&#x3D;1.618^n$$指数级别。可以在idea输入大一点的数字试一下，比如n&#x3D;70，代码跑半天结果都没出来，算法复杂度十分糟糕。</p>
<p><strong>现在有如下解决方案：</strong>在第一次需要求解的时候，例如，我在遍历的时候需要第一次计算f（2），算完f（0）和f（1）了以后，得到f（2）的值，将f（2）的值存入数组中，在f（4）需要求f（2）的值的时候，可以直接取到值，不用再让f（2）进行遍历。<strong>这个过程也称为剪枝，也叫记忆化、备忘录。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//假设爬70阶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">70</span>;</span><br><span class="line">        <span class="comment">//数组记录已经递归过的值</span></span><br><span class="line">        <span class="type">int</span>[] cache = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//没递归过的值都是-1</span></span><br><span class="line">        Arrays.fill(cache, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//递归的出口也可以直接赋值，无所谓</span></span><br><span class="line">        cache[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        cache[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        cache[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用递归算结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> f(n, cache);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] cache)</span> &#123;</span><br><span class="line"><span class="comment">//        if (n == 0) &#123;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (n == 1) &#123;</span></span><br><span class="line"><span class="comment">//            return 1;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (n == 2) &#123;</span></span><br><span class="line"><span class="comment">//            return 2;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//取：cache[index]的值不是-1的时候取</span></span><br><span class="line">        <span class="keyword">if</span> (cache[n] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> f(n - <span class="number">1</span>, cache);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> f(n - <span class="number">2</span>, cache);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存：cache[index]的值是-1的时候存；第一次计算出结果的时候存</span></span><br><span class="line">        <span class="keyword">if</span> (cache[n] == -<span class="number">1</span>) &#123;</span><br><span class="line">            cache[n] = x + y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果在数组中，cache[n]是-1，那么说明没有递归过，存进cache数组；如果不是-1，说明递归过这个值了，数组中存过了，直接取数组中的值返回就可以了，不要递归。由于在数组中也存了n&#x3D;0，1,2的值了，也不需要进行if判断了，因为在取的时候可以返回回去</p>
<p>刚刚跑不出来的70阶也跑出来了，$$f（70）&#x3D; 696897233$$</p>
<p>另外，为什么在代码中我们选择使用数组作为缓存的数据结构而不是map集合？那自然是因为cpu的三级缓存和数组存储空间连续性的原因让我们查数组查得比集合要快。可以看主页的另一篇操作系统cpu的文章。</p>
<h1 id="七、优化爆栈"><a href="#七、优化爆栈" class="headerlink" title="七、优化爆栈"></a>七、优化爆栈</h1><h2 id="1-尾调用"><a href="#1-尾调用" class="headerlink" title="1.尾调用"></a>1.尾调用</h2><p>如果函数的最后一步是调用一个函数，则称为尾调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E5%B0%BE%E8%B0%83%E7%94%A82.png"></p>
<p>在Java中，方法的调用都是在栈里面的，一个方法执行完毕后，释放内存，出栈。但是连续的尾调用会导致栈中的方法越来越多的同时不能释放内存，最后导致爆栈，也就是<code>stackoverflowError</code>。</p>
<p>在一些语言中，可以对尾调用进行优化：将代码变成同级关系就可以避免爆栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a();</span><br><span class="line">b();</span><br><span class="line">c();</span><br></pre></td></tr></table></figure>

<p>再来思考为什么对函数进行操作比如b()+1不行？</p>
<p>因为必须要等b返回以后才能进行+1，仍然是a嵌套b的关系，但是如果不存在的话，a只管a的逻辑处理，b也只管b的逻辑处理，可以优化尾调用</p>
<h2 id="2-尾递归"><a href="#2-尾递归" class="headerlink" title="2.尾递归"></a>2.尾递归</h2><p>尾递归是尾调用的一种特殊情况。无非就是方法调用的是自己。在java中，不存在尾调用的优化（就是不能把方法从嵌套改为并列关系），所以只能使用其他语言。能实现的语言有：c++、scala。在idea中可以安装scala的插件使用scala的语法。</p>
<p>由于在java中会存在爆栈问题，因此解决的方案就是将递归改为循环。</p>
<h1 id="八、多路递归2"><a href="#八、多路递归2" class="headerlink" title="八、多路递归2"></a>八、多路递归2</h1><h2 id="1-汉诺塔"><a href="#1-汉诺塔" class="headerlink" title="1.汉诺塔"></a>1.汉诺塔</h2><p><img src="%E6%B1%89%E8%AF%BA%E5%A1%94.png"></p>
<h3 id="1-1-图解："><a href="#1-1-图解：" class="headerlink" title="1.1 图解："></a>1.1 图解：</h3><p><img src="%E6%B1%89%E8%AF%BA%E5%A1%941.png"></p>
<p><img src="%E6%B1%89%E8%AF%BA%E5%A1%942.png"></p>
<p><img src="%E6%B1%89%E8%AF%BA%E5%A1%943.png"></p>
<h3 id="1-2-多叉树："><a href="#1-2-多叉树：" class="headerlink" title="1.2 多叉树："></a>1.2 多叉树：</h3><p><img src="%E6%B1%89%E8%AF%BA%E5%A1%944.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//三根柱子</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; list3 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//圆盘个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> number; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            list1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">        remove(number, list1, list2, list3);</span><br><span class="line">        System.out.println(<span class="string">&quot;=================================&quot;</span>);</span><br><span class="line">        System.out.println(list3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> n, LinkedList&lt;Integer&gt; list1, LinkedList&lt;Integer&gt; list2, LinkedList&lt;Integer&gt; list3)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 当只剩下一个圆盘时，直接从list1移动到list3</span></span><br><span class="line">            list3.add(list1.removeLast());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 递归地将n-1个圆盘从list1移动到list2，使用list3作为辅助</span></span><br><span class="line">            remove(n - <span class="number">1</span>, list1, list3, list2);</span><br><span class="line">            print(list1, list2, list3);</span><br><span class="line">            <span class="comment">// 将list1上剩下的最大圆盘移动到list3</span></span><br><span class="line">            list3.add(list1.removeLast());</span><br><span class="line">            print(list1, list2, list3);</span><br><span class="line">            <span class="comment">// 递归地将list2上的n-1个圆盘移动到list3</span></span><br><span class="line">            remove(n - <span class="number">1</span>, list2, list1, list3);</span><br><span class="line">            print(list1, list2, list3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(LinkedList&lt;Integer&gt; list1, LinkedList&lt;Integer&gt; list2, LinkedList&lt;Integer&gt; list3)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">        System.out.println(list2);</span><br><span class="line">        System.out.println(list3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-杨辉三角"><a href="#2-杨辉三角" class="headerlink" title="2.杨辉三角"></a>2.杨辉三角</h2><p>好经典的题目了，这里直接上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(element(<span class="number">1</span>, <span class="number">1</span>));<span class="comment">//1</span></span><br><span class="line">        System.out.println(element(<span class="number">1</span>, <span class="number">2</span>));<span class="comment">//0</span></span><br><span class="line">        System.out.println(element(<span class="number">5</span>, <span class="number">2</span>));<span class="comment">//4</span></span><br><span class="line">        System.out.println(element(<span class="number">5</span>, <span class="number">3</span>));<span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">element</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 找规律</span></span><br><span class="line">        <span class="comment">// 如果都是第一列，j的值都是1</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//杨辉三角往左边拉直以后，列数不会比行数多</span></span><br><span class="line">        <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//行等于列的时候，元素上方不存在元素</span></span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span> element(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//正常的三角内元素，直接遍历</span></span><br><span class="line">            <span class="keyword">return</span> element(i - <span class="number">1</span>, j - <span class="number">1</span>) + element(i - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在已经可以求出对应行对应列的值了，接下来就是打印三角形</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(element(1, 1));//1</span></span><br><span class="line"><span class="comment">//        System.out.println(element(1, 2));//0</span></span><br><span class="line"><span class="comment">//        System.out.println(element(5, 2));//4</span></span><br><span class="line"><span class="comment">//        System.out.println(element(5, 3));//6</span></span><br><span class="line">        print(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">element</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// 找规律</span></span><br><span class="line">        <span class="comment">// 如果都是第一列，j的值都是1</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//杨辉三角往左边拉直以后，列数不会比行数多</span></span><br><span class="line">        <span class="keyword">if</span> (j &gt; i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//行等于列的时候，元素上方不存在元素</span></span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span> element(i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//正常的三角内元素，直接遍历</span></span><br><span class="line">            <span class="keyword">return</span> element(i - <span class="number">1</span>, j - <span class="number">1</span>) + element(i - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">1</span>; row &lt;= i; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> <span class="number">1</span>; column &lt;= row; column++) &#123;</span><br><span class="line">                System.out.print(element(row, column) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E4%B8%89%E8%A7%921.png"></p>
<p>此时三角形还是不正的，优化一下打印的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">1</span>; row &lt;= i; row++) &#123;</span><br><span class="line">           printSpace(i, row);</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">column</span> <span class="operator">=</span> <span class="number">1</span>; column &lt;= row; column++) &#123;</span><br><span class="line">               System.out.printf(<span class="string">&quot;%-4d&quot;</span>, element(row, column));</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSpace</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span> * (n - i);</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= num; j++) &#123;</span><br><span class="line">           System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E4%B8%89%E8%A7%922.png"></p>
<h2 id="3-优化杨辉三角"><a href="#3-优化杨辉三角" class="headerlink" title="3.优化杨辉三角"></a>3.优化杨辉三角</h2><p>可以看到，其实杨辉三角中进行递归的时候还是有重复的流程的，和斐波那契数列一样</p>
<p><img src="%E4%B8%89%E8%A7%923.png"></p>
<p>两个10其实都需要上面的6，然而原本的方法是直接不断递归，没有像类似斐波那契数列用数组存储避免递归。而在这个地方也可以使用二维数组的记忆法去避免递归，这里略了，参考黑马算法p67,68。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
