<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker：速速上手docker部署镜像</title>
    <url>/2024/07/06/Docker%E5%AE%9E%E6%93%8D/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h1 id="1-初识Docker"><a href="#1-初识Docker" class="headerlink" title="1.初识Docker"></a>1.初识Docker</h1><h2 id="1-1-什么是Docker"><a href="#1-1-什么是Docker" class="headerlink" title="1.1.什么是Docker"></a>1.1.什么是Docker</h2><p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p>
<ul>
<li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li>
<li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li>
</ul>
<h3 id="1-1-1-应用部署的环境问题"><a href="#1-1-1-应用部署的环境问题" class="headerlink" title="1.1.1.应用部署的环境问题"></a>1.1.1.应用部署的环境问题</h3><p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>
<ul>
<li><p>依赖关系复杂，容易出现兼容性问题</p>
</li>
<li><p>开发、测试、生产环境有差异</p>
</li>
</ul>
<p><img src="image-20210731141907366-17202512119731.png"></p>
<p>例如一个项目中，部署时需要依赖于node.js、Redis、RabbitMQ、MySQL等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p>
<h3 id="1-1-2-Docker解决依赖兼容问题"><a href="#1-1-2-Docker解决依赖兼容问题" class="headerlink" title="1.1.2.Docker解决依赖兼容问题"></a>1.1.2.Docker解决依赖兼容问题</h3><p>而Docker确巧妙的解决了这些问题，Docker是如何实现的呢？</p>
<p>Docker为了解决依赖的兼容问题的，采用了两个手段：</p>
<ul>
<li><p>将应用的Libs（函数库）、Deps（依赖）、配置与应用一起打包</p>
</li>
<li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p>
</li>
</ul>
<p><img src="image-20210731142219735-17202512390553.png"></p>
<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p>
<p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p>
<h3 id="1-1-3-Docker解决操作系统环境差异"><a href="#1-1-3-Docker解决操作系统环境差异" class="headerlink" title="1.1.3.Docker解决操作系统环境差异"></a>1.1.3.Docker解决操作系统环境差异</h3><p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。以一个Ubuntu操作系统为例，结构如下：</p>
<p><img src="image-20210731143401460-17202512515745.png"></p>
<p>结构包括：</p>
<ul>
<li>计算机硬件：例如CPU、内存、磁盘等</li>
<li>系统内核：所有Linux发行版的内核都是Linux，例如CentOS、Ubuntu、Fedora等。内核可以与计算机硬件交互，对外提供<strong>内核指令</strong>，用于操作计算机硬件。</li>
<li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li>
</ul>
<p>应用于计算机交互的流程如下：</p>
<p>1）应用调用操作系统应用（函数库），实现各种功能</p>
<p>2）系统函数库是对内核指令集的封装，会调用内核指令</p>
<p>3）内核指令操作计算机硬件</p>
<p>Ubuntu和CentOSpringBoot都是基于Linux内核，无非是系统应用不同，提供的函数库有差异：</p>
<p><img src="image-20210731144304990-17202512906267.png"></p>
<p>此时，如果将一个Ubuntu版本的MySQL应用安装到CentOS系统，MySQL在调用Ubuntu函数库时，会发现找不到或者不匹配，就会报错了：</p>
<p><img src="image-20210731144458680-17202513039019.png"></p>
<p>Docker如何解决不同系统环境的问题？</p>
<ul>
<li>Docker将用户程序与所需要调用的系统(比如Ubuntu)函数库一起打包</li>
<li>Docker运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的Linux内核来运行</li>
</ul>
<p>如图：</p>
<p><img src="image-20210731144820638-172025131387611.png"></p>
<h3 id="1-1-4-小结"><a href="#1-1-4-小结" class="headerlink" title="1.1.4.小结"></a>1.1.4.小结</h3><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>
<ul>
<li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>
<li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>
</ul>
<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>
<ul>
<li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li>
</ul>
<p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p>
<ul>
<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li>
<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>
<li>启动、移除都可以通过一行命令完成，方便快捷</li>
</ul>
<h2 id="1-2-Docker和虚拟机的区别"><a href="#1-2-Docker和虚拟机的区别" class="headerlink" title="1.2.Docker和虚拟机的区别"></a>1.2.Docker和虚拟机的区别</h2><p>Docker可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>
<p>两者有什么差异呢？</p>
<p><strong>虚拟机</strong>（virtual machine）是在操作系统中<strong>模拟</strong>硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的Ubuntu应用了。</p>
<p><strong>Docker</strong>仅仅是封装函数库，并没有模拟完整的操作系统，如图：</p>
<p><img src="image-20210731145914960-172025132358913.png"></p>
<p>对比来看：</p>
<p><img src="image-20210731152243765-172025133336715.png"></p>
<p>小结：</p>
<p>Docker和虚拟机的差异：</p>
<ul>
<li><p>docker是一个系统进程；虚拟机是在操作系统中的操作系统</p>
</li>
<li><p>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p>
</li>
</ul>
<h2 id="1-3-Docker架构"><a href="#1-3-Docker架构" class="headerlink" title="1.3.Docker架构"></a>1.3.Docker架构</h2><h3 id="1-3-1-镜像和容器"><a href="#1-3-1-镜像和容器" class="headerlink" title="1.3.1.镜像和容器"></a>1.3.1.镜像和容器</h3><p>Docker中有几个重要的概念：</p>
<p><strong>镜像（Image）</strong>：Docker将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</p>
<p><strong>容器（Container）</strong>：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是Docker会给容器进程做隔离，对外不可见。</p>
<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>
<p>而<strong>镜像</strong>，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</p>
<p><strong>容器</strong>呢，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。因此一个镜像可以启动多次，形成多个容器进程。</p>
<p><img src="image-20210731153059464-172025134110517.png"></p>
<p>例如你下载了一个QQ，如果我们将QQ在磁盘上的运行<strong>文件</strong>及其运行的操作系统依赖打包，形成QQ镜像。然后你可以启动多次，双开、甚至三开QQ，跟多个妹子聊天。</p>
<h3 id="1-3-2-DockerHub"><a href="#1-3-2-DockerHub" class="headerlink" title="1.3.2.DockerHub"></a>1.3.2.DockerHub</h3><p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如Redis、MySQL镜像放到网络上，共享使用，就像GitHub的代码共享一样。</p>
<ul>
<li><p>DockerHub：DockerHub是一个官方的Docker镜像的托管平台。这样的平台称为Docker Registry。</p>
</li>
<li><p>国内也有类似于DockerHub 的公开服务，比如 <a href="https://c.163yun.com/hub">网易云镜像服务</a>、<a href="https://cr.console.aliyun.com/">阿里云镜像库</a>等。</p>
</li>
</ul>
<p>我们一方面可以将自己的镜像共享到DockerHub，另一方面也可以从DockerHub拉取镜像：</p>
<p><img src="image-20210731153743354-172025135047219.png"></p>
<h3 id="1-3-3-Docker架构"><a href="#1-3-3-Docker架构" class="headerlink" title="1.3.3.Docker架构"></a>1.3.3.Docker架构</h3><p>我们要使用Docker来操作镜像、容器，就必须要安装Docker。</p>
<p>Docker是一个CS架构的程序，由两部分组成：</p>
<ul>
<li><p>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等</p>
</li>
<li><p>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</p>
</li>
</ul>
<p>如图：</p>
<p><img src="image-20210731154257653-172025136278221.png"></p>
<h3 id="1-3-4-小结"><a href="#1-3-4-小结" class="headerlink" title="1.3.4.小结"></a>1.3.4.小结</h3><p>镜像：</p>
<ul>
<li>将应用程序及其依赖、环境、配置打包在一起</li>
</ul>
<p>容器：</p>
<ul>
<li>镜像运行起来就是容器，一个镜像可以运行多个容器</li>
</ul>
<p>Docker结构：</p>
<ul>
<li><p>服务端：接收命令或远程请求，操作镜像或容器</p>
</li>
<li><p>客户端：发送命令或者请求到Docker服务端</p>
</li>
</ul>
<p>DockerHub：</p>
<ul>
<li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li>
</ul>
<h2 id="1-4-安装Docker"><a href="#1-4-安装Docker" class="headerlink" title="1.4.安装Docker"></a>1.4.安装Docker</h2><p>企业部署一般都是采用Linux操作系统，而其中又数CentOS发行版占比最多，因此我们在CentOS下安装Docker。参考我的另外一篇博客。</p>
<h1 id="2-Docker的基本操作"><a href="#2-Docker的基本操作" class="headerlink" title="2.Docker的基本操作"></a>2.Docker的基本操作</h1><h2 id="2-1-镜像操作"><a href="#2-1-镜像操作" class="headerlink" title="2.1.镜像操作"></a>2.1.镜像操作</h2><h3 id="2-1-1-镜像名称"><a href="#2-1-1-镜像名称" class="headerlink" title="2.1.1.镜像名称"></a>2.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p>
<ul>
<li>镜名称一般分两部分组成：[repository]:[tag]。</li>
<li>在没有指定tag时，默认是latest，代表最新版本的镜像</li>
</ul>
<p>如图：</p>
<p><img src="image-20210731155141362-172025139335023.png"></p>
<p>这里的mysql就是repository，5.7就是tag，合一起就是镜像名称，代表5.7版本的MySQL镜像。</p>
<h3 id="2-1-2-镜像命令"><a href="#2-1-2-镜像命令" class="headerlink" title="2.1.2.镜像命令"></a>2.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p>
<p><img src="image-20210731155649535-172025140269125.png"></p>
<h3 id="2-1-3-案例1-拉取、查看镜像"><a href="#2-1-3-案例1-拉取、查看镜像" class="headerlink" title="2.1.3.案例1-拉取、查看镜像"></a>2.1.3.案例1-拉取、查看镜像</h3><p>需求：从DockerHub中拉取一个nginx镜像并查看</p>
<p>1）首先去镜像仓库搜索nginx镜像，比如<a href="https://hub.docker.com/">DockerHub</a>:</p>
<p><img src="image-20210731155844368-172025141331627.png"></p>
<p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p>
<p><img src="image-20210731155856199-172025142614029.png"></p>
<p>3）通过命令：docker images 查看拉取到的镜像</p>
<p><img src="image-20210731155903037-172025143514131.png"></p>
<h3 id="2-1-4-案例2-保存、导入镜像"><a href="#2-1-4-案例2-保存、导入镜像" class="headerlink" title="2.1.4.案例2-保存、导入镜像"></a>2.1.4.案例2-保存、导入镜像</h3><p>需求：利用docker save将nginx镜像导出磁盘，然后再通过load加载回来</p>
<p>1）利用docker xx –help命令查看docker save和docker load的语法</p>
<p>例如，查看save命令用法，可以输入命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="image-20210731161104732-172025144806833.png"></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save -o [保存的目标文件名称] [镜像名称]</span><br></pre></td></tr></table></figure>



<p>2）使用docker save导出镜像到磁盘 </p>
<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save -o nginx.tar nginx:latest</span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="image-20210731161354344-172025149206737.png"></p>
<p>3）使用docker load加载镜像</p>
<p>先删除本地的nginx镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi nginx:latest</span><br></pre></td></tr></table></figure>



<p>然后运行命令，加载本地文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load -i nginx.tar</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="image-20210731161746245-172025150212339.png"></p>
<h2 id="2-2-容器操作"><a href="#2-2-容器操作" class="headerlink" title="2.2.容器操作"></a>2.2.容器操作</h2><h3 id="2-2-1-容器相关命令"><a href="#2-2-1-容器相关命令" class="headerlink" title="2.2.1.容器相关命令"></a>2.2.1.容器相关命令</h3><p>容器操作的命令如图：</p>
<p><img src="image-20210731161950495-172025151425541.png"></p>
<p>容器保护三个状态：</p>
<ul>
<li>运行：进程正常运行</li>
<li>暂停：进程暂停，CPU不再运行，并不释放内存</li>
<li>停止：进程终止，回收进程占用的内存、CPU等资源</li>
</ul>
<p>其中：</p>
<ul>
<li><p>docker run：创建并运行一个容器，处于运行状态</p>
</li>
<li><p>docker pause：让一个运行的容器暂停</p>
</li>
<li><p>docker unpause：让一个容器从暂停状态恢复运行</p>
</li>
<li><p>docker stop：停止一个运行的容器</p>
</li>
<li><p>docker start：让一个停止的容器再次运行</p>
</li>
<li><p>docker rm：删除一个容器</p>
</li>
</ul>
<h3 id="2-2-2-案例-创建并运行一个容器"><a href="#2-2-2-案例-创建并运行一个容器" class="headerlink" title="2.2.2.案例-创建并运行一个容器"></a>2.2.2.案例-创建并运行一个容器</h3><p>创建并运行nginx容器的命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li>docker run ：创建并运行一个容器</li>
<li>–name : 给容器起一个名字，比如叫做mn</li>
<li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>
<li>-d：后台运行容器</li>
<li>nginx：镜像名称，例如nginx</li>
</ul>
<p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p>
<p>默认情况下，容器是隔离环境，我们直接访问宿主机的80端口，肯定访问不到容器中的nginx。</p>
<p>现在，将容器的80与宿主机的80关联起来，当我们访问宿主机的80端口时，就会被映射到容器的80，这样就能访问到nginx了：</p>
<p><img src="image-20210731163255863-172025152437243.png"></p>
<h3 id="2-2-3-案例-进入容器，修改文件"><a href="#2-2-3-案例-进入容器，修改文件" class="headerlink" title="2.2.3.案例-进入容器，修改文件"></a>2.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入Nginx容器，修改HTML文件内容，添加“传智教育欢迎您”</p>
<p><strong>提示</strong>：进入容器要用到docker exec命令。</p>
<p><strong>步骤</strong>：</p>
<p>1）进入容器。进入我们刚刚创建的nginx容器的命令为：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it mn bash</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li><p>docker exec ：进入容器内部，执行一个命令</p>
</li>
<li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p>
</li>
<li><p>mn ：要进入的容器的名称</p>
</li>
<li><p>bash：进入容器后执行的命令，bash是一个linux终端交互命令</p>
</li>
</ul>
<p>2）进入nginx的HTML所在目录 &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</p>
<p>容器内部会模拟一个独立的Linux文件系统，看起来如同一个linux服务器一样：</p>
<p><img src="image-20210731164159811-172025153479945.png"></p>
<p>nginx的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的html文件。</p>
<p>查看DockerHub网站中的nginx页面，可以知道nginx的html目录位置在<code>/usr/share/nginx/html</code></p>
<p>我们执行命令，进入该目录：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/nginx/html</span><br></pre></td></tr></table></figure>

<p> 查看目录下文件：</p>
<p><img src="image-20210731164455818-172025154570447.png"></p>
<p>3）修改index.html的内容</p>
<p>容器内没有vi命令，无法直接修改，我们用下面的命令来修改：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sed -i -e <span class="string">&#x27;s#Welcome to nginx#传智教育欢迎您#g&#x27;</span> -e <span class="string">&#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#x27;</span> index.html</span><br></pre></td></tr></table></figure>



<p>在浏览器访问自己的虚拟机地址，例如我的是：<a href="http://192.168.150.101，即可看到结果：">http://192.168.150.101，即可看到结果：</a></p>
<p><img src="image-20210731164717604-172025155924049.png"></p>
<h3 id="2-2-4-小结"><a href="#2-2-4-小结" class="headerlink" title="2.2.4.小结"></a>2.2.4.小结</h3><p>docker run命令的常见参数有哪些？</p>
<ul>
<li>–name：指定容器名称</li>
<li>-p：指定端口映射</li>
<li>-d：让容器后台运行</li>
</ul>
<p>查看容器日志的命令：</p>
<ul>
<li>docker logs</li>
<li>添加 -f 参数可以持续查看日志</li>
</ul>
<p>查看容器状态：</p>
<ul>
<li>docker ps</li>
<li>docker ps -a 查看所有容器，包括已经停止的</li>
</ul>
<h2 id="2-3-数据卷（容器数据管理）"><a href="#2-3-数据卷（容器数据管理）" class="headerlink" title="2.3.数据卷（容器数据管理）"></a>2.3.数据卷（容器数据管理）</h2><p>在之前的nginx案例中，修改nginx的html页面时，需要进入nginx内部。并且因为没有编辑器，修改文件也很麻烦。</p>
<p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p>
<p><img src="image-20210731172440275-172025157161351.png"></p>
<p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>
<h3 id="2-3-1-什么是数据卷"><a href="#2-3-1-什么是数据卷" class="headerlink" title="2.3.1.什么是数据卷"></a>2.3.1.什么是数据卷</h3><p><strong>数据卷（volume）</strong>是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>
<p><img src="image-20210731173541846-172025159346453.png"></p>
<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p>
<p>这样，我们操作宿主机的&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;html目录，就等于操作容器内的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html目录了</p>
<h3 id="2-3-2-数据集操作命令"><a href="#2-3-2-数据集操作命令" class="headerlink" title="2.3.2.数据集操作命令"></a>2.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>

<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>
<ul>
<li>create 创建一个volume</li>
<li>inspect 显示一个或多个volume的信息</li>
<li>ls 列出所有的volume</li>
<li>prune 删除未使用的volume</li>
<li>rm 删除一个或多个指定的volume</li>
</ul>
<h3 id="2-3-3-创建和查看数据卷"><a href="#2-3-3-创建和查看数据卷" class="headerlink" title="2.3.3.创建和查看数据卷"></a>2.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p>
<p>① 创建数据卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume create html</span><br></pre></td></tr></table></figure>



<p>② 查看所有数据</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="image-20210731173746910-172025160602555.png"></p>
<p>③ 查看数据卷详细信息卷</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker volume inspect html</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="image-20210731173809877-172025161650357.png"></p>
<p>可以看到，我们创建的html这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p>
<p><strong>小结</strong>：</p>
<p>数据卷的作用：</p>
<ul>
<li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li>
</ul>
<p>数据卷操作：</p>
<ul>
<li>docker volume create：创建数据卷</li>
<li>docker volume ls：查看所有数据卷</li>
<li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li>
<li>docker volume rm：删除指定数据卷</li>
<li>docker volume prune：删除所有未使用的数据卷</li>
</ul>
<h3 id="2-3-4-挂载数据卷"><a href="#2-3-4-挂载数据卷" class="headerlink" title="2.3.4.挂载数据卷"></a>2.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  --name mn \</span><br><span class="line">  -v html:/root/html \</span><br><span class="line">  -p 8080:80</span><br><span class="line">  nginx \</span><br></pre></td></tr></table></figure>

<p>这里的-v就是挂载数据卷的命令：</p>
<ul>
<li><code>-v html:/root/htm</code> ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中</li>
</ul>
<h3 id="2-3-5-案例-给nginx挂载数据卷"><a href="#2-3-5-案例-给nginx挂载数据卷" class="headerlink" title="2.3.5.案例-给nginx挂载数据卷"></a>2.3.5.案例-给nginx挂载数据卷</h3><p><strong>需求</strong>：创建一个nginx容器，修改容器内的html目录内的index.html内容</p>
<p><strong>分析</strong>：上个案例中，我们进入nginx容器内部，已经知道nginx的html目录所在位置&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html ，我们需要把这个目录挂载到html这个数据卷上，方便操作其中的内容。</p>
<p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p>
<p>步骤：</p>
<p>① 创建容器并挂载数据卷到容器内的HTML目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>



<p>② 进入html数据卷所在位置，并修改HTML内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看html数据卷的位置</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 进入该目录</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vi index.html</span><br></pre></td></tr></table></figure>



<h3 id="2-3-6-案例-给MySQL挂载本地目录"><a href="#2-3-6-案例-给MySQL挂载本地目录" class="headerlink" title="2.3.6.案例-给MySQL挂载本地目录"></a>2.3.6.案例-给MySQL挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p>
<ul>
<li>带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录</li>
<li>直接挂载模式：宿主机目录 —&gt; 容器内目录</li>
</ul>
<p>如图：</p>
<p><img src="image-20210731175155453-172025163822859.png"></p>
<p><strong>语法</strong>：</p>
<p>目录挂载与数据卷挂载的语法是类似的：</p>
<ul>
<li>-v [宿主机目录]:[容器内目录]</li>
<li>-v [宿主机文件]:[容器内文件]</li>
</ul>
<p><strong>需求</strong>：创建并运行一个MySQL容器，将宿主机目录直接挂载到容器</p>
<p>实现思路如下：</p>
<p>1）在将课前资料中的mysql.tar文件上传到虚拟机，通过load命令加载为镜像</p>
<p>2）创建目录&#x2F;tmp&#x2F;mysql&#x2F;data</p>
<p>3）创建目录&#x2F;tmp&#x2F;mysql&#x2F;conf，将课前资料提供的hmy.cnf文件上传到&#x2F;tmp&#x2F;mysql&#x2F;conf</p>
<p>4）去DockerHub查阅资料，创建并运行MySQL容器，要求：</p>
<p>① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录</p>
<p>② 挂载&#x2F;tmp&#x2F;mysql&#x2F;conf&#x2F;hmy.cnf到mysql容器的配置文件</p>
<p>③ 设置MySQL密码</p>
<h3 id="2-3-7-小结"><a href="#2-3-7-小结" class="headerlink" title="2.3.7.小结"></a>2.3.7.小结</h3><p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p>
<ul>
<li>-v volume名称:容器内目录</li>
<li>-v 宿主机文件:容器内文</li>
<li>-v 宿主机目录:容器内目录</li>
</ul>
<p>数据卷挂载与目录直接挂载的</p>
<ul>
<li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li>
<li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li>
</ul>
<h1 id="3-Dockerfile自定义镜像"><a href="#3-Dockerfile自定义镜像" class="headerlink" title="3.Dockerfile自定义镜像"></a>3.Dockerfile自定义镜像</h1><p>常见的镜像在DockerHub就能找到，但是我们自己写的项目就必须自己构建镜像了。</p>
<p>而要自定义镜像，就必须先了解镜像的结构才行。</p>
<h2 id="3-1-镜像结构"><a href="#3-1-镜像结构" class="headerlink" title="3.1.镜像结构"></a>3.1.镜像结构</h2><p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>
<p>我们以MySQL为例，来看看镜像的组成结构：</p>
<p><img src="image-20210731175806273-172025168205161.png"></p>
<p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p>
<p>我们要构建镜像，其实就是实现上述打包的过程。</p>
<h2 id="3-2-Dockerfile语法"><a href="#3-2-Dockerfile语法" class="headerlink" title="3.2.Dockerfile语法"></a>3.2.Dockerfile语法</h2><p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p>
<p>我们只需要告诉Docker，我们的镜像的组成，需要哪些BaseImage、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来Docker会帮助我们构建镜像。</p>
<p>而描述上述信息的文件就是Dockerfile文件。</p>
<p><strong>Dockerfile</strong>就是一个文本文件，其中包含一个个的**指令(Instruction)**，用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层Layer。</p>
<p><img src="image-20210731180321133-172025169038663.png"></p>
<p>更新详细语法说明，请参考官网文档： <a href="https://docs.docker.com/engine/reference/builder">https://docs.docker.com/engine/reference/builder</a></p>
<h2 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3.小结"></a>3.3.小结</h2><p>小结：</p>
<ol>
<li><p>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</p>
</li>
<li><p>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</p>
</li>
<li><p>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p>
</li>
</ol>
<h1 id="4-Docker-Compose"><a href="#4-Docker-Compose" class="headerlink" title="4.Docker-Compose"></a>4.Docker-Compose</h1><h2 id="4-1-dockerCompose介绍"><a href="#4-1-dockerCompose介绍" class="headerlink" title="4.1 dockerCompose介绍"></a>4.1 dockerCompose介绍</h2><p>Compose文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">version<span class="punctuation">:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"> services<span class="punctuation">:</span></span><br><span class="line">  mysql<span class="punctuation">:</span></span><br><span class="line">    image<span class="punctuation">:</span> mysql<span class="punctuation">:</span><span class="number">5.7</span><span class="number">.25</span></span><br><span class="line">    environment<span class="punctuation">:</span></span><br><span class="line">     MYSQL_ROOT_PASSWORD<span class="punctuation">:</span> <span class="number">123</span> </span><br><span class="line">    volumes<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">     - <span class="string">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span></span><br><span class="line">  web<span class="punctuation">:</span></span><br><span class="line">    build<span class="punctuation">:</span> .</span><br><span class="line">    ports<span class="punctuation">:</span></span><br><span class="line">     - <span class="string">&quot;8090:8090&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的Compose文件就描述一个项目，其中包含两个容器：</p>
<ul>
<li>mysql：一个基于<code>mysql:5.7.25</code>镜像构建的容器，并且挂载了两个目录</li>
<li>web：一个基于<code>docker build</code>临时构建的镜像容器，映射端口时8090</li>
</ul>
<p>DockerCompose的详细语法参考官网：<a href="https://docs.docker.com/compose/compose-file/">https://docs.docker.com/compose/compose-file/</a></p>
<p>其实DockerCompose文件可以看做是将多个docker run命令写到一个文件，只是语法稍有差异。</p>
<p>​                         </p>
<h2 id="4-2-dockerCompose案例（没做实操）"><a href="#4-2-dockerCompose案例（没做实操）" class="headerlink" title="4.2 dockerCompose案例（没做实操）"></a>4.2 dockerCompose案例（没做实操）</h2><p>dockerCompose底层可以直接使用服务名称连接到对应微服务而不是用地址，比如配置nacos的地址，在Java的application.yml文件的spring的addr中配置之前写的是localhost：10086，但是其他主机访问不到。dockerCompose能够使用服务名称跨设备访问微服务。nacos：10086。</p>
<p> <img src="Composedemo-172025204419373.png"></p>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>软件技术</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC：Java语言连接数据库</title>
    <url>/2024/07/06/JDBC%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="一、-什么是JDBC"><a href="#一、-什么是JDBC" class="headerlink" title="一、 什么是JDBC"></a>一、 什么是JDBC</h1><p><em>JDBC（Java DataBase Connectivity）</em>是Java数据库连接技术的简称，提供连接和操作各种常用数据库的能力，JDBC只定义了Java应用程序访问数据库的标准接口层，而对于不同的数据库而言则由数据库厂商去实现JDBC接口层的功能 （叫做数据库驱动程序包）。</p>
<h1 id="二、-JDBC工作原理"><a href="#二、-JDBC工作原理" class="headerlink" title="二、  JDBC工作原理"></a>二、  JDBC工作原理</h1><p><img src="image-20230509201759580-3634684.png"></p>
<p>JDBC驱动程序包实际上是对JDK jdbc api的具体实现。可以理解成JDBC只定义了与数据库通信的规范和协议，而这些规范的具体实现由各数据库厂商自己实现也只有数据库厂商才知道怎样操作自己的数据库。</p>
<p><img src="image-20230509201842721-3634725.png"></p>
<h1 id="三、-JDBC访问数据库的步骤"><a href="#三、-JDBC访问数据库的步骤" class="headerlink" title="三、  JDBC访问数据库的步骤"></a>三、  JDBC访问数据库的步骤</h1><p>准备工作：把驱动程序包<em>mysql-connector-j-8.2.0.jar</em>引入<strong>项目依赖</strong>，</p>
<p><em>Project Structure</em> —&gt;选中<em>module</em> —&gt; <em>Dependency</em> —&gt;点击右侧<em>”+”</em>号添加依赖库。</p>
<ol>
<li><p>注册数据库动程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/scott&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">USERNAME</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">PASSWORD</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//1. 注册数据库动程序</span></span><br><span class="line">  Class.forName(DRIVER);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">  System.err.println(<span class="string">&quot;注册数据库驱动失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>java.sql.DriverManager</code> 获得数据库连接 <code>java.sql.Connection</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line"><span class="comment">//2. 通过`java.sql.DriverManager` 获得数据库连接 `java.sql.Connection`</span></span><br><span class="line">conn = DriverManager.getConnection(URL, USERNAME, PASSWORD);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>java.sql.Connection</code> 创建语句对象 <code>java.sql.Statement</code> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//3. 通过 `java.sql.Connection` 创建语句对象 `java.sql.Statement`</span></span><br><span class="line">stmt = conn.createStatement();</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 SQL 语句</p>
<ul>
<li><p><strong>select 查询</strong>：<em>java.sql.ResultSet  statement.exceuteQuery( sql : String )</em> 返回结果集对象</p>
</li>
<li><p><strong>insert, update, delete 语句</strong>：<em>int  statement.executeUpate( sql : String )</em> 返回整数，此操作数据库影响的行数。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"> <span class="comment">//4.执行 SQL 语句获得结果集对象</span></span><br><span class="line">rs = stmt.executeQuery(<span class="string">&quot;select * from emp&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历查询结果集 <code>java.sql.ResultSet</code>（select 操作）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 遍历查询结果集 `java.sql.ResultSet`（select 操作）</span></span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123; <span class="comment">//遍历每一行</span></span><br><span class="line">  <span class="comment">//取每一列</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">empno</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;empno&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">ename</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;ename&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">job</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;job&quot;</span>);</span><br><span class="line">  <span class="type">int</span> <span class="variable">mgr</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;mgr&quot;</span>);</span><br><span class="line">  <span class="type">Date</span> <span class="variable">hiredate</span> <span class="operator">=</span> rs.getDate(<span class="string">&quot;hiredate&quot;</span>);</span><br><span class="line">  <span class="type">double</span> <span class="variable">sal</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;sal&quot;</span>);</span><br><span class="line">  <span class="type">double</span> <span class="variable">comm</span> <span class="operator">=</span> rs.getDouble(<span class="string">&quot;comm&quot;</span>);</span><br><span class="line">  <span class="type">int</span> <span class="variable">deptno</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;deptno&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(empno, ename, job, mgr, hiredate, sal, comm, deptno);</span><br><span class="line">  employees.add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 <code>java.sql.ResultSet</code>、<code>java.sql.Statement</code>、<code>java.sql.Connection</code> 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ......</span><br><span class="line">&#125; <span class="keyword">catch</span>(SQLException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//6. 关闭 `java.sql.ResultSet`、`java.sql.Statement`、`java.sql.Connection` 对象</span></span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">      rs.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">      stmt.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">      conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;关闭数据资源失败！&quot;</span> + e.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img src="image-20230509201950686-3634794.png"></p>
<blockquote>
<p><strong>注意：</strong></p>
<p>注册数据驱动只需在整个项目运行时注册一次即可。不需要每次获取<code>Connection</code> 时都去注册驱动。注册数据库驱动程序后其它的类再去访问数据库时 JVM 就能找得到数据库驱动了，所以通常把注册驱动的代码写在某个类的*static{ ….. }*静态初始化块中。</p>
</blockquote>
<h3 id="3-1-各数据库-URL"><a href="#3-1-各数据库-URL" class="headerlink" title="3.1 各数据库 URL"></a>3.1 各数据库 URL</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//url格式：协议:子协议:主机:port:数据库</span></span><br><span class="line"><span class="comment">//SQL Server</span></span><br><span class="line"><span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:sqlserver://localhost:1433;DatabaseName=数据库名&quot;</span>;</span><br><span class="line"><span class="comment">//Oracle</span></span><br><span class="line"><span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:oracle:thin:@localhost:1521:ORCL(实例名,SID)&quot;</span>;</span><br><span class="line"><span class="comment">//MySQL</span></span><br><span class="line"><span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/数据库名?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai&quot;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="四、-JDBC-API-类"><a href="#四、-JDBC-API-类" class="headerlink" title="四、 JDBC API 类"></a>四、 JDBC API 类</h1><h2 id="4-1-Connection常用方法"><a href="#4-1-Connection常用方法" class="headerlink" title="4.1 Connection常用方法"></a>4.1 Connection常用方法</h2><ol>
<li><p><code>close()</code>：立即释放此 Connection 对象的数据库和 JDBC 资源，而不是等待它们被自动释放。</p>
</li>
<li><p><code>commit()</code> ：提交SQL操作，默认是自动提交SQL操作，很少情况需要手动提交。</p>
</li>
<li><p>createStatement() ：创建一个 Statement (普通语句)对象并将 SQL 语句发送到数据库去执行。</p>
</li>
<li><p><code>prepareStatement(String sql)</code>：创建一个 <code>PreparedStatement</code>(预编译语句) 对象来将参数化的 SQL 语句发送到数据库，其后对<strong>占位符</strong>设置参数，这种语句类型可获得更好的性能。</p>
</li>
<li><p><code>prepareCall(String sql)</code> ：创建一个 <code>CallableStatement</code> 对象来调用数据库存储过程。</p>
</li>
<li><p>必须在 <em>finally</em> 块中关闭<code>Connection</code>。</p>
</li>
<li><p><code>void rollback()</code>：取消在当前事务中进行的所有更改，并释放此 <code>Connection</code> 对象当前持有的所有数据库锁。</p>
</li>
<li><p><code>void setAutoCommit(boolean autoCommit):</code> 将此连接的自动提交模式设置为给定状态。</p>
</li>
</ol>
<h2 id="4-2-Statement常用方法"><a href="#4-2-Statement常用方法" class="headerlink" title="4.2 Statement常用方法"></a>4.2 Statement常用方法</h2><ol>
<li><p><strong>（不推荐用）</strong><code>Boolean execute(String sql)</code> ：执行给定的 SQL 语句（增删改查语句都可以），该语句可能返回多个结果。</p>
</li>
<li><p><code>ResultSet executeQuery(String sql)</code> : 执行给定的 SQL 查询语句，该语句返回单个 <code>ResultSet</code> 对象。</p>
</li>
<li><p><code>int intexecuteUpdate(Stringsql)</code>: 执行给定 SQL 语句，该语句可能为 <em>INSERT、UPDATE 或 DELETE</em> 语句，或者不返回任何内容的 SQL 语句（如 DDL 语句）。</p>
</li>
<li><p><code>setQueryTimeout(int seconds)</code> ：将驱动程序等待 <code>Statement</code> 对象执行的秒数设置为给定秒数。</p>
</li>
<li><p>必须在finally块中关闭<code>Statement</code>。</p>
</li>
</ol>
<h2 id="4-3-ResultSet常用方法"><a href="#4-3-ResultSet常用方法" class="headerlink" title="4.3  ResultSet常用方法"></a>4.3  ResultSet常用方法</h2><ol>
<li><p><code>next()</code>: 将光标从当前位置向前移一行。ResultSet 光标最初位于第一行之前；第一次调用 next 方法使第一行成为当前行；第二次调用使第二行成为当前行，依此类推。</p>
</li>
<li><p><code>close()</code> ：立即释放此 ResultSet 对象的数据库和 JDBC 资源，而不是等待该对象自动关闭时发生此操作。</p>
</li>
<li><p><code>getXxx(int columnIndex)</code> ：使用列索引来获取数据，Xxx表示相应的数据类型。</p>
</li>
</ol>
<p>​		例如：</p>
<ul>
<li>获字符串用<em>getString(int columnIndex)，getString(String columnNanme)</em></li>
<li>获取整数用<em>getInt(int columnIndex),  getInt(String columnName)</em></li>
</ul>
<p>d)   必须在<code>finally</code>块中关闭<code>ResultSet</code>。</p>
<h1 id="五、PreparedStatement"><a href="#五、PreparedStatement" class="headerlink" title="五、PreparedStatement"></a>五、PreparedStatement</h1><ol>
<li><p>预编译语句<code>PreparedStatement</code>是<code>Statement</code>的子类</p>
</li>
<li><p>为什么要使用预编译语句？</p>
<ul>
<li><p>执行效率高</p>
</li>
<li><p>安全</p>
</li>
<li><p>支持参数值占位符：？</p>
</li>
</ul>
</li>
</ol>
<p><img src="image-20230509215556993-3640563.png"></p>
<p>SQL中的 “**- -**” 把后面的语句给注掉了，这样就出现了SQL漏洞。预编译语句可以避免此类问题的发生。</p>
<p>如果要多次执行相似的SQL语句，如：一次插入（更新、删除）几百条记录; 又如不同用户登录执行 SQL语句只有用户名和密码不同。可以使用<code>PreparedStatement</code>（预编译语句对象）对象来执行。由于预编译语句使用占位符 ”?”，在执行SQL之前语句会被先发送到数据库服务器进行语法检查和编译等工作，并将SQL语句加入到数据库的语句缓冲池里，随后再对SQL语句中的占位符 <strong>”?”</strong> 设置定值。那么也就说如果你要执行1000行插入的时候第一次先SQL语句发送给数据库服务器处理，接着后面只需传递占位符的值就可以了。因此它不需每次传递大量的SQL语句也无需对每条SQL语句做语法检查和编译所以比较高效。</p>
<ol start="3">
<li>通过Connection的prepareStatement( sql )方法来创建预编译语句对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">save</span><span class="params">(Employee e)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> (</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> JdbcUtils.getConnection();</span><br><span class="line">  ) &#123;</span><br><span class="line">      <span class="comment">//? 占位符只能对赋值的地方占位，</span></span><br><span class="line">      <span class="comment">//如：where empno=?;    update emp set ename=? ....</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into emp(ename,job,mgr,hiredate,sal,comm,deptno) values (?,?,?,?,?,?,?)&quot;</span>; </span><br><span class="line">      <span class="comment">//1.先创建预编译语句，占位符只能给值进行占位</span></span><br><span class="line">      <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">      <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//2.再给？(点位符)设置值, 占位符索引位置从1开始</span></span><br><span class="line">      ps.setString(index++, e.getEname());</span><br><span class="line">      ps.setString(index++, e.getJob());</span><br><span class="line">      ps.setInt(index++, e.getMgr());</span><br><span class="line">      ps.setDate(index++, <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(e.getHiredate().getTime()));</span><br><span class="line">      ps.setDouble(index++, e.getSal());</span><br><span class="line">      <span class="comment">//如果列允许为空时，需要作一下JDBC 的空值处理, setNull(i, sqlType);</span></span><br><span class="line">      <span class="keyword">if</span>(e.getComm()==<span class="literal">null</span>)&#123;</span><br><span class="line">          ps.setNull(index++, java.sql.Types.DOUBLE);</span><br><span class="line">      &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">          ps.setDouble(index++,e.getComm());</span><br><span class="line">      &#125;</span><br><span class="line">      ps.setInt(index++, e.getDeptno());</span><br><span class="line">      <span class="comment">//3.执行，不能再指定SQL 语句</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">          System.err.println(<span class="string">&quot;&gt;&gt;2.新增员工实体失败：&quot;</span> + ex.getMessage());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-常用方法"><a href="#5-1-常用方法" class="headerlink" title="5.1 常用方法"></a>5.1 常用方法</h2><ul>
<li><p><code>boolean   execute()</code>：在此 <code>PreparedStatement</code> 对象中执行 SQL 语句，该语句可以是任何种类的 SQL 语句。</p>
</li>
<li><p><code>ResultSet executeQuery()</code> 在此 <code>PreparedStatement</code> 对象中执行 SQL 查询，并返回该查询生成的 ResultSet 对象。</p>
</li>
<li><p><code>int executeUpdate()</code>：在此 <code>PreparedStatement</code> 对象中执行 SQL 语句，该语句必须是一个 SQL 数据操作语言<em>（Data Manipulation Language，DML）</em>语句，比如 <em>INSERT、UPDATE 或 DELETE</em> 语句；或者是无返回内容的 SQL 语句，比如 DDL 语句。</p>
</li>
<li><p><code>void setXxx(int parameterIndex, Xxx value)</code>: Xxx表示相应的数据类型，如：setString(…), setInt(…)等。设置点位符位置的值，第一个参数是 1，第二个参数是 2，…..</p>
</li>
<li><p><code>setNull(int parameterIndex, java.sql.Types value)</code>: 插入或更新时处理空值的字段，通常对非<code>char, varchar</code>类型字段空值时使用。</p>
</li>
<li><p>必须在 <em>finally</em> 块中关闭<code>PreparedStatement</code>。</p>
</li>
</ul>
<h2 id="5-2-PreparedStatement与Statement的对比"><a href="#5-2-PreparedStatement与Statement的对比" class="headerlink" title="5.2 PreparedStatement与Statement的对比"></a>5.2 PreparedStatement与Statement的对比</h2><table>
<thead>
<tr>
<th></th>
<th>Statement</th>
<th>PreparedStatement</th>
</tr>
</thead>
<tbody><tr>
<td>创建语句对象的方法</td>
<td><em>Connection.createStatement( )</em>  创建语句对象时 不提供SQL</td>
<td><em>Connection.preparedStatement( sql )</em>  创建语句对象时 提供SQL</td>
</tr>
<tr>
<td>查询</td>
<td><em>executeQuery( sql )</em>  要提供SQL语句</td>
<td><em>executeQuery( )</em>  不提供提供SQL语句，但随后要设置占位符的值</td>
</tr>
<tr>
<td>插入、更新、删除</td>
<td><em>executeUpdate( sql )</em>  要提供SQL语句</td>
<td><em>executeUpdate( )</em>  不提供提供SQL语句</td>
</tr>
</tbody></table>
<h1 id="六-存储过程调用"><a href="#六-存储过程调用" class="headerlink" title="六. 存储过程调用"></a>六. 存储过程调用</h1><p>调用存储过程可以使用<code>CallableStatement</code>语句类型来调用。</p>
<ol>
<li><p>通过conn.prepareCall(<strong>“</strong>{call find_employee(?,?)}”); 获得一个使用CallableStatement语句对象。</p>
</li>
<li><p>设置<em>输入（IN模式）参数</em>的值和注册<em>输出（OUT模式）参数</em>。</p>
<ul>
<li><p>设置输入（IN模式）参数的值使用：</p>
<p><code>CallableStatement.setString(parameterIndex, value);</code></p>
<p>根据参数类型选择调用相应的方法。</p>
</li>
<li><p>注册输出（OUT模式）参数:</p>
</li>
</ul>
</li>
</ol>
<p>​			<code>CallableStatement.registerOutParameter(OUT_ ParameterIndex, java.sql.Types.类型常量);</code></p>
<ol start="3">
<li>获得输出参数的值使用方法：getString (输出参数的索引位置); 根据输出参数类型调用相应的方法。</li>
</ol>
<ul>
<li><strong>示例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用存储过程</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProcedure</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="comment">//调用存储过程必须用CallableStatement语句对象，它是PreparedStatement的子类</span></span><br><span class="line">    <span class="type">CallableStatement</span> <span class="variable">cs</span> <span class="operator">=</span></span><br><span class="line">            <span class="built_in">this</span>.conn.prepareCall(<span class="string">&quot;&#123;call get_job_sum_sal(?,?)&#125;&quot;</span>); <span class="comment">//第二个？号的参数模式是out</span></span><br><span class="line">    <span class="comment">//设置点位符的值</span></span><br><span class="line">    cs.setString(<span class="number">1</span>, <span class="string">&quot;SALESMAN&quot;</span>);</span><br><span class="line">    cs.setDouble(<span class="number">2</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="comment">//若过程有输出参数模式的，必须在过程执行前注册输出参数，也是说要告诉oracle驱动要得到哪个占位符的值 </span></span><br><span class="line">    cs.registerOutParameter(<span class="number">2</span>, java.sql.Types.DOUBLE, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行过程</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> cs.execute();</span><br><span class="line">    <span class="comment">//得到结果，即过程的输出参数的值</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> cs.getDouble(<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;SALESMAN的总工资：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七-批量更新"><a href="#七-批量更新" class="headerlink" title="七. 批量更新"></a>七. 批量更新</h1><h2 id="7-1-Statement-批量更新"><a href="#7-1-Statement-批量更新" class="headerlink" title="7.1 Statement 批量更新"></a>7.1 Statement 批量更新</h2><p>用Statement对象执行批量更新时，用到addBatch()和executeBatch()方法。</p>
<p><em>insert</em> 和 <em>delete</em> 操作与<em>update</em> 操作相似。</p>
<ul>
<li><strong>示例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JdbcUtil.getConnection();</span><br><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//1.设置自动提交事务为 false</span></span><br><span class="line">    connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    statement = connection.createStatement();</span><br><span class="line">    <span class="comment">//2.使用addBatch（）方法添加要在批处理中执行的SQL语句。然后使用executeBatch（）执行SQL语句。</span></span><br><span class="line">    statement.addBatch(<span class="string">&quot;update people set firstname=&#x27;aaa&#x27; where id=123&quot;</span>);</span><br><span class="line">    statement.addBatch(<span class="string">&quot;update people set firstname=&#x27;bbb&#x27; where id=456&quot;</span>);</span><br><span class="line">    statement.addBatch(<span class="string">&quot;update people set firstname=&#x27;ccc&#x27;  where id=789&quot;</span>);</span><br><span class="line">		<span class="comment">//返回每条件语句数据受影响的行数</span></span><br><span class="line">    <span class="type">int</span>[] recordsAffected = statement.executeBatch();</span><br><span class="line">    <span class="comment">//3.1 提交事务</span></span><br><span class="line">    connection.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">  	<span class="comment">//3.2 回滚事务</span></span><br><span class="line">  	connection.rollback();</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">            statement.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-PreparedStatement-批量更新"><a href="#7-2-PreparedStatement-批量更新" class="headerlink" title="7.2 PreparedStatement 批量更新"></a>7.2 PreparedStatement 批量更新</h2><p>使用<code>PreparedStatement</code>对象执行批量更新。<code>PreparedStatement</code><em>可以重用相同的SQL语句</em>，并只需插入新参数即可执行每个更新。</p>
<p><em>insert</em> 和 <em>delete</em> 操作与<em>update</em> 操作相似。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JdbcUtil.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update PEOPLE set firstname=? where id=?&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//1.设置自动提交事务为 false</span></span><br><span class="line">    connection.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">  	<span class="comment">//2.添加语句组，并为每条语句设置参数值</span></span><br><span class="line">    <span class="comment">//第1条记录</span></span><br><span class="line">    preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;james&quot;</span>);</span><br><span class="line">    preparedStatement.setLong  (<span class="number">2</span>, <span class="number">123</span>);</span><br><span class="line">    <span class="comment">//加入到批量处理</span></span><br><span class="line">    preparedStatement.addBatch();</span><br><span class="line">    <span class="comment">//第2条记录</span></span><br><span class="line">    preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;zhang&quot;</span>);</span><br><span class="line">    preparedStatement.setLong  (<span class="number">2</span>, <span class="number">456</span>);</span><br><span class="line">    preparedStatement.addBatch();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] affectedRecords = preparedStatement.executeBatch();</span><br><span class="line">    <span class="comment">//3.1 提交事务</span></span><br><span class="line">    connection.commit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">  	<span class="comment">//3.2 回滚事务</span></span><br><span class="line">  	connection.rollback();</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preparedStatement != <span class="literal">null</span>) &#123;</span><br><span class="line">            preparedStatement.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		将每组参数值插入到preparedStatement中，并调用*addBatch( )<em>方法。 这会将参数值添加到批处理内部。 现在可以添加另一组值，以便插入到SQL语句中。 将全部批次发送到数据库后，将每组参数插入到SQL中并分别执行。然后执行</em>executeBatch( )*方法，它执行所有的批量更新。 SQL语句和参数集一起发送到数据库。</p>
<p><strong>注意: 批量操作应该放到事务里进行，因为它会存在某条语句执行失败的情况。</strong></p>
<h1 id="八-Java数据类型与SQL类型的映射"><a href="#八-Java数据类型与SQL类型的映射" class="headerlink" title="八. Java数据类型与SQL类型的映射"></a>八. Java数据类型与SQL类型的映射</h1><h2 id="8-1-Conversions-by-setObject-index-value"><a href="#8-1-Conversions-by-setObject-index-value" class="headerlink" title="8.1 Conversions by setObject(index, value)"></a>8.1 Conversions by setObject(index, value)</h2><p>下表说明了可用*Statement.setObject(index, value)和 PreparedStatement.setObject(index, value)*方法支持将Java类型到JDBC类型赋值。</p>
<p><img src="clip_image001.png"></p>
<p>An “x” means that the given Java object type may be converted to the given JDBC type. This table show the possible values for the parameter specifying a target JDBC type that is passed to the method PreparedStatement.setObject or RowSet.setObject. Note that some conversions may fail at run time if the value presented is invalid.</p>
<h2 id="8-2-Conversions-by-ResultSet-getXXX-Methods"><a href="#8-2-Conversions-by-ResultSet-getXXX-Methods" class="headerlink" title="8.2 Conversions by ResultSet.getXXX Methods"></a>8.2 Conversions by ResultSet.getXXX Methods</h2><p><img src="clip_image001-3697769-3697774.png"></p>
<p><code>SQLInput.readXXX</code> methods support only the recommended conversions. An “x” means that the method <em>can</em> retrieve the JDBC type. An “<strong>X</strong>“ means that the method is <em>recommended</em> for retrieving the JDBC type.</p>
<h1 id="九、apache-DButils-组件库"><a href="#九、apache-DButils-组件库" class="headerlink" title="九、apache DButils 组件库"></a>九、apache DButils 组件库</h1><p>dbutils是apache 中的一个简化了jdbc的编程的工具组件库。</p>
<p>下载地址：<a href="https://commons.apache.org/proper/commons-dbutils/">DbUtils – JDBC Utility Component (apache.org)</a></p>
<p>官方示例：<a href="https://commons.apache.org/proper/commons-dbutils/examples.html">DbUtils – JDBC Utility Component – Examples (apache.org)</a></p>
<h2 id="9-1-ResultSetHandler结果集处理器接口"><a href="#9-1-ResultSetHandler结果集处理器接口" class="headerlink" title="9.1 ResultSetHandler结果集处理器接口"></a>9.1 ResultSetHandler结果集处理器接口</h2><p><code>ResultSetHandler</code> 的功能是将查询结果的列名与JavaBean对象的属性名(setter方法)进行反射赋值，有以下几个常用实现类：</p>
<ul>
<li><p><code>BeanHandler</code>：JavaBean处理器。将查询结果集 <code>ResultSet</code>的一行仅且一行封装成一个JavaBean对象。</p>
</li>
<li><p><code>BeanListHandler</code>：JavaBean列表处理器。 将多行查询集 <code>ResultSet</code>封装成一个JavaBean列表。</p>
</li>
<li><p><code>MapHandler</code>：Map处理器。将查询结果集的一行仅且一行封装成一个<em>Map</em>对象，结果集的列名作为 Map 的<em>key</em>，值作为Map 的<em>value</em>;</p>
</li>
<li><p><code>MapListHandler</code>： Map列表处理器。返回一个列表其元素为Map，查询结果集的每一行封装成一个Map对象，结果的列名作为key，值作为value;</p>
</li>
<li><p><code>ScalarHandler</code>: 标量类型处理器。将只有一行一列的查询结果集封装成一个基本类型的值，如：<em>Select  count(*)  as rows  from  employee</em>;</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将查询结果集通过反射机制封装成一个JavaBean实体，查询结果的列名将与JavaBean的属性名进行反射（实际上是调用 JavaBean 的setter方法）</span></span><br><span class="line"><span class="comment">//如果结果集的列有与 JavaBean 属性名不同时，可通过给列名取别名的方式使之与JavaBean 属性名一样</span></span><br><span class="line">ResultSetHandler&lt;Employee&gt;  rsh = <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;Employee&gt;(Employee.class); </span><br><span class="line">runner.query(conn, sql, rsh [,Object... params]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将查询结果集通过反射机制封装成一个JavaBean实体列表</span></span><br><span class="line">ResultSetHandler&lt;Employee&gt;  rsh = <span class="keyword">new</span> <span class="title class_">BeanListHandler</span> &lt;Employee&gt;(Employee.class);</span><br><span class="line">runner.query(conn, sql, rsh [,Object... params]);</span><br></pre></td></tr></table></figure>

<h2 id="9-2-QueryRunner-SQL执行操作类-多线程安全"><a href="#9-2-QueryRunner-SQL执行操作类-多线程安全" class="headerlink" title="9.2 QueryRunner SQL执行操作类(多线程安全)"></a>9.2 QueryRunner SQL执行操作类(多线程安全)</h2><p>官方是这样解释的：</p>
<blockquote>
<p>Executes SQL queries with pluggable strategies for handling <code>ResultSet</code>s. This class is thread safe.</p>
</blockquote>
<p>所有对数据库的CRUD操作都通过 <code>QueryRunner</code> 完成。</p>
<p>如果创建<code>QueryRunner</code>实例时没有提供<code>DataSource</code>数据源参数则在执行CRUD操作方法时需提供数据库连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式 1: 不使用数据源</span></span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//方式 2：使用数据源，数据源通过其它方式获得并传入构造中</span></span><br><span class="line"><span class="type">QueryRunner</span> <span class="variable">runner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>([DataSource]);</span><br></pre></td></tr></table></figure>

<h3 id="普通查询（无占位符参数）"><a href="#普通查询（无占位符参数）" class="headerlink" title="普通查询（无占位符参数）"></a>普通查询（无占位符参数）</h3><p>以下示例均以junit 单元测试提供。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuerySingleEmployee</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from emp where ename=&#x27;ZHANG&#x27;&quot;</span>;</span><br><span class="line">    <span class="comment">//默认dbutil会通过结果集的类名与bean的属性名进行反射，</span></span><br><span class="line">    <span class="comment">//如果列名与bean的属性名不一致时可以为列名取别名来解决</span></span><br><span class="line">    ResultSetHandler&lt;Employee&gt; rsh = <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;Employee&gt;(Employee.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Employee</span> <span class="variable">e</span> <span class="operator">=</span> runner.query(conn, sql, rsh);</span><br><span class="line">      System.out.println(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="带占位符参数查询"><a href="#带占位符参数查询" class="headerlink" title="带占位符参数查询"></a>带占位符参数查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryEmployeeList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//复杂查询时SQL语句需动态构建</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from emp where ename like ? and sal between ? and ?&quot;</span>;</span><br><span class="line">    <span class="comment">//默认dbutil会通过结果集的类名与bean的属性名进行反射，</span></span><br><span class="line">    <span class="comment">//如果列名与bean的属性名不一致时可以为列名取别名来解决</span></span><br><span class="line">    ResultSetHandler&lt;List&lt;Employee&gt;&gt; rsh = <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;Employee&gt;(Employee.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; list = runner.query(conn, sql, rsh,<span class="string">&quot;%A%&quot;</span>,<span class="number">1000.0</span>,<span class="number">5000.0</span>);</span><br><span class="line">        <span class="keyword">for</span> (Employee e : list) &#123;</span><br><span class="line">          System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标量查询"><a href="#标量查询" class="headerlink" title="标量查询"></a>标量查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCount</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(empno) AS r from emp&quot;</span>;</span><br><span class="line">    ResultSetHandler&lt;BigDecimal&gt; rsh = <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>&lt;BigDecimal&gt;(<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">rows</span> <span class="operator">=</span> runner.query(conn, sql, rsh);</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> rows.intValue();</span><br><span class="line">        System.out.println(rows);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//SQL语句可能需动态构建，参考以前JDBC的代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into emp(EMPNO,ENAME,MGR,HIREDATE,SAL,DEPTNO) values(?,?,?,?,?,?)&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回数据库受影响的行数，即插入的行数</span></span><br><span class="line">      	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> runner.update(conn, sql, <span class="number">8136</span>,<span class="string">&quot;Alex&quot;</span>,<span class="number">7369</span>,<span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="keyword">new</span> <span class="title class_">Date</span>().getTime()),<span class="number">4440.0</span>,<span class="number">10</span>);</span><br><span class="line">      	System.out.println(i);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSave</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//SQL语句可能需动态构建，参考以前JDBC的代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update emp set ENAME=?,JOB=?,SAL=? Where EMPNO=?&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回数据库受影响的行数，即更新的行数</span></span><br><span class="line">      	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> runner.update(conn, sql, <span class="number">8136</span>,<span class="string">&quot;Alex&quot;</span>,<span class="number">7369</span>,<span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="keyword">new</span> <span class="title class_">Date</span>().getTime()),<span class="number">4440.0</span>,<span class="number">10</span>);</span><br><span class="line">      	System.out.println(i);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//SQL语句可能需动态构建，参考以前JDBC的代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete employee Where EMPNO=?&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 返回数据库受影响的行数，即删除的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> runner.update(conn, sql, <span class="number">8136</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java：JDK8函数式接口、lambda表达式、方法引用</title>
    <url>/2024/07/06/Java-JDK8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E3%80%81lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一、函数式接口"><a href="#一、函数式接口" class="headerlink" title="一、函数式接口"></a>一、函数式接口</h1><p>只有一个抽象方法的接口就成为函数式接口。同时，引入了一个新的注解：@FunctionalInterface。可以把他它放在一个接口前，表示这个接口是一个函数式接口。这个注解是非必须的，只要接口只包含一个方法的接口，虚拟机会自动判断，不过最好在接口上使用注解 @FunctionalInterface 进行声明。在接口中添加了 @FunctionalInterface 的接口，只允许有一个抽象方法，否则编译器也会报错。</p>
<p>举例几个Java常用的函数式接口：predicate断言型接口、consumer消费者接口、supplier提供者接口、Function接口等。</p>
<p><strong>记好一句话：函数式接口可以接收匿名内部类和lambda表达式</strong></p>
<p><strong>记好一句话：函数式接口可以接收匿名内部类和lambda表达式</strong></p>
<p><strong>记好一句话：函数式接口可以接收匿名内部类和lambda表达式</strong></p>
<p><strong>全文重点：</strong></p>
<p>俗话说，new一个接口就要new他的实现类对象，但是假设我不存在函数时接口的实现类对象，那么一般就使用匿名内部类的形式创建对象。创建出来的匿名内部类需要实现函数式接口中全部（其实就一个）的抽象方法。既然是匿名内部类的抽象方法，当然可以使用lambda表达式代替方法的实现。然而使用lambda表达式虽然简便了书写，但是代码的可读性也直线下降，没有注解的情况去读lambda表达式十分痛苦，为了针对代码可读性的问题，方法引用应运而生。方法引用作为lambda表达式的语法糖，可以简化lambda表达式的同时，提高代码的可读性，方法引用通过本篇博客的三种情况，代替lambda表达式的书写。</p>
<h3 id="1-1-Predicate"><a href="#1-1-Predicate" class="headerlink" title="1.1 Predicate"></a>1.1 Predicate</h3><p><code>java.util.function.Predicate</code>为函数式接口，predicate的中文意思是“断定”，即判断的意思，判断某个东西是否满足某种条件； 因此它包含test方法，根据输入值来做逻辑判断，其结果为True或者False。</p>
<ul>
<li><code>Predicate</code> 是一个布尔类型的函数，该函数只有一个输入参数。</li>
<li><code>Predicate</code>接口包含了多种默认方法，用于处理复杂的逻辑动词（<em>and, or, negate</em>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt;&#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是使用<code>Predicate</code>的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; atLeast5 = x -&gt; x&gt;<span class="number">5</span>;</span><br><span class="line">predicate.test(<span class="number">3</span>);              <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</span><br><span class="line">predicate.test(<span class="string">&quot;foo&quot;</span>);          <span class="comment">// true</span></span><br><span class="line">predicate.negate().test(<span class="string">&quot;foo&quot;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">System.out.println(nonNull.test(<span class="literal">null</span>)); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line">System.out.println(isNull.test(<span class="literal">null</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">System.out.println(isEmpty.test(<span class="string">&quot;&quot;</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br><span class="line">System.out.println(isNotEmpty.test(<span class="string">&quot;&quot;</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><em>x&gt;5</em> 是表达式的主体，返回值就是表达式主体的值。</p>
<h3 id="1-2-Function"><a href="#1-2-Function" class="headerlink" title="1.2 Function"></a>1.2 Function</h3><p><code>java.util.function.Function</code>也是一个函数式编程接口；它代表的含义是“函数”，而函数经常是<strong>有输入输出</strong>的，因此它含有一个<em>apply方法</em>，<em>包含一个输入（一个参数）与一个输出（返回值）</em>；<br> 除apply方法外，它还有<em>compose</em> 与 <em>andThen</em>方法。</p>
<ul>
<li><p>**高阶函数: **</p>
<p>接受一个函数或返回一个函数。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = s -&gt; s + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = s -&gt; s * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 高阶函数: 接受一个函数或返回一个函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 下面表示在执行F时，先执行G，并且执行F时使用G的结果当作输入。</span></span><br><span class="line"><span class="comment"> * 相当于以下代码：</span></span><br><span class="line"><span class="comment"> * Integer a = g.apply(1);</span></span><br><span class="line"><span class="comment"> * System.out.println(f.apply(a));</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(f.compose(g).apply(<span class="number">1</span>)); <span class="comment">//output: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 表示执行F的 apply 后使用其返回的值当作输入再执行G的Apply；</span></span><br><span class="line"><span class="comment"> * 相当于以下代码</span></span><br><span class="line"><span class="comment"> * Integer a = f.apply(1);</span></span><br><span class="line"><span class="comment"> * System.out.println(g.apply(a));</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(f.apply(<span class="number">1</span>));            <span class="comment">//output: 2</span></span><br><span class="line">System.out.println(f.andThen(g).apply(<span class="number">1</span>)); <span class="comment">//output: 4</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>转换器实例</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**定义一个转换的函数式接口</span></span><br><span class="line"><span class="comment"> * T：参数类型</span></span><br><span class="line"><span class="comment"> * R：返回值类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;T,R&gt; &#123;</span><br><span class="line">    R <span class="title function_">convert</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConverterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Converter&lt;String,Integer&gt; intConverter = (s) -&gt; Integer.valueOf(s);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> intConverter.convert(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;String to Integer:&quot;</span> + value);</span><br><span class="line"></span><br><span class="line">        Converter&lt;String,Double&gt; doubleConverter = (s) -&gt; Double.valueOf(s);</span><br><span class="line">      	<span class="type">Double</span> <span class="variable">dblValue</span> <span class="operator">=</span> doubleConverter.convert(<span class="string">&quot;123.99&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;String to Double:&quot;</span> + dblValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接使用 Function 接口</span></span><br><span class="line">        Function&lt;String,Integer&gt; function = s -&gt; Integer.valueOf(s);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value2</span> <span class="operator">=</span> function.apply(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        System.out.println(value2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法引用</span></span><br><span class="line">        <span class="comment">// :: 表示引用方法</span></span><br><span class="line">        <span class="comment">//引用静态方法，类名::类方法名；如：Integer.valueOf(s)</span></span><br><span class="line">      	<span class="comment">//引用实例方法，对象::方法名</span></span><br><span class="line">        Function&lt;String,Integer&gt; function2 = Integer::valueOf;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value3</span> <span class="operator">=</span> function2.apply(<span class="string">&quot;9999&quot;</span>);</span><br><span class="line">        System.out.println(value3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-Consumer-消费者（重点）"><a href="#1-3-Consumer-消费者（重点）" class="headerlink" title="1.3 Consumer 消费者（重点）"></a>1.3 Consumer 消费者（重点）</h3><p>它定义了一个名为<code>accept</code>的<a href="https://so.csdn.net/so/search?q=%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">抽象方法</a>，该方法接受一个参数并且不返回任何结果。换句话说，<code>Consumer</code>接口表示一个消费者，它可以对给定的对象执行某些操作，但不产生任何结果。</p>
<p><code>accept(T) 方法</code>：是 Consumer 函数式接口的函数方法，传入一个任意类型，无返回值，可以用于 Lambda 表达式和方法引用。<br><code>andThen(Consumer) 方法</code>：可以传入一个 Consumer ，返回组合了两个 Consumer 后的 Consumer ，传入的 Consumer 不能为 null，否则会得到 NullPointerException 。</p>
<p><strong>通俗的来说：</strong><br>Consumer 相当于一个放东西的容器，你可以在这个容器里定义一个带有入参的代码块，然后返回 T 类型，当调用 accept(T) 方法的时候才会去执行容器里的代码。</p>
<p><strong>例子1：</strong>使用类名引用成员方法（类名引用成员方法见本篇博客第三节3.3）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用实例方法</span></span><br><span class="line">Consumer&lt;String&gt; enameConsumer = employee::setEname;</span><br><span class="line">enameConsumer.accept(<span class="string">&quot;mike&quot;</span>);</span><br><span class="line"><span class="comment">// test(enameConsumer);</span></span><br><span class="line">System.out.println(employee.getName());</span><br><span class="line"></span><br><span class="line"><span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> System.out::println;</span><br><span class="line">Arrays.asList(<span class="string">&quot;james&quot;</span>,<span class="string">&quot;andy&quot;</span>,<span class="string">&quot;scott&quot;</span>).forEach(consumer);</span><br></pre></td></tr></table></figure>



<p><strong>例子2：</strong>使用Consumer函数式接口接受lambda表达式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class MainServer &#123;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        Consumer&lt;String&gt; first = x -&gt; System.out.println(&quot;1.&quot;+x.toLowerCase());</span><br><span class="line">        Consumer&lt;String&gt; second = y -&gt; System.out.println(&quot;2.&quot; + y);</span><br><span class="line">        System.out.println(&quot;开始&quot;);</span><br><span class="line">        Consumer&lt;String&gt; result = first.andThen(second);</span><br><span class="line">        //调用了accept 后，会先执行 first 容器里的代码，再执行 second 容器里的代码</span><br><span class="line">        result.accept(&quot;A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-Supplier-供应者"><a href="#1-4-Supplier-供应者" class="headerlink" title="1.4 Supplier 供应者"></a>1.4 Supplier 供应者</h3><p>代表无参数，返回一个结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用默认构造函数</span></span><br><span class="line">Supplier&lt;Employee&gt; supplier = Employee::<span class="keyword">new</span>;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">System.out.println(employee);</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用对象的String getName()方法</span></span><br><span class="line">Supplier&lt;String&gt; stringSupplier = employee::getEname;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-BinaryOperator"><a href="#1-5-BinaryOperator" class="headerlink" title="1.5 BinaryOperator"></a>1.5 BinaryOperator</h3><ul>
<li><p><code>BinaryOperator</code><em>接口接收两个参数，返回一个值，返回值和参数的数据类型相同。</em></p>
</li>
<li><p><code>BinaryOperator</code>接口是<code>BiFunction</code> （接收两个参数）的子接口。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; addLongs = (x,y) -&gt; x + y;</span><br><span class="line">System.out.println(addLongs.apply(<span class="number">1L</span>, <span class="number">2L</span>));</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;Lambda表达式是一个匿名方法，将行为像数据一样传递。&#x3D;&#x3D;</p>
<h1 id="二、Lambda表达式"><a href="#二、Lambda表达式" class="headerlink" title="二、Lambda表达式"></a>二、Lambda表达式</h1><p><img src="%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.png"></p>
<p><strong>1、Lambda表达式的基本作用?</strong><br>简化函数式接口的<strong>匿名内部类</strong>的写法。</p>
<p><strong>2、Lambda表达式有什么使用前提?</strong><br>必须是接口的匿名内部类，接口中只能有一个抽象方法</p>
<p><strong>3、Lambda的好处?</strong><br>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码，它可以写出更简洁、更灵活的代码，作为一种更紧凑的代码风格，使Java语言表达能力得到了提升。</p>
<p>举个例子：单列集合arraylist调用foreach方法进行遍历。</p>
<p><img src="forEach.png"></p>
<p>其中方法的参数是<strong>consumer接口</strong>（留意一下consumer接口）的实现类，因此需要使用匿名内部类的形式调用方法，改进后可以使用lambda表达式遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">&quot;博主你这个博客是自己写的吗&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;我的天，好有水平，但是我看不懂&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.使用匿名内部类进行遍历</span></span><br><span class="line">        coll.forEach(<span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.使用lambda表达式进行遍历</span></span><br><span class="line">        coll.forEach(</span><br><span class="line">           (String s)-&gt; &#123;</span><br><span class="line">               System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.lambda简化版</span></span><br><span class="line">        coll.forEach(</span><br><span class="line">                (String s)-&gt; System.out.println(s)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="三、方法引用"><a href="#三、方法引用" class="headerlink" title="三、方法引用"></a>三、方法引用</h1><p><img src="%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.png"></p>
<p>只有使用匿名内部类和lambda表达式的地方才可以使用方法引用。</p>
<p>它的基本思想是，如果一个Lambda代表的只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。事实上，方法引用就是让你根据已有的方法实现来创建Lambda表达式。但是，显式地指明方法的名称，你的代码的可读性会更好。</p>
<p><strong>方法引用的规则:</strong></p>
<ol>
<li>需要有函数式接口</li>
<li>被引用的方法必须已经存在</li>
<li>被引用方法的形参，需要跟抽象方法的第二个形参到最后一个形参保持一致， 返回值需要保持一致。</li>
<li>被引用方法的功能需要满足当前的需求</li>
</ol>
<p><strong>抽象方法形参的详解:</strong><br><strong>第一个参数：</strong>表示被引用方法的调用者，决定了可以引用哪些类中的方法<br>在Stream流当中，第一个参数一般都表示流里面的每一个数据。假设流里面的数据是字符串，那么使用这种方式进行方法引用，只能引用String这个类中的方法。<br><strong>第二个参数到最后一个参数：</strong>跟被引用方法的形参保持一致，如果没有第二个参数，说明被引用的方法需要是无参的成员方法</p>
<h2 id="3-1-静态方法引用"><a href="#3-1-静态方法引用" class="headerlink" title="3.1 静态方法引用"></a>3.1 静态方法引用</h2><img src="%E9%9D%99%E6%80%81%E5%BC%95%E7%94%A8.png" style="zoom:80%;">



<p>举个例子</p>
<p><img src="1.png"></p>
<h2 id="3-2-对象引用成员方法"><a href="#3-2-对象引用成员方法" class="headerlink" title="3.2 对象引用成员方法"></a>3.2 对象引用成员方法</h2><img src="%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95.png" style="zoom: 50%;">

<p>this::方法名和super::方法名，这两个的被引用处不能是静态方法，因为静态方法没有this、super关键字</p>
<p>举个例子：</p>
<p><img src="2.png"></p>
<h2 id="3-3-类名引用成员方法"><a href="#3-3-类名引用成员方法" class="headerlink" title="3.3 类名引用成员方法"></a>3.3 类名引用成员方法</h2><p>举个例子：我现在需要把集合中的字母全部变成大写，使用匿名内部类语法如下</p>
<img src="3.png" style="zoom: 67%;">



<p>现在使用类名引用方法的形式，首先看String类中的toUpperCase方法</p>
<p><img src="all%E5%A4%A7%E5%86%99%E6%96%B9%E6%B3%95.png"></p>
<p>按照抽象方法参数的详解（3.1节），匿名内部类中抽象方法apply中的参数String s是抽象方法的第一个参数，它决定能使用什么类的方法。</p>
<p>第二个参数到末尾的参数要和成员方法的一致，如果抽象方法只有一个参数，那么应该调用这个类的无参方法。</p>
<p>String类中的toUpperCase方法提供了两个，符合可以用空参的那个。</p>
<img src="string%E7%B1%BBtoUpperCase.png" style="zoom:80%;">



<p>因此可以把匿名内部类的写法改成使用方法引用的形式</p>
<img src="4.png" style="zoom:80%;">









]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7部署docker</title>
    <url>/2024/07/06/centOS%E9%83%A8%E7%BD%B2docker/</url>
    <content><![CDATA[<h1 id="0-安装Docker"><a href="#0-安装Docker" class="headerlink" title="0.安装Docker"></a>0.安装Docker</h1><p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p>
<p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p>
<p>官方网站上有各种环境下的 <a href="https://docs.docker.com/install/">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p>
<h1 id="1-CentOS安装Docker"><a href="#1-CentOS安装Docker" class="headerlink" title="1.CentOS安装Docker"></a>1.CentOS安装Docker</h1><p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在CentOS 7安装Docker。</p>
<h2 id="1-1-卸载（可选）"><a href="#1-1-卸载（可选）" class="headerlink" title="1.1.卸载（可选）"></a>1.1.卸载（可选）</h2><p>如果之前安装过旧版本的Docker，可以使用下面命令卸载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine \</span><br><span class="line">                  docker-ce</span><br></pre></td></tr></table></figure>



<h2 id="1-2-安装docker"><a href="#1-2-安装docker" class="headerlink" title="1.2.安装docker"></a>1.2.安装docker</h2><p>首先需要大家虚拟机联网，安装yum工具</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">           device-mapper-persistent-data \</span><br><span class="line">           lvm2 --skip-broken</span><br></pre></td></tr></table></figure>



<p>然后更新本地镜像源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置docker镜像源</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line">sed -i &#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>





<p>然后输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure>

<p>docker-ce为社区免费版本。稍等片刻，docker即可安装成功。</p>
<h2 id="1-3-启动docker"><a href="#1-3-启动docker" class="headerlink" title="1.3.启动docker"></a>1.3.启动docker</h2><p>Docker应用需要用到各种端口，逐一去修改防火墙设置。非常麻烦，因此建议大家直接关闭防火墙！</p>
<p>启动docker前，一定要关闭防火墙后！！</p>
<p>启动docker前，一定要关闭防火墙后！！</p>
<p>启动docker前，一定要关闭防火墙后！！</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="comment"># 禁止开机启动防火墙</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br></pre></td></tr></table></figure>



<p>通过命令启动docker：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start docker  <span class="comment"># 启动docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl stop docker  <span class="comment"># 停止docker服务</span></span><br><span class="line"></span><br><span class="line">systemctl restart docker  <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure>



<p>然后输入命令，可以查看docker版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>

<p>如图：</p>
<p><img src="image-20210418154704436.png"></p>
<h2 id="1-4-配置镜像加速"><a href="#1-4-配置镜像加速" class="headerlink" title="1.4.配置镜像加速"></a>1.4.配置镜像加速</h2><p>docker官方镜像仓库网速较差，我们需要设置国内镜像服务：</p>
<p>参考阿里云的镜像加速文档：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p>
<h1 id="2-CentOS7安装DockerCompose"><a href="#2-CentOS7安装DockerCompose" class="headerlink" title="2.CentOS7安装DockerCompose"></a>2.CentOS7安装DockerCompose</h1><h2 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1.下载"></a>2.1.下载</h2><p>Linux下需要通过命令下载：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<p>如果下载速度较慢，或者下载失败，联系博主给你一份</p>
<p><img src="image-20210417133020614.png"></p>
<p>上传到<code>/usr/local/bin/</code>目录也可以。</p>
<h2 id="2-2-修改文件权限"><a href="#2-2-修改文件权限" class="headerlink" title="2.2.修改文件权限"></a>2.2.修改文件权限</h2><p>修改文件权限：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>



<h2 id="2-3-Base自动补全命令："><a href="#2-3-Base自动补全命令：" class="headerlink" title="2.3.Base自动补全命令："></a>2.3.Base自动补全命令：</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 补全命令</span></span><br><span class="line">curl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure>

<p>如果这里出现错误，需要修改自己的hosts文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>





<h1 id="3-Docker镜像仓库"><a href="#3-Docker镜像仓库" class="headerlink" title="3.Docker镜像仓库"></a>3.Docker镜像仓库</h1><p>搭建镜像仓库可以基于Docker官方提供的DockerRegistry来实现。</p>
<p>官网地址：<a href="https://hub.docker.com/_/registry">https://hub.docker.com/_/registry</a></p>
<h2 id="3-1-简化版镜像仓库"><a href="#3-1-简化版镜像仓库" class="headerlink" title="3.1.简化版镜像仓库"></a>3.1.简化版镜像仓库</h2><p>Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p>
<p>搭建方式比较简单，命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    --name registry	\</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -v registry-data:/var/lib/registry \</span><br><span class="line">    registry</span><br></pre></td></tr></table></figure>



<p>命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。</p>
<p>访问<a href="http://yourip:5000/v2/_catalog">http://YourIp:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p>
<h2 id="3-2-带有图形化界面版本"><a href="#3-2-带有图形化界面版本" class="headerlink" title="3.2.带有图形化界面版本"></a>3.2.带有图形化界面版本</h2><p>使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.0&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">registry</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./registry-data:/var/lib/registry</span></span><br><span class="line">  <span class="attr">ui:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">joxit/docker-registry-ui:static</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:80</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_TITLE=传智教育私有仓库</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REGISTRY_URL=http://registry:5000</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">registry</span></span><br></pre></td></tr></table></figure>



<h2 id="3-3-配置Docker信任地址"><a href="#3-3-配置Docker信任地址" class="headerlink" title="3.3.配置Docker信任地址"></a>3.3.配置Docker信任地址</h2><p>我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 添加内容：</span></span><br><span class="line"><span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;http://192.168.150.101:8080&quot;</span>]</span><br><span class="line"><span class="comment"># 重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>











]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>软件技术</tag>
      </tags>
  </entry>
  <entry>
    <title>快速复习git</title>
    <url>/2024/06/26/git%E9%80%9F%E6%9F%A5/</url>
    <content><![CDATA[<h3 id="1-博客前言"><a href="#1-博客前言" class="headerlink" title="1. 博客前言"></a>1. 博客前言</h3><p>这篇博客适用于有git基础的人看，如果没学习过git不建议看这篇博客。<br>本篇博客记录git常用的命令，用于快速复习。基于命令行，对一个项目进行版本控制（不使用图形化界面，例如idea、vscode等）。</p>
<h3 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h3><h4 id="2-1-删除git仓库"><a href="#2-1-删除git仓库" class="headerlink" title="2.1 删除git仓库"></a>2.1 删除git仓库</h4><p>​	如果项目是拉取的，或者想要换一个gitee仓库，那么在使用自己的仓库之前需要将之前的删掉。步骤如下：</p>
<ol>
<li><p>打开命令行工具,得航到你的项目所在的目录。</p>
</li>
<li><p>输入以下命令来取消当前项目与Gitee的关联: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure>

<p>这里的”origin”通常是默认的远程仓库名称，但如果你使用了不同的名称，你需要将其替换为实际的远程仓库名。</p>
</li>
<li><p>输入以下命令来检查是否已成功取消关联:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -V</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​		如果没有版本提示，说明就是删除成功了，跳到2.2步</p>
<h4 id="2-2-提交代码到gitee仓库"><a href="#2-2-提交代码到gitee仓库" class="headerlink" title="2.2 提交代码到gitee仓库"></a>2.2 提交代码到gitee仓库</h4><ol>
<li><p>项目初始化。右键自己的项目，或者进项目的目录一级，右键打开git bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 右键自己的项目，或者进项目的目录一级，右键打开git bash</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>



<p>此时文件夹中多出一个.git文件（需要打开隐藏文件夹开关）</p>
<img src="init%E5%91%BD%E4%BB%A4.png" style="zoom: 50%;">




</li>
<li><p>添加远程仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># origin 后面的是自己在gitee上创建的仓库地址</span></span><br><span class="line">git remote add origin https://gitee.com/samurai127/XXX.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看是否连接成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure>

<p>提示版本号说明成功绑定</p>
</li>
</ol>
<h4 id="2-3-提交"><a href="#2-3-提交" class="headerlink" title="2.3 提交"></a>2.3 提交</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将代码提交到本地仓库</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交</span></span><br><span class="line">git commit -m <span class="string">&#x27;版本备注&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将代码推送到远程仓库。如果多人开发，需要把master换成自己的分支，例如dev01</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>至此，在gitee上已经能够看到提交的代码了</p>
<h4 id="2-4-版本回退"><a href="#2-4-版本回退" class="headerlink" title="2.4 版本回退"></a>2.4 版本回退</h4><p>如果本地的代码被你改的bug一大堆，那么可以尝试恢复到之前交的git仓库的版本。<br>此处推荐使用reset命令进行版本回退（如果想恢复到之前某个提交的版本，且那个版本之后提交的版本我们都不要了，就可以用这种方法）。</p>
<h5 id="2-4-1-回退到上一个版本"><a href="#2-4-1-回退到上一个版本" class="headerlink" title="2.4.1 回退到上一个版本"></a>2.4.1 回退到上一个版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取所有更新，不同步</span></span><br><span class="line">git fetch --all </span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地代码同步线上最新版本(会覆盖本地所有与远程仓库.上同名的文件);</span></span><br><span class="line">git reset --hard origin/ master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再更新一次 (其实也可以不用，第二二步命令做过了其实)</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>



<h5 id="2-4-2-回退到指定版本"><a href="#2-4-2-回退到指定版本" class="headerlink" title="2.4.2 回退到指定版本"></a>2.4.2 回退到指定版本</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看版本号</span></span><br><span class="line">git logs</span><br><span class="line"><span class="comment"># 回退版本：f42aa0e换成需要的版本号</span></span><br><span class="line">git reset --hard f42aa0e</span><br></pre></td></tr></table></figure>



<h3 id="3-管理分支开发"><a href="#3-管理分支开发" class="headerlink" title="3. 管理分支开发"></a>3. 管理分支开发</h3><h4 id="3-1-从其他分支更新本地代码"><a href="#3-1-从其他分支更新本地代码" class="headerlink" title="3.1 从其他分支更新本地代码"></a>3.1 从其他分支更新本地代码</h4><p>假设多人开发，我在dev01，另一个成员在dev02，dev02更新后上传到origin dev02，我需要在本地更新dev02的代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin dev02:dev01</span><br></pre></td></tr></table></figure>



<p>看一张图了解原理：</p>
<img src="pull%E5%91%BD%E4%BB%A4.png" style="zoom: 50%;">

<p><strong>所以：git pull &#x3D; git fetch + git merge</strong></p>
<h4 id="3-2-绑定远程分支和本地分支"><a href="#3-2-绑定远程分支和本地分支" class="headerlink" title="3.2 绑定远程分支和本地分支"></a>3.2 绑定远程分支和本地分支</h4><p>按照3.1的场景，命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev02 origin/dev02 </span><br></pre></td></tr></table></figure>

<p>这个命令做了如下事情：</p>
<ol>
<li><strong>创建本地分支</strong>：如果本地不存在名为 dev02 的分支，这个命令会创建一个新的本地分支 dev02。</li>
<li><strong>设置上游分支</strong>：新创建的本地 dev02 分支会自动设置为跟踪（tracking）远程仓库 origin 上的 dev02 分支。这意味着当你以后在这个本地分支上执行 git pull 或 git  push（不带参数）时，Git 会知道要与远程的 origin&#x2F;dev02 分支进行交互。</li>
</ol>
]]></content>
      <categories>
        <category>软件技术</category>
      </categories>
      <tags>
        <tag>软件技术</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统：（一）快速学习存储器</title>
    <url>/2024/07/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E5%BF%AB%E9%80%9F%E5%AD%A6%E4%B9%A0%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h2 id="一、CPU"><a href="#一、CPU" class="headerlink" title="一、CPU"></a>一、CPU</h2><h3 id="1、冯诺依曼模型"><a href="#1、冯诺依曼模型" class="headerlink" title="1、冯诺依曼模型"></a>1、冯诺依曼模型</h3><p>在 1945 年冯诺依曼和其他计算机科学家们提出了计算机具体实现的报告，其遵循了图灵机的设计，而且还提出用电子元件构造计算机，并约定了用二进制进行计算和存储。</p>
<p>最重要的是定义计算机基本结构为 5 个部分，分别是<strong>运算器、控制器、存储器、输入设备、输出设备</strong>，这 5 个部分也被称为<strong>冯诺依曼模型</strong>。</p>
<p><img src="Von_Neumann_architecture.svg"></p>
<p><strong>运算器、控制器是在中央处理器（CPU）里的，存储器就我们常见的内存，输入输出设备则是计算机外接的设备，</strong>比如键盘就是输入设备，显示器就是输出设备。</p>
<p>存储单元和输入输出设备要与中央处理器打交道的话，离不开总线。所以，它们之间的关系如下图：</p>
<p><img src="%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B.webp"></p>
<hr>
<h4 id="1-1-内存"><a href="#1-1-内存" class="headerlink" title="1.1 内存"></a>1.1 内存</h4><h4 id="1-什么是内存？"><a href="#1-什么是内存？" class="headerlink" title="1.什么是内存？"></a>1.什么是内存？</h4><p><strong>内存是硬件，是用于存放数据的硬件。</strong></p>
<p>程序执行前需要先放到内存中才能被CPU处理。</p>
<p>内存是与CPU沟通的桥梁，计算机中所有程序的运行都要依靠内存，内存对计算机的影响非常大。</p>
<p><strong>主存储器，内存，内存条，内部存储器是一个东西</strong>。这很重要，不然看到后面概念都混淆。</p>
<h4 id="2-内存的作用"><a href="#2-内存的作用" class="headerlink" title="2.内存的作用"></a>2.内存的作用</h4><p><strong>内存，用于存放CPU中的运算数据以及硬盘等外部存储设备交换的数据。</strong></p>
<p>CPU一般会把需要运算的数据调到主存中进行运算，运算完后CPU将结果再传出来。</p>
<p>我们的程序和数据都是存储在内存，存储的区域是线性的。</p>
<p>在计算机数据存储中，存储数据的基本单位是<strong>字节（byte）</strong>，1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。</p>
<p>内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。</p>
<hr>
<h4 id="1-2-中央处理器（CPU）"><a href="#1-2-中央处理器（CPU）" class="headerlink" title="1.2 中央处理器（CPU）"></a>1.2 中央处理器（CPU）</h4><p>中央处理器也就是我们常说的 CPU，32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：</p>
<ul>
<li>32 位 CPU 一次可以计算 4 个字节；</li>
<li>64 位 CPU 一次可以计算 8 个字节；</li>
</ul>
<p>这里的 32 位和 64 位，通常称为 CPU 的位宽，代表的是 CPU 一次可以计算（运算）的数据量。</p>
<p>之所以 CPU 要这样设计，是为了能计算更大的数值，如果是 8 位的 CPU，那么一次只能计算 1 个字节 <code>0~255</code> 范围内的数值，这样就无法一次完成计算 <code>10000 * 500</code> ，于是为了能一次计算大数的运算，CPU 需要支持多个 byte 一起计算，所以 CPU 位宽越大，可以计算的数值就越大，比如说 32 位 CPU 能计算的最大整数是 <code>4294967295</code>。</p>
<p>CPU 内部还有一些组件，常见的有<strong>寄存器、控制单元和逻辑运算单元</strong>等。其中，控制单元负责控制 CPU 工作，逻辑运算单元负责计算，而寄存器可以分为多种类，每种寄存器的功能又不尽相同。</p>
<p><strong>寄存器是计算机中央处理器（CPU）内部的一种高速存储单元，用于临时存储数据和指令。</strong></p>
<p><strong>为什么有了内存还需要寄存器？</strong></p>
<p>因为内存离 CPU 太远了，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。</p>
<hr>
<h4 id="1-3-输入、输出设备"><a href="#1-3-输入、输出设备" class="headerlink" title="1.3 输入、输出设备"></a>1.3 输入、输出设备</h4><p>输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。</p>
<hr>
<h3 id="2、线路位宽与-CPU-位宽（操作系统32位和64位）"><a href="#2、线路位宽与-CPU-位宽（操作系统32位和64位）" class="headerlink" title="2、线路位宽与 CPU 位宽（操作系统32位和64位）"></a>2、线路位宽与 CPU 位宽（操作系统32位和64位）</h3><p>数据是如何通过线路传输的呢？其实是通过操作电压，低电压表示 0，高压电压则表示 1。</p>
<p>如果构造了高低高这样的信号，其实就是 101 二进制数据，十进制则表示 5，如果只有一条线路，就意味着每次只能传递 1 bit 的数据，即 0 或 1，那么传输 101 这个数据，就需要 3 次才能传输完成，这样的效率非常低。</p>
<p>这样一位一位传输的方式，称为串行，下一个 bit 必须等待上一个 bit 传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以并行传输。</p>
<p>为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。</p>
<p>CPU 想要操作「内存地址」就需要「地址总线」：</p>
<ul>
<li>如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，所以 CPU 能操作的内存地址最大数量为 2（2^1）个（注意，不要理解成同时能操作 2 个内存地址）；</li>
<li>如果地址总线有 2 条，那么能表示 00、01、10、11 这四种地址，所以 CPU 能操作的内存地址最大数量为 4（2^2）个。</li>
</ul>
<p>那么，想要 CPU 操作 4G 大的内存，那么就需要 32 条地址总线，因为 <code>2 ^ 32 = 4G</code>。</p>
<p>知道了线路位宽的意义后，我们再来看看 CPU 位宽。</p>
<p>CPU 的位宽最好不要小于线路位宽，比如 32 位 CPU 控制 40 位宽的地址总线和数据总线的话，工作起来就会非常复杂且麻烦，所以 32 位的 CPU 最好和 32 位宽的线路搭配，因为 32 位 CPU 一次最多只能操作 32 位宽的地址总线和数据总线。</p>
<p>如果用 32 位 CPU 去加和两个 64 位大小的数字，就需要把这 2 个 64 位的数字分成 2 个低位 32 位数字和 2 个高位 32 位数字来计算，先加个两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位，就能算出结果了，可以发现 32 位 CPU 并不能一次性计算出加和两个 64 位数字的结果。</p>
<p>对于 64 位 CPU 就可以一次性算出加和两个 64 位数字的结果，因为 64 位 CPU 可以一次读入 64 位的数字，并且 64 位 CPU 内部的逻辑运算单元也支持 64 位数字的计算。</p>
<p>但是并不代表 64 位 CPU 性能比 32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以<strong>如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来</strong>。</p>
<p>另外，32 位 CPU 最大只能操作 4GB 内存，就算装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为 <code>2^64</code>（256T）</p>
<h2 id="二、存储器的层次结构"><a href="#二、存储器的层次结构" class="headerlink" title="二、存储器的层次结构"></a>二、存储器的层次结构</h2><h3 id="层次结构介绍"><a href="#层次结构介绍" class="headerlink" title="层次结构介绍"></a>层次结构介绍</h3><p>计算机的两类存储器，一是外部存储器，二是内部存储器。<strong>常见的外部存储器主要是磁盘，磁盘又分为硬盘和软盘，而内部存储器就是常说的内存。</strong></p>
<p><strong>小林coding层次结构：</strong></p>
<img src="%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" style="zoom: 80%;">

<p><strong>OS教材：</strong></p>
<img src="OS%E7%9A%84%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1.png" style="zoom: 80%;">

<h3 id="聚焦CPU内部："><a href="#聚焦CPU内部：" class="headerlink" title="聚焦CPU内部："></a>聚焦CPU内部：</h3><p>我们想象中一个场景，大学期末准备考试了，你前去图书馆临时抱佛脚。那么，在看书的时候，我们的大脑会思考问题，也会记忆知识点，另外我们通常也会把常用的书放在自己的桌子上，当我们要找一本不常用的书，则会去图书馆的书架找。</p>
<p>我们可以把 CPU 比喻成我们的大脑，大脑正在思考的东西，就好比 CPU 中的<strong>寄存器</strong>，处理速度是最快的，但是能存储的数据也是最少的，毕竟我们也不能一下同时思考太多的事情，除非你练过。</p>
<p>我们大脑中的记忆，就好比 <strong>CPU Cache</strong>，中文称为 CPU 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。</p>
<p>CPU Cache 通常会分为 <strong>L1、L2、L3 三层</strong>，其中 L1 Cache 通常分成「数据缓存」和「指令缓存」，L1 是距离 CPU 最近的，因此它比 L2、L3 的读写速度都快、存储空间都小。我们大脑中短期记忆，就好比 L1 Cache，而长期记忆就好比 L2&#x2F;L3 Cache。</p>
<p>寄存器和 CPU Cache 都是在 CPU 内部，跟 CPU 挨着很近，因此它们的读写速度都相当的快，但是能存储的数据很少，毕竟 CPU 就这么丁点大。</p>
<p><img src="%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E5%85%B3%E7%B3%BB.webp"></p>
<h3 id="聚焦CPU外部："><a href="#聚焦CPU外部：" class="headerlink" title="聚焦CPU外部："></a>聚焦CPU外部：</h3><p>知道 CPU 内部的存储器的层次分布，我们放眼看看 CPU 外部的存储器。</p>
<p>当我们大脑记忆中没有资料的时候，可以从书桌或书架上拿书来阅读，那我们桌子上的书，就好比<strong>内存</strong>，我们虽然可以一伸手就可以拿到，但读写速度肯定远慢于寄存器，那图书馆书架上的书，就好比<strong>硬盘</strong>，能存储的数据非常大，但是读写速度相比内存差好几个数量级，更别说跟寄存器的差距了。</p>
<p>硬盘有如下的内容：</p>
<p><strong>机械硬盘（HDD）</strong><br>机械硬盘是计算机中的一种数据存储设备，它使用旋转的盘片和移动的磁头来读写数据。机械硬盘通常比固态硬盘容量更大，价格更便宜，但是速度相对较慢，且比较容易受到机械损伤的影响。机械硬盘通常用于存储大量数据和长期存储。</p>
<p><strong>固态硬盘（SSD）</strong><br>固态硬盘是一种新型的数据存储设备，它使用闪存芯片来读写数据。固态硬盘比机械硬盘速度更快，能够更快地启动计算机和打开文件，且比较抗震抗摔，寿命也更长。但是，固态硬盘价格相对较高，容量相对较小。</p>
<p>在第一节介绍内存的时候，曾说内存就是主存，<strong>但是严格的说，内存包括主存(内存条,基于DRAM)与高速缓存(Cache,基于SRAM)两部分。</strong></p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><h4 id="1-CPU的寄存器"><a href="#1-CPU的寄存器" class="headerlink" title="1. CPU的寄存器"></a>1. CPU的寄存器</h4><p><strong>定义与功能</strong></p>
<ol>
<li><p>寄存器是CPU内部的高速存储单元，用于暂时存储CPU运算过程中的数据和指令。</p>
</li>
<li><p>它们具有极快的访问速度，能够减少CPU对内存的访问次数，提高程序执行效率。</p>
</li>
</ol>
<h4 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h4><p><strong>定义与功能</strong></p>
<ol>
<li><p>内存（RAM，随机存取存储器）是计算机系统中用于存储数据和程序的临时存储器。</p>
</li>
<li><p>提供了较大的存储容量，但相对于CPU的访问速度较慢。</p>
</li>
</ol>
<p><strong>与CPU的关系</strong></p>
<ol>
<li><p>CPU通过内存总线与内存进行通信，以读取和写入数据。</p>
</li>
<li><p>当CPU需要执行程序时，它会从内存中读取指令和数据到寄存器中进行处理。</p>
</li>
</ol>
<h4 id="3-高速缓存（Cache）"><a href="#3-高速缓存（Cache）" class="headerlink" title="3. 高速缓存（Cache）"></a>3. 高速缓存（Cache）</h4><p><strong>定义与功能</strong></p>
<ol>
<li><p>高速缓存是位于CPU和内存之间的一种存储器层次结构，用于存储CPU频繁访问的数据和指令。</p>
</li>
<li><p>它通过减少CPU对内存的访问次数来提高计算机系统的性能。</p>
</li>
</ol>
<p><strong>多级缓存结构</strong></p>
<ol>
<li><p>通常包括L1、L2、L3等多级缓存，其中L1缓存距离CPU最近且速度最快，L2、L3缓存则更大但速度稍慢。</p>
</li>
<li><p>这种多级缓存结构旨在利用容量、速度和成本之间的平衡，以提供更好的性能。</p>
</li>
</ol>
<h4 id="4-寄存器、内存与高速缓存之间的联系"><a href="#4-寄存器、内存与高速缓存之间的联系" class="headerlink" title="4. 寄存器、内存与高速缓存之间的联系"></a>4. 寄存器、内存与高速缓存之间的联系</h4><p><strong>数据传输</strong></p>
<ol>
<li><p>当CPU执行程序时，它会从内存中读取指令和数据到寄存器中进行处理。</p>
</li>
<li><p>如果这些指令和数据已经存储在高速缓存中，则CPU可以直接从缓存中读取，减少了对内存的访问次数。</p>
</li>
</ol>
<p><strong>性能提升</strong></p>
<ol>
<li><p>寄存器和高速缓存的存在大大提高了CPU的数据访问速度，从而提升了计算机系统的整体性能。</p>
</li>
<li><p>它们通过减少CPU对内存的依赖，降低了内存访问的延迟和能耗。</p>
</li>
</ol>
<p><strong>协同工作</strong></p>
<ol>
<li><p>寄存器、内存和高速缓存之间通过复杂的协同工作机制，共同支持CPU的高效运行。</p>
</li>
<li><p>寄存器提供快速的数据访问能力，高速缓存减少了对内存的访问次数，而内存则提供了较大的存储容量以支持复杂的程序和数据结构。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis：持久层技术、ORM框架</title>
    <url>/2024/07/06/mybatis/</url>
    <content><![CDATA[<h1 id="回顾-JDBC开发"><a href="#回顾-JDBC开发" class="headerlink" title="回顾 JDBC开发"></a>回顾 JDBC开发</h1><ol>
<li><p>优点：简单易学,上手快, 非常灵活构建SQL，效率高</p>
</li>
<li><p>缺点：代码繁琐，难以写出高质量的代码（例如：资源的释放，SQL注入安全性等）</p>
</li>
</ol>
<p>开发者既要写业务逻辑，又要写对象的创建和销毁，必须管底层具体数据库的语法</p>
<p>（例如：分页）。</p>
<ol start="3">
<li>适合于超大批量数据的操作，速度快</li>
</ol>
<p>性能：jdbc(80%代码只完成20%的事) &gt; mybatis &gt; hibernate:(from Employee) &gt; jpa</p>
<h1 id="什么是mybatis，有什么特点"><a href="#什么是mybatis，有什么特点" class="headerlink" title="什么是mybatis，有什么特点"></a>什么是mybatis，有什么特点</h1><ol>
<li><p>基于上述二种支持，我们需要在中间找到一个平衡点呢？结合它们的优点，摒弃它们的缺点，这就是myBatis，现今myBatis被广泛的企业所采用。 </p>
</li>
<li><p>MyBatis，前身ibatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。</p>
</li>
<li><p>iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAO）</p>
</li>
<li><p>持久层技术：</p>
</li>
</ol>
<p>​		<strong>jdbc&#x2F;dbutils&#x2F;springDAO</strong></p>
<p>​		ORM ( Object Relationship Mapping)框架：ORM 框架是持久化框架有<strong>mybatis、hibernate、springORM、Java Persistence API (JPA)、toplink、EJB3 EntityBean</strong></p>
<p>​	<a href="http://www.mybatis.cn/archives/2391.html"><a href="http://www.mybatis.cn/">MyBatis中文官网</a></a></p>
<h1 id="1-准备Maven-Pom-xml"><a href="#1-准备Maven-Pom-xml" class="headerlink" title="1.准备Maven Pom.xml"></a>1.准备Maven Pom.xml</h1><p> 在IntelliJ IDEA中配置 <em>pom.xml</em> 引入类库，这样在创建项目时直接引用类库即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 常量声明 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jdk版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 模块的依赖 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mysql driver --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- apache libraries --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 类字节增强库：getter/setter, constructor method etc... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="2-创建POJO实体类"><a href="#2-创建POJO实体类" class="headerlink" title="2. 创建POJO实体类"></a>2. 创建POJO实体类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span> <span class="comment">// lombok类库 生成getter, setter, toString</span></span><br><span class="line"><span class="comment">// @ToString            //生成toString()</span></span><br><span class="line"><span class="comment">// @AllArgsConstructor  //全参数构造</span></span><br><span class="line"><span class="comment">// @NoArgsConstructor   //默认构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="comment">//lombok类库：用注解为实体类的属性生成getter/setter及构造函数等</span></span><br><span class="line">    <span class="keyword">private</span> Integer empno; <span class="comment">//Integer=null, int=0</span></span><br><span class="line">    <span class="keyword">private</span> String ename;</span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line">    <span class="keyword">private</span> Integer mgr;</span><br><span class="line">    <span class="keyword">private</span> Date hiredate;</span><br><span class="line">    <span class="keyword">private</span> Double sal;</span><br><span class="line">    <span class="keyword">private</span> Double comm;</span><br><span class="line">    <span class="keyword">private</span> Integer deptno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-创建-mybatis-config-xml配置文件"><a href="#3-创建-mybatis-config-xml配置文件" class="headerlink" title="3. 创建 mybatis-config.xml配置文件"></a>3. 创建 mybatis-config.xml配置文件</h1><p>在 <code>src/main/resources</code> 目录下新建<code>mybatis-config.xml</code> 配置文件，内容如下：</p>
<ol>
<li><p>（可选）配置相关属性：<code>&lt;properties resource=&quot;jdbc.properties&quot;/&gt; </code> 引入连接信息</p>
</li>
<li><p>（可选）配置实体类别名：<code>&lt;typeAliases&gt; ... &lt;/typeAliases&gt;</code></p>
</li>
</ol>
<ol start="3">
<li><p>配置连接池环境:  <code>&lt;environments default=&quot;...&quot;&gt; ... &lt;/environments&gt;</code></p>
</li>
<li><p>注册SQL Mapper映射文件：</p>
</li>
</ol>
<h2 id="jdbc-properties"><a href="#jdbc-properties" class="headerlink" title="jdbc.properties"></a>jdbc.properties</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/scott?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<h2 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a><strong>mybatis-config.xml</strong></h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载外部的属性文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置不同的数据库环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 开发环境 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注册实体映射文件，里面写SQL --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;mapper resource=&quot;org/mybatis/example/BlogMapper.xml&quot;/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="**&lt;typeAliases&gt;**类型别名"></a>**&lt;typeAliases&gt;**类型别名</h2><p>类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。例如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 为包内的类命名别名：Employee 或 employee --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.glut.mybatismapper.entity&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：<typeAliases>加在<properties>元素的后面，<environments>元素的前面。</environments></properties></typeAliases></strong></p>
<h2 id="特性配置"><a href="#特性配置" class="headerlink" title="**&lt;settings&gt;**特性配置"></a>**&lt;settings&gt;**特性配置</h2><p>MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。具体配置项参考 Mybatis中文参考手册。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 二级缓存开关; 这个配置使全局的映射器启用或禁用二级缓存 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：<settings>加在<properties>元素的后面，<typeAliases>元素的前面。</typeAliases></properties></settings></strong></p>
<h1 id="4-创建-SqlSessionFactory"><a href="#4-创建-SqlSessionFactory" class="headerlink" title="4. 创建 SqlSessionFactory"></a>4. 创建 SqlSessionFactory</h1><ul>
<li><p>通过加载核心配置文件创建SqlSessionFactory实例，SqlSessionFactory是一个应用程序内全局单一的实例，支持多线程安全操作</p>
</li>
<li><p>通过SqlSessionFactory 获得 SqlSession 操作数据库，所有的数据库操作通过SqlSession 完成。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">      <span class="comment">// 加载核心配置文件</span></span><br><span class="line">      <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">      <span class="comment">// sql会话工厂，此对象类似 DataSource</span></span><br><span class="line">      <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 得到sql会话对象,它封装了Connection， 此对象类似 java.sql.Connection</span></span><br><span class="line">      <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">      System.out.println(sqlSession.getConnection());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行查询</span></span><br><span class="line">      <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> sqlSession.selectList(<span class="string">&quot;名字空间 + 语句 ID&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-编写XML映射文件"><a href="#5-编写XML映射文件" class="headerlink" title="5. 编写XML映射文件"></a>5. 编写XML映射文件</h1><p>SQL语句元素有：</p>
<ul>
<li>select</li>
<li>insert</li>
<li>update</li>
<li>delete</li>
<li>sql</li>
</ul>
<p>Mybatis XML映射文件中可用来生成动态 SQL 的 XML 元素有：</p>
<ul>
<li>where</li>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
<li>bind</li>
</ul>
<p><strong>创建一个包：com.lanqiao.mapper</strong></p>
<ol>
<li><p>创建 XML 映射文件，编写sql语句</p>
</li>
<li><p>编写结果映射配置:  <resultMap id type="实体类全类名"></resultMap></p>
</li>
<li><p>主要的XML元素:</p>
</li>
</ol>
<h2 id="5-1-根元素"><a href="#5-1-根元素" class="headerlink" title="5.1 **&lt;mapper&gt;**根元素"></a>5.1 **&lt;mapper&gt;**根元素</h2><ul>
<li>namespace: 命名空间，通常是接口映射的全类名。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-2-与-元素"><a href="#5-2-与-元素" class="headerlink" title="5.2 **&lt;select&gt; ** 与 **&lt;where&gt;**元素"></a>5.2 **&lt;select&gt; ** 与 **&lt;where&gt;**元素</h2><p><code>&lt;select&gt;</code>元素用来编写select语句。</p>
<p><code>&lt;where&gt;</code>元素会生成一个 <code>WHERE</code>关键字。</p>
<ul>
<li><p><code>&lt;select resultType=&quot;POJO全类名&quot;&gt;</code>: 自动查询结果映射，要求结果集的列与实体类的属性名一致不区分大小写。</p>
</li>
<li><p><code>&lt;select resultMap=&quot;REF_ResultMap_ID&quot;&gt;</code>：手动结果映射，这种是推荐结果映射方式，这种方式比较灵活，而合适多表查询的结果映射。</p>
</li>
<li><p><code>&lt;bind name=&quot;变量名&quot; value=&quot;&quot;&gt;</code>: 绑定生成新变量在后面用于</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">     SELECT * FROM EMP WHERE EMPNO=#&#123;empno,jdbcType=INTEGER&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Employee&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;baseResultMap&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM EMP</span><br><span class="line">    <span class="comment">&lt;!-- 动态WHERE, 会生成一个 WHERE关键字,并且会消除条件中多余的 AND 或 OR关键字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 在Java 里把 %JAMES% 拼好 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;if test=&quot;ename != null&quot;&gt;AND ENAME like #&#123;ename&#125;&lt;/if&gt; --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;enamePattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + ename + &#x27;%&#x27;&quot;</span>/&gt;</span></span><br><span class="line">        AND ENAME like #&#123;enamePattern&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null and job.trim().length()&gt;0&quot;</span>&gt;</span>AND JOB=trim(#&#123;job&#125;)<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span>&lt;![CDATA[ AND SAL&lt;=#&#123;sal&#125; ]]&gt;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptnoList != null&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;deptnoList&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">open</span>=<span class="string">&quot;AND DEPTNO in(&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> </span></span><br><span class="line"><span class="tag">                 <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">          #&#123;deptno&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：以上where 条件中<code>SAL &lt;=#&#123;sal&#125;</code>  的小于号是 XML 的无字符，需要放在XML CDATA 节点内，</strong></p>
<p><strong><code>&lt;![CDATA[ AND SAL&lt;=#&#123;sal&#125; ]]&gt;</code></strong></p>
<h2 id="5-3-结果映射元素"><a href="#5-3-结果映射元素" class="headerlink" title="5.3 **&lt;resultMap&gt;**结果映射元素"></a>5.3 **&lt;resultMap&gt;**结果映射元素</h2><p><code>&lt;resultMap&gt;</code>元素用来将查询结果集映射到实体。<code>&lt;resultMap&gt;</code>内部有以下几个主要元素：</p>
<ul>
<li><p><code>&lt;id&gt;</code>元素专门用于<em>映射主键字段</em></p>
<ul>
<li>javaType: 映射的 Java 属性类型，可以mybatis 预定义的类型别名（在第 8 节）或类型的全类名。</li>
<li>jdbcType: jdbc的类型名称（在第 7 节）。</li>
<li>typeHandler：类型处理器。无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。Mybatis 已定义了一些默认的类型处理器。</li>
</ul>
</li>
<li><p><code>&lt;result&gt;</code>元素用于映射普通字段。<result>元素的属性与<id>元素的的属性一样。</id></result></p>
</li>
<li><p><code>&lt;association&gt;</code>元素用于M:1多对一关联中映射 1方的实体</p>
</li>
<li><p><code>&lt;collection&gt;</code> 元素用于1:M一对多关联中映射 M方的实体</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;BaseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lanqiao.domain.Employee&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;empno&quot;</span> <span class="attr">column</span>=<span class="string">&quot;empno&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;job&quot;</span> <span class="attr">column</span>=<span class="string">&quot;job&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;VARCHAR&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;mgr&quot;</span> <span class="attr">column</span>=<span class="string">&quot;mgr&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;hiredate&quot;</span> <span class="attr">column</span>=<span class="string">&quot;hiredate&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DATE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sal&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sal&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;comm&quot;</span> <span class="attr">column</span>=<span class="string">&quot;comm&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;DECIMAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">jdbcType</span>=<span class="string">&quot;INTEGER&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="5-3-1-多对一关联映射"><a href="#5-3-1-多对一关联映射" class="headerlink" title="5.3.1 **&lt;association&gt;**多对一关联映射"></a>5.3.1 **&lt;association&gt;**多对一关联映射</h3><p>常用的两种实体关联映射有：</p>
<ul>
<li><strong>M:1（多对一关联映射）</strong></li>
<li><strong>1:1（一对一关联映射）</strong></li>
</ul>
<p>实体的 M:1(多对一)关联中使用<code>&lt;association&gt;&lt;/association&gt;</code>映射，关联元素处理“有一个”类型的关系，如一个员工属于一个部门。</p>
<p><strong>多对一关联有以下两种映射方式：</strong></p>
<ol>
<li><strong>(推荐）嵌套结果</strong></li>
</ol>
<p>​	使用嵌套结果映射来处理重复的联合结果的子集。首先让我们来查看这个元素的属性。所有的结果集你都会看到，它和普通的只由 <code>select </code>和 <code>resultMap</code> <em>属性</em>的结果映射不同。</p>
<p>​	<em>嵌套结果要求使用一条SQL语句查询出实体与关联实体（关联表）的数据，效率好。</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Employee&quot;</span>&gt;</span></span><br><span class="line">  省略其它字段的映射....</span><br><span class="line">  <span class="comment">&lt;!-- 1.嵌套结果（推荐使用）: --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Department&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DEPTNO&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">column</span>=<span class="string">&quot;DNAME&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span> <span class="attr">column</span>=<span class="string">&quot;LOC&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">association</span>&gt;</span> </span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 或者也可以引用另一个名字空间下的结果映射，这样可以减少一些映射配置</span></span><br><span class="line"><span class="comment">  &lt;association property=&quot;dept&quot; </span></span><br><span class="line"><span class="comment">      resultMap=&quot;com.lanqiao.mapper.DepartmentMapper.baseResultMap&quot;&gt;</span></span><br><span class="line"><span class="comment">  &lt;/association&gt;</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>嵌套查询</strong></li>
</ol>
<p><em>嵌套查询 (性能差)</em>: 通过执行另外一个 SQL 映射语句来返回预期的复杂类型(JavaBean)。也就是说每个关联的实体都通过一条单独的 SQL来查询。</p>
<p>这种方式很简单, 但是对于大型数据集合和列表将不会表现很好。问题就是我们熟知的 <strong>“N+1 查询问题”</strong>。</p>
<blockquote>
<p><strong>（面试题）</strong>在mybatis的查询中什么是<strong>N+1</strong>次查询，即嵌套查询中的<strong>N+1</strong>问题：这种关联会发生<strong>N+1</strong>次查询问题。N指的是执行了多少条SQL语句获取关联实体，1指的是主查询。如下映射所示：</p>
</blockquote>
<ul>
<li><p>一条语句为查询员工实体：</p>
<p><code>select * from scott.emp</code>  </p>
<p>你执行了一个单独的 SQL 语句来获取员工结果列表(<strong>就是“+1”</strong>)。</p>
</li>
<li><p>N条语句为查询每个员工关联的部门实体</p>
<p>对返回的每条记录, 你执行了一个查询语句来为每个实体加载细节(<strong>就是“N”</strong>)。</p>
<p>当一条语句查询出员工的结果集时，员工结果集中关联的每个部门 (10,20,30,40) 都会导致执行了N 条 SQL语句查询部门实体，<em>已被查询出的部门实体会被缓存在mybatis的一级缓存 SqlSession中</em>：</p>
<p><code>select * from  scott.dept=10;</code>   </p>
<p><code>select * from scott.dept=20;</code>  </p>
<p><code>......</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseResultMap_2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用单独的语句查询关联实体，column=&quot;deptno&quot;员工表外键 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectDeptByPrimaryKey&quot;</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDeptByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">&quot;deptResultMap&quot;</span>&gt;</span></span><br><span class="line">  	select * from dept where deptno=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-3-2-一对多关联映射"><a href="#5-3-2-一对多关联映射" class="headerlink" title="5.3.2 **&lt;collection&gt;**一对多关联映射"></a>5.3.2 **&lt;collection&gt;**一对多关联映射</h3><p>1:M（一对多）关联使用<code>&lt;collection ofType=&quot;元素类型&quot; column=&quot;外键字段&quot;&gt;&lt;/collection&gt;</code>元素，要映射Many端结果到List集合中，我们使用集合元素。</p>
<p>映射集合也有两种方式：</p>
<ul>
<li><p><strong>1（推荐使用）嵌套结果</strong></p>
<p>​    <code>&lt;collection property=&quot;属性名&quot; ofType=&quot;集合元素的类型&quot; column=&quot;外键列&quot;&gt;</code></p>
<p>​    <code>&lt;/collection&gt;</code></p>
<p>​    结果映射引用了<code>EmployeeMapper.xml</code> 中的 <code>baseResultMap</code> 结果映射配置.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;departemnt&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span>       <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span>    <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span>      <span class="attr">column</span>=<span class="string">&quot;loc&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;employeeList&quot;</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">ofType</span>=<span class="string">&quot;employee&quot;</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">resultMap</span>=<span class="string">&quot;com.lanqiao.mapper.EmployeeMapper.baseResultMap&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>2. 嵌套查询</strong></p>
<p>通过在<code>&lt;collection&gt;&lt;/collection&gt;</code>元素上指定<code>select=&quot;查询 Many端实体的语句&quot; </code>属性，</p>
<p>该属性会使用当前实体的主键（Many端为外键）来执行另一条查询语句获取Many端实体，并将获取到的Many端实体存入集合中。</p>
<p>​    <code>&lt;collection property=&quot;属性名&quot; ofType=&quot;属性类型&quot; column=&quot;外键列&quot; select=&quot;查询 Many端实体的语句&quot;&gt;</code></p>
<p>​    <code>&lt;/collection&gt;</code></p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;baseResultMap_2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;departemnt&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span>       <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span>    <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span>      <span class="attr">column</span>=<span class="string">&quot;loc&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;employeeList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">select</span>=<span class="string">&quot;selectEmployeeByDeptno&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByDeptno&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resultMap</span>=<span class="string">&quot;com.lanqiao.mapper.EmployeeMapper.baseResultMap&quot;</span>&gt;</span></span><br><span class="line">   select *</span><br><span class="line">   from emp</span><br><span class="line">   where deptno=#&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><em>优点：编写<strong>SQL</strong>简单，无需做多表的连接查询；关联的实体通过单独的<strong>SQL</strong>语句查询并单独封装。<br> 缺点：执行了<strong>N+1</strong>条件语句。性能差</em></p>
<h2 id="5-4-通用-SQL-片段"><a href="#5-4-通用-SQL-片段" class="headerlink" title="5.4 **&lt;sql&gt;**通用 SQL 片段"></a>5.4 **&lt;sql&gt;**通用 SQL 片段</h2><p><em>通用 SQL片段</em>，可被其他语句引用的可重用语句块。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;Base_Column_List&quot;</span>&gt;</span></span><br><span class="line">  empno,ename,job,mgr,hiredate,sal,comm,deptno,header</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">resultMap</span>=<span class="string">&quot;BaseResultMap&quot;</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;Base_Column_List&quot;</span> /&gt;</span></span><br><span class="line">    from emp</span><br><span class="line">    where  empno = #&#123;empno,jdbcType=INTEGER&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="5-5-元素"><a href="#5-5-元素" class="headerlink" title="5.5 **&lt;if&gt;**元素"></a>5.5 **&lt;if&gt;**元素</h2><p><code>&lt;if&gt;</code>元素用以根据条件判断生成动态SQL。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1.在程序里把 %JAMES% 拼好 </span></span><br><span class="line"><span class="comment">		emp.setEname(&quot;%J%&quot;);</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span></span><br><span class="line">    AND ENAME like #&#123;ename&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">	<span class="comment">&lt;!-- 2.在XML里把 % 拼好 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;enamePattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + ename + &#x27;%&#x27;&quot;</span>/&gt;</span></span><br><span class="line">    AND ENAME like #&#123;enamePattern&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- SQL中遇到小于号用 CDATA 元素包裹起来。大于号可以直接用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[ AND SAL&lt;=#&#123;sal&#125;  ]]&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- trim(#&#123;job&#125;) 是mysql的trim()函数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null and job.trim().length()&gt;0&quot;</span>&gt;</span></span><br><span class="line">    AND JOB=trim(#&#123;job&#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h2 id="5-6-元素"><a href="#5-6-元素" class="headerlink" title="5.6 **&lt;choose&gt;**元素"></a>5.6 **&lt;choose&gt;**元素</h2><p>分支结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 类似 java的 switch --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span> <span class="comment">&lt;!-- java switch case --&gt;</span></span><br><span class="line">      sql语句</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span> <span class="comment">&lt;!-- java switch default --&gt;</span></span><br><span class="line">       sql语句</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="5-7-元素"><a href="#5-7-元素" class="headerlink" title="5.7**&lt;foreach&gt;**元素"></a>5.7**&lt;foreach&gt;**元素</h2><p><code> &lt;foreach&gt;</code>元素通过遍历集合来产生动态 SQL。</p>
<ul>
<li>java 代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span> <span class="comment">// @Data = @Getter + @Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="comment">//省略其它属性</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//用于查询条件的多个部门号</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; deptnoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>xml 映射</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptnoList != null&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;deptnoList&quot;</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">open</span>=<span class="string">&quot;AND DEPTNO in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">    #&#123;deptno&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-8-元素"><a href="#5-8-元素" class="headerlink" title="5.8**&lt;trim&gt;**元素"></a>5.8**&lt;trim&gt;**元素</h2><p><code>&lt;trim&gt;</code> 元素用于删除空格或删除指定字符，并添加上指定的前缀字符 和 后缀字符。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;加上前缀字符&quot;</span> <span class="attr">suffix</span>=<span class="string">&quot;加上的后缀字符&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">prefixOverrides</span>=<span class="string">&quot;被删除的前缀字符&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;被删除的后缀字符&quot;</span>&gt;</span></span><br><span class="line">   	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span>ename,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>job,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;mgr != null&quot;</span>&gt;</span>mgr,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>示例：用来前置<code>SET</code>关键字和清除最后的逗号</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update_2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">    update emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;set&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span>ENAME=#&#123;ename&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>JOB=#&#123;job&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span>SAL=#&#123;sal&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comm != null&quot;</span>&gt;</span>COMM=#&#123;comm&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empno != null&quot;</span>&gt;</span>EMPNO=#&#123;empno&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-9-元素、set元素"><a href="#5-9-元素、set元素" class="headerlink" title="5.9**&lt;update&gt;**元素、set元素"></a>5.9**&lt;update&gt;**元素、set元素</h2><p><code>&lt;set&gt;</code>元素会前置一个<code>SET</code>关键字，<em>同时会删除最后多余的逗号</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">  update emp</span><br><span class="line">  <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span>ENAME=#&#123;ename&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>JOB=#&#123;job&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span>SAL=#&#123;sal&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comm != null&quot;</span>&gt;</span>COMM=#&#123;comm&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empno != null&quot;</span>&gt;</span>EMPNO=#&#123;empno&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="5-10-元素"><a href="#5-10-元素" class="headerlink" title="5.10**&lt;insert&gt;**元素"></a>5.10**&lt;insert&gt;**元素</h2><p>insert语句没有resultMap，默认返回整数即插入的行数.<br><em>如果某些字段允许为 null 时，安全的做法就是对这样的列做 空值处理，这不是 mybaits 需要的，而是不同数据的驱动需要。</em></p>
<ul>
<li><p><code>useGeneratedKeys=&quot;true&quot;</code> : 说明主键值由数据库生成</p>
</li>
<li><p><code>keyProperty=&quot;empno&quot; </code>: 自动生成的主键值赋给 POJO 的哪个属性</p>
</li>
<li><p><code>keyColumn=&quot;empno&quot;</code>: 自动生成主键值的列</p>
</li>
</ul>
<p><strong>示例 1：使用 JDBC null 值处理</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;employee&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;empno&quot;</span> <span class="attr">keyColumn</span>=<span class="string">&quot;empno&quot;</span>&gt;</span></span><br><span class="line">    insert into emp(ename, job, mgr, hiredate, sal, comm, deptno)</span><br><span class="line">    values (#&#123;ename&#125;,#&#123;job,jdbcType=VARCHAR&#125;,#&#123;mgr,jdbcType=INTEGER&#125;,#&#123;hiredate,jdbcType=DATE&#125;,#&#123;sal,jdbcType=DOUBLE&#125;,#&#123;comm,jdbcType=DOUBLE&#125;,#&#123;deptno,jdbcType=INTEGER&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>示例 2：使用&lt;trim&gt;元素</strong></p>
<p><trim prefix="加上前缀字符" suffix="加上的后缀字符" prefixoverrides="被删除的前缀字符" suffixoverrides="被删除的后缀字符"></trim></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态 insert语句，就是说页面过来有值的字段生成SQL,无值的字段不生成SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert_2&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">  insert into emp(</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span>ename,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>job,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;mgr != null&quot;</span>&gt;</span>mgr,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hiredate != null&quot;</span>&gt;</span>hiredate,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span>sal,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comm != null&quot;</span>&gt;</span>comm,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptno != null&quot;</span>&gt;</span>deptno,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span>)</span><br><span class="line">  values(</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename != null&quot;</span>&gt;</span>#&#123;ename&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;job != null&quot;</span>&gt;</span>#&#123;job&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;mgr != null&quot;</span>&gt;</span>#&#123;mgr&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;hiredate != null&quot;</span>&gt;</span>#&#123;hiredate&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal != null&quot;</span>&gt;</span>#&#123;sal&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;comm != null&quot;</span>&gt;</span>#&#123;comm&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;deptno != null&quot;</span>&gt;</span>#&#123;deptno&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span>)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="6-接口映射器"><a href="#6-接口映射器" class="headerlink" title="6. 接口映射器"></a>6. 接口映射器</h1><p>映射器接口执行SQL语句的规则：</p>
<ol>
<li><p>XML 映射文件 *.xml的名字空间(<em>namespace</em>)必须和<em>映射器接口全类名一致</em>,必须放在与映射器接口相同的包下。</p>
<p>接口映射器类全名：<code>org.glut.mybatis.mapper.EmployeeMapper</code> (名字空间)</p>
</li>
</ol>
<ul>
<li>接口映射器 Java</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.glut.mybatis.mapper;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeMapper</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> Employee <span class="title function_">selectByPrimaryKey</span><span class="params">(Integer empno)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>XML映射文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.glut.mybatis.mapper.EmployeeMapper&quot;</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> </span></span><br><span class="line"><span class="tag">            <span class="attr">resultType</span>=<span class="string">&quot;Employee&quot;</span>&gt;</span></span><br><span class="line">      select * from emp where empno=#&#123;id&#125;</span><br><span class="line">  	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>selectByPrimaryKey(Integer empno) </code>方法名对应 *.xml中的语句ID</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByPrimaryKey&quot;</span> <span class="attr">....</span>&gt;</span></span><br><span class="line">  SQL....</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>selectByPrimaryKey(Integer empno)</code>参数类型对应SQL语句所需的参数类型</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">....</span>&gt;</span></span><br><span class="line">    SQL....</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>Employee selectByPrimaryKey(Integer empno)</code>返回值  对应 SQL语句的查询结果类型</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">resultType</span>=<span class="string">&quot;Employee&quot;</span> <span class="attr">....</span>&gt;</span></span><br><span class="line">    SQL....</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span>  </span><br></pre></td></tr></table></figure>

<p><em>如果是 insert,update,delete 操作那么方法声明返回 int 类型</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(Employee parameter)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(Employee parameter)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(Integer empno)</span>;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在<code>mybatis-config.xml</code> 配置文件中配置接口映射器</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mapper/EmployeeMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;package name=&quot;XML映射文件所在包&quot;/&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在程序中使用接口映射器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> SqlSession.getMapper(EmployeeMapper.class);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 通过EmployeeMapper接口全类名 与 EmployeeMapper.xml文件中的命名空间匹配.</span></span><br><span class="line"><span class="comment">* 调用的select() 方法其方法名“select”为 EmployeeMapper.xml文件中的语句ID.</span></span><br><span class="line"><span class="comment">* select()方法返回类型与 sql语句的查询结果匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.selectByPrimaryKey(<span class="number">1234</span>);</span><br></pre></td></tr></table></figure>

<h1 id="7-支持的-JDBC-类型"><a href="#7-支持的-JDBC-类型" class="headerlink" title="7.支持的 JDBC 类型"></a>7.支持的 JDBC 类型</h1><p>为了未来的参考,MyBatis 通过包含的 <em>jdbcType枚举型</em>,支持下面的 JDBC 类型。 </p>
<p><code>java.sql.Types</code>中定义的常量。</p>
<table>
<thead>
<tr>
<th><strong>BIT</strong></th>
<th><strong>FLOAT</strong></th>
<th><strong>CHAR</strong></th>
<th><strong>TIMESTAMP</strong></th>
<th>OTHER</th>
<th>UNDEFINED</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>REAL</td>
<td><strong>VARCHAR</strong></td>
<td>BINARY</td>
<td><strong>BLOG</strong></td>
<td>NVARCHAR</td>
</tr>
<tr>
<td>SMALLINT</td>
<td><strong>DOUBLE</strong></td>
<td>LONGVARCHAR</td>
<td>VARBINARY</td>
<td><strong>CLOB</strong></td>
<td>NCHAR</td>
</tr>
<tr>
<td><strong>INTEGER</strong></td>
<td><strong>NUMERIC</strong></td>
<td><strong>DATE</strong></td>
<td>LONGVARBINARY</td>
<td><strong>BOOLEAN</strong></td>
<td>NCLOB</td>
</tr>
<tr>
<td>BIGINT</td>
<td><strong>DECIMAL</strong></td>
<td>TIME</td>
<td>NULL</td>
<td>CURSOR</td>
<td>ARRAY</td>
</tr>
</tbody></table>
<h1 id="8-支持的-Java类型"><a href="#8-支持的-Java类型" class="headerlink" title="8. 支持的 Java类型"></a>8. 支持的 Java类型</h1><p>mybatis已经为许多常见的 Java 类型内建了相应的<em>类型别名</em>。它们都是大小写不敏感的，<em>需要注意的是由基本类型名称重复导致的特殊处理“带下划线”</em>。</p>
<table>
<thead>
<tr>
<th><em>别名</em></th>
<th><em>映射的Java类型</em></th>
</tr>
</thead>
<tbody><tr>
<td><strong>_byte</strong></td>
<td>byte</td>
</tr>
<tr>
<td><strong>_long</strong></td>
<td>long</td>
</tr>
<tr>
<td><strong>_short</strong></td>
<td>short</td>
</tr>
<tr>
<td><strong>_int</strong></td>
<td>int</td>
</tr>
<tr>
<td><strong>_integer</strong></td>
<td>int</td>
</tr>
<tr>
<td><strong>_double</strong></td>
<td>double</td>
</tr>
<tr>
<td><strong>_float</strong></td>
<td>float</td>
</tr>
<tr>
<td><strong>_boolean</strong></td>
<td>boolean</td>
</tr>
<tr>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>integer</td>
<td>Integer</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>date</td>
<td>Date</td>
</tr>
<tr>
<td>decimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>bigdecimal</td>
<td>BigDecimal</td>
</tr>
<tr>
<td>object</td>
<td>Object</td>
</tr>
<tr>
<td>map</td>
<td>Map</td>
</tr>
<tr>
<td>hashmap</td>
<td>HashMap</td>
</tr>
<tr>
<td>list</td>
<td>List</td>
</tr>
<tr>
<td>arraylist</td>
<td>ArrayList</td>
</tr>
<tr>
<td>collection</td>
<td>Collection</td>
</tr>
<tr>
<td>iterator</td>
<td>Iterator</td>
</tr>
</tbody></table>
<h1 id="9-expr-与-expr-的区别"><a href="#9-expr-与-expr-的区别" class="headerlink" title="9. #{expr}与 ${expr} 的区别"></a>9. #{expr}与 ${expr} 的区别</h1><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#&#123;ename&#125;: mybatis会将该表达解析成预译语句的 ？号（占位符）。</span><br><span class="line">$&#123;ename&#125;: mybatis不将这种表达式解析成预编译语句的 ？号，而是将它直接作为值来处理。这种语法不安全会有SQL注入攻击的风险。</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">and</span> ename <span class="keyword">like</span> <span class="string">&#x27;$&#123;ename&#125;&#x27;</span>  #生成<span class="comment">--&gt; and ename like &#x27;%J%&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">order</span> <span class="keyword">by</span> $&#123;orderBy&#125;  # orderBy是 Java 里的一个属性</span><br></pre></td></tr></table></figure>



<h1 id="10-SqlSession-持久化操作"><a href="#10-SqlSession-持久化操作" class="headerlink" title="10. SqlSession 持久化操作"></a>10. SqlSession 持久化操作</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession.selectList(<span class="string">&quot;语句ID&quot;</span> [, parameter]);</span><br><span class="line">SqlSession.selectOne(<span class="string">&quot;语句ID&quot;</span> [, parameter]);</span><br><span class="line">SqlSession.insert(<span class="string">&quot;语句ID&quot;</span>, parameter);</span><br><span class="line">SqlSession.delete(<span class="string">&quot;语句ID&quot;</span>, parameter);</span><br><span class="line">SqlSession.update(<span class="string">&quot;语句ID&quot;</span>, parameter);</span><br><span class="line">T <span class="title function_">getMapper</span><span class="params">(Class&lt;T&gt; cls)</span>; <span class="comment">//获取接口映射器</span></span><br></pre></td></tr></table></figure>

<p>parameter 参数对象为调用 SQL语句时所需的占位符参数，一般为 POJO对象。</p>
<p>#11.（重要）mybatis工作流程</p>
<ol>
<li><p>通过<code>Reader</code>对象读取<code>mybatis-config.xml</code>配置文件(该文本的位置和名字可任意)</p>
</li>
<li><p>通过<code>SqlSessionFactoryBuilder</code>对象创建<code>SqlSessionFactory</code>（类似<code>javax.sql.DataSource</code>）对象。</p>
</li>
</ol>
<p>注：如果要在应用程序中使用二级缓存那么可利用第三方的缓存（ehcache等），mybatis提供集成方案。</p>
<ol start="3">
<li>从<code>SqlSessionFactory</code>中获取<code>SqlSession</code>（封装了<code>java.sql.Connection</code>）对象，将<code>sqlSession</code>称为一级缓存。</li>
</ol>
<p><em>说明：</em></p>
<h2 id="SessionFactoryBuilder"><a href="#SessionFactoryBuilder" class="headerlink" title="SessionFactoryBuilder"></a><strong>SessionFactoryBuilder</strong></h2><p><em>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory</em>，就不再需要它了。因此 <code>SqlSessionFactoryBuilder</code> 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 <code>SqlSessionFactoryBuilder</code> 来创建多个 <code>SqlSessionFactory </code>实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p>
<h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a><strong>SqlSessionFactory</strong></h2><p><code>SqlSessionFactory</code><em>的缓存称为：二级（全局）缓存</em></p>
<p><code>SqlSessionFactory</code> 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 <code>SqlSessionFactory</code> 的最佳实践是在应用运行期间不要重复创建多次，多次重建 <code>SqlSessionFactory</code> 被视为一种代码“坏味道（bad smell）”。因此<code> SqlSessionFactory</code> 的最佳作用域是应用程序作用域级。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a><strong>SqlSession</strong></h2><p><code>SqlSession</code><em>的缓存称为：一级（线程级、事务级）缓存</em></p>
<p>每个线程都应该有它自己的 <code>SqlSession</code> 实例。<code>SqlSession</code> 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将<code> SqlSession</code> 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 <code>SqlSession</code> 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 <code>HttpSession</code>。如果你现在正在使用一种 Web 框架，要考虑 <code>SqlSession</code> 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 <code>SqlSession</code>，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。</p>
<ol>
<li><p>事务开始，在mybatis中事务是默认开启的, 但自动提交是关闭的。</p>
</li>
<li><p>通过<code>SqlSession</code>对象读取<code>EmployeeMapper.xm</code>l映射文件中的操作语句ID，从而读取sql语句。</p>
</li>
<li><p>事务提交。</p>
<ul>
<li><p><code>sqlSession.commit() </code>： 提交事务</p>
</li>
<li><p><code>sqlSession.rollback()</code>：回滚事务</p>
</li>
</ul>
</li>
<li><p>关闭<code>SqlSession</code>对象，释放数据库连接，提高数据库连接的重用性。让mybatis能响应更多的用户请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用try-finally 结构自动关闭 SqlSession</span></span><br><span class="line"><span class="keyword">try</span> ( <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> MybatisUtil.getSqlSession() ) &#123;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="11-二级缓存配置"><a href="#11-二级缓存配置" class="headerlink" title="11. 二级缓存配置"></a>11. 二级缓存配置</h1><p><strong>SqlSession</strong>级的缓存称为一级缓存、事务级缓存、线程级缓存。</p>
<p><strong>SqlSessionFactory</strong>级的缓存称为二级缓存、应用级缓存、全局缓存。Mybatis除了自身提供二级缓存的实现外，同时也提供对第三方缓存的支持，如：<em>Redis, Ehcache, Memory Cache</em>等。</p>
<h2 id="11-1-修改mybatis-config-xml"><a href="#11-1-修改mybatis-config-xml" class="headerlink" title="11.1 修改mybatis-config.xml"></a>11.1 修改mybatis-config.xml</h2><p><em>默认二级缓存是开启的</em>，如果要启用二级缓存，需要在mybatis-config.xml文件中加入下面设置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  	<span class="comment">&lt;!--  设置日志的实现方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个配置使全局的映射器启用或禁用二级缓存 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="11-2-在SQL-Mapper映射文件中"><a href="#11-2-在SQL-Mapper映射文件中" class="headerlink" title="11.2 在SQL Mapper映射文件中"></a>11.2 在SQL Mapper映射文件中</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 缓存实体，此元素只对当前名字空间内的实体查询有效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">&quot;LRU&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">flushInterval</span>=<span class="string">&quot;60000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">size</span>=<span class="string">&quot;1024&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--也可让某查询不使用二经缓存，只需在&lt;selec&gt;元素中使用useCache=“true” </span></span><br><span class="line"><span class="comment">     flushCache=&quot;false&quot; </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;select&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;string&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;integer&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    Select_statement</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><cache> 这个简单语句的效果如下:</cache></p>
<ul>
<li><p><em>映射语句文件中的所有 <code>select</code> 语句将会被缓存</em>。</p>
</li>
<li><p><em>映射语句文件中的所有 <code>insert,update</code> 和 <code>delete</code> 语句会刷新缓存</em>。</p>
</li>
<li><p>缓存会使用 Least Recently Used (LRU,最近最少使用的)算法来收回。</p>
</li>
<li><p>根据时间表(比如 no Flush Interval,没有刷新间隔), 缓存不会以任何时间顺序来刷新。</p>
</li>
<li><p>缓存会存储列表集合或对象(无论查询方法返回什么)的 1024 个引用。</p>
</li>
<li><p>缓存会被视为是 read&#x2F;write(可读&#x2F;可写)的缓存,意味着对象检索不是共享的,而且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。</p>
</li>
</ul>
<p>可用的<em>收回策略</em>(<code>eviction</code>)有： </p>
<ul>
<li><p><em>LRU –  最近最少使用的</em>：移除最长时间不被使用的对象。 </p>
</li>
<li><p><em>FIFO –  先进先出</em>：按对象进入缓存的顺序来移除它们。 </p>
</li>
<li><p><em>SOFT –  软引用</em>：移除基于垃圾回收器状态和软引用规则的对象。 </p>
</li>
<li><p><em>WEAK –  弱引用</em>：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</p>
</li>
</ul>
<p><strong>默认的是</strong> LRU收回策略。</p>
<ul>
<li><p>flushInterval（刷新间隔）可以被设置为任意的正整数，而且它们代表一个合理的<strong>毫秒</strong>形式的时间段。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。 </p>
</li>
<li><p>size（引用数目）可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目。默认值1024。 </p>
</li>
<li><p>readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。</p>
</li>
</ul>
<h2 id="11-3-实体类实现java-io-Serializable接口"><a href="#11-3-实体类实现java-io-Serializable接口" class="headerlink" title="11.3 实体类实现java.io.Serializable接口"></a>11.3 实体类实现java.io.Serializable接口</h2><p><strong>如果二级缓存想要命中实现，则必须要将上一次<strong><strong>sqlSession commit</strong></strong>之后才能生效**</strong>;**</p>
<p>缓存实体，只对当前名字空间内的实体查询有效。默认数据被缓存在java.io.tmpdir (JVM的一个属性)</p>
<p><strong>注意：</strong></p>
<ol>
<li><p>多表连接查询时关联实体不做缓存</p>
</li>
<li><p>mybatis的缓存是基于SQL语句id（namespace + select_id）做标识的</p>
</li>
<li><p>查询后要调用<strong>SqlSession.commit();</strong> 数据才会被缓存</p>
</li>
</ol>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>软件技术</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库：（一）索引底层原理与实现</title>
    <url>/2024/06/29/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="一、-什么是索引？"><a href="#一、-什么是索引？" class="headerlink" title="一、 什么是索引？"></a>一、 什么是索引？</h2><p>索引是一个排序的列表，在这个列表中存储着索引的值和包含这个值的数据所在行的物理地址，可以大大加快查询的速度，使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据。索引的作用类似于书的目录，可以根据目录中的页码快速找到所需的内容。</p>
<h3 id="1-1-索引概述（了解）"><a href="#1-1-索引概述（了解）" class="headerlink" title="1.1 索引概述（了解）"></a>1.1 索引概述（了解）</h3><p>当数据保存在磁盘类存储介质上时，它是作为数据块存放。这些数据块是被当作一个整体来访问的，这样可以保证操作的原子性。硬盘数据块存储结构类似于链表，都包含数据部分，以及一个指向下一个节点（或数据块）的指针，不需要连续存储。</p>
<p>记录集只能在某个关键字段上进行排序，所以如果需要在一个无序字段上进行搜索，就要执行一个线性搜索（Linear Search）的过程，平均需要访问 N&#x2F;2 的数据块，N 是表示所占据的数据块数目。如果这个字段是一个非主键字段（也就是说，不包含唯一的访问入口）， 那么需要在 N 个数据块上搜索整个表格空间。</p>
<p>但是对于一个有序字段，可以运用二分查找（BinarySearch），这样只需要访问 log2(N)的数据块。这就是为什么数据表使用索引后性能可以得到本质上提高的原因。</p>
<p>索引是对记录集的多个字段进行排序的方法。在一张表中为一个字段创建一个索引，将创建另外一个数据结构，包含字段数值以及指向相关记录的指针，然后对这个索引结构进行排序，允许在该数据上进行二分法排序。索引需要额外的磁盘空间。</p>
<p>对于 MyISAM 引擎而言，这些索引是被统一保存在一张表中的。如果很多字段都建立了索引，那么会占用大量的磁盘空间，这个文件将很快到达底层文件系统所能够支持的大小限制。</p>
<h4 id="1-1-1-索引的作用"><a href="#1-1-1-索引的作用" class="headerlink" title="1.1.1 索引的作用"></a>1.1.1 索引的作用</h4><p>索引除了快没有其他的作用，数据库利用各种各样的快速定位技术，能够大大提高查询效率。特别是当数据量非常大，查询涉及多个表时，使用索引往往能使查询速度加快成千上万倍。</p>
<h4 id="1-1-2-索引的查找过程"><a href="#1-1-2-索引的查找过程" class="headerlink" title="1.1.2 索引的查找过程"></a>1.1.2 索引的查找过程</h4><p>举一个例子，三个表t1、t2、t3，每个表中只有一个字段，但是每一个表中都有1000行记录，这些记录都是1~1000的数字。</p>
<p>执行以下的查找语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt;SELECT c1,c2,c3 FROM t1,t2,t3 WHERE c1=c2 AND c1=c3;</span><br></pre></td></tr></table></figure>


<p>在无索引的情况下处理此查询， 必须寻找 3 个表所有的组合，以便得出与 WHERE 子句相配的那些行。而可能的组合数目 为 1000×1000×1000（十亿）</p>
<p>如果对每个表进行索引，就能极大地加速查询进程，利用索引的查询处理如下。</p>
<p>从表 t1 中选择第一行，查看此行所包含的数据。<br>使用表 t2 上的索引，直接定位 t2 中与 t1 的值匹配的行。同理，利用表 t3 上的索引， 直接定位 t3 中与 t1 的值匹配的行。<br>扫描表 t1 的下一行并重复前面的过程，直到遍历 t1 中所有的行。<br>在这样的情况下，对表 t1 执行了一个完全扫描，但能够在表 t2 和 t3 上进行索引查找直接取出这些表中的行，比未用索引时要快一百万倍。<br>利用索引，MySQL 加速了 WHERE 子句满足条件行的搜索，而在多表连接查询时、在执行连接时加快了与其他表中的行匹配的速度。</p>
<h2 id="二、索引的分类（逻辑分类）"><a href="#二、索引的分类（逻辑分类）" class="headerlink" title="二、索引的分类（逻辑分类）"></a>二、索引的分类（逻辑分类）</h2><p>逻辑的角度来划分，索引分为普通索引、唯一索引、主键索引、组合索引和全文索引。</p>
<h3 id="2-1-普通索引"><a href="#2-1-普通索引" class="headerlink" title="2.1 普通索引"></a>2.1 普通索引</h3><h4 id="2-1-1-普通索引格式"><a href="#2-1-1-普通索引格式" class="headerlink" title="2.1.1 普通索引格式"></a>2.1.1 普通索引格式</h4><p>普通索引是最基本的索引，它没有任何限制，也是大多数情况下用到的索引。</p>
<p>直接创建索引的方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># column 是指定要创建索引的列名</span></span><br><span class="line"><span class="comment"># length 是可选项</span></span><br><span class="line">mysql&gt;CREATE INDEX index_name ON table_name (column(length));</span><br></pre></td></tr></table></figure>

<p>索引列的长度有一个最大上限 255 个字节（MyISAM 和 InnoDB 表的最大上限为 1000 个字 节），如果索引列的长度超过了这个上限，就只能用列的前缀进行索引。另外，BLOB 或 TEXT 类型的列也必须使用前缀索引。</p>
<h4 id="2-1-2-创建普通索引"><a href="#2-1-2-创建普通索引" class="headerlink" title="2.1.2 创建普通索引"></a>2.1.2 创建普通索引</h4><p>方法一：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>);  <span class="comment">##创建一个表结构</span></span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   |     | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; create index id_index on info(<span class="built_in">id</span>);    <span class="comment">##为info表中的id创建索引</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | MUL | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到在key下面的MUL，索引创建成功了</span></span><br></pre></td></tr></table></figure>




<p>方法二：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">修改表结构的方式添加索引</span><br><span class="line">mysql&gt;ALTER TABLE table_name ADD INDEX index_name (column(length));</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table info add index name_index (name);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | MUL | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | MUL | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>




<p>方法三：<br>在创建一个表结构时，就创建索引</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table num (<span class="built_in">id</span> int(3),index id_index(<span class="built_in">id</span>));</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; describe num;</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">| Field | Type   | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>    | int(3) | YES  | MUL | NULL    |       |</span><br><span class="line">+-------+--------+------+-----+---------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>



<h4 id="2-1-3-查看索引"><a href="#2-1-3-查看索引" class="headerlink" title="2.1.3 查看索引"></a>2.1.3 查看索引</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show index from info\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: id_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: name_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>



<h3 id="2-2-唯一索引"><a href="#2-2-唯一索引" class="headerlink" title="2.2 唯一索引"></a>2.2 唯一索引</h3><p>唯一索引与普通索引类似，不同的就是：唯一索引的索引列的值必须唯一，但允许有空<br>值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一。唯一索引创建方法和普<br>通索引类似。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改表结构的时候添加唯一索引：</span></span><br><span class="line">mysql&gt;CREATEUNIQUEINDEXindex_nameON table_name(column(length));</span><br></pre></td></tr></table></figure>

<p>新建一个表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>,primary key(<span class="built_in">id</span>));</span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   |     | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; create unique index unique_name on info2(name);</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | UNI | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  |     | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>




<p>修改表结构的时候添加唯一索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式</span><br><span class="line">mysql&gt;ALTERTABLEtable_nameADD UNIQUEindex_name(column(length));</span><br></pre></td></tr></table></figure>


<p>创建表的时候同时创建唯一索引：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CREATETABLE`table`( </span><br><span class="line">...</span><br><span class="line">UNIQUE index Name (title(length)) );</span><br></pre></td></tr></table></figure>

<h3 id="2-3-主键索引"><a href="#2-3-主键索引" class="headerlink" title="2.3 主键索引"></a>2.3 主键索引</h3><p>主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。</p>
<p>主键索引也就是primary key，在之前的创建表的过程中已经演示过，有两种方式。</p>
<p>第一种：在字段外创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>,primary key(<span class="built_in">id</span>));</span><br></pre></td></tr></table></figure>

<p>第二种：在字段内创建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table info2 (<span class="built_in">id</span> int(4) not null primary key,name varchar(10) not null,address varchar(50) default <span class="string">&#x27;未知&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-4-组合索引（最左前缀）"><a href="#2-4-组合索引（最左前缀）" class="headerlink" title="2.4 组合索引（最左前缀）"></a>2.4 组合索引（最左前缀）</h3><p>平时用的 SQL 查询语句一般都有比较多的限制条件，所以为了进一步榨取 MySQL 的效率，就要考虑建立组合索引。在组合索引的创建中，有两种场景，即为单列索引和多列索引。</p>
<p>特点：<br>遵从最左原则，从左往右依次执行；</p>
<h3 id="2-5-全文索引"><a href="#2-5-全文索引" class="headerlink" title="2.5 全文索引"></a>2.5 全文索引</h3><p>对于较大的数据集，将资料输入一个没有 FULLTEXT 索引的表中，然后创建索引，其 速度比把资料输入现有 FULLTEXT 索引的速度更快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间、非常消耗硬盘空间的做法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table info2 add fulltext index addr_index(address);    <span class="comment">##创建全文索引</span></span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.04 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 1</span><br><span class="line"></span><br><span class="line">mysql&gt; describe info2;</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type        | Null | Key | Default | Extra |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">| <span class="built_in">id</span>      | int(4)      | NO   | PRI | NULL    |       |</span><br><span class="line">| name    | varchar(10) | NO   | UNI | NULL    |       |</span><br><span class="line">| address | varchar(50) | YES  | MUL | 未知    |       |</span><br><span class="line">+---------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line">mysql&gt; show index from info2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: addr_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: address</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>




<h2 id="三、-查看及删除索引"><a href="#三、-查看及删除索引" class="headerlink" title="三、 查看及删除索引"></a>三、 查看及删除索引</h2><h3 id="3-1-查看索引"><a href="#3-1-查看索引" class="headerlink" title="3.1 查看索引"></a>3.1 查看索引</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">查看索引的两种方法</span><br><span class="line">mysql&gt;show index from tablename;</span><br><span class="line">mysql&gt;show keys from tablename;</span><br></pre></td></tr></table></figure>


<p>以show keys from tablename为例，两种方法用法相同</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show keys from info2;</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| Table | Non_unique | Key_name    | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| info2 |          0 | PRIMARY     |            1 | <span class="built_in">id</span>          | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| info2 |          0 | unique_name |            1 | name        | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| info2 |          1 | addr_index  |            1 | address     | NULL      |           0 |     NULL | NULL   | YES  | FULLTEXT   |         |               |</span><br><span class="line">+-------+------------+-------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>



<p>可以使用 mysql&gt; show keys from info2\G;使用显示结果更加直观</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; mysql&gt; show keys from info2\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 1</span><br><span class="line">     Key_name: addr_index</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: address</span><br><span class="line">    Collation: NULL</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: YES</span><br><span class="line">   Index_type: FULLTEXT</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Table：表的名称。</p>
</li>
<li><p>Non_unique：如果索引不能包括重复词，则为 0；如果可以，则为 1。</p>
</li>
<li><p>Key_name：索引的名称。</p>
</li>
<li><p>Seq_in_index：索引中的列序号，从 1 开始。</p>
</li>
<li><p>Column_name：列名称。</p>
</li>
<li><p>Collation：列以什么方式存储在索引中。在 MySQL 中，有值‘A’（升序）或 NULL（无分类）。</p>
</li>
<li><p>Cardinality：索引中唯一值数目的估计值。通过运行 ANALYZETABLE 或 myisamchk-a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没 有必要是精确的。基数越大，当进行联合时，MySQL 使用该索引的机会就越大。</p>
</li>
<li><p>Sub_part：如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列 被编入索引，则为 NULL。</p>
</li>
<li><p>Packed：指示关键字如何被压缩。如果没有被压缩，则为 NULL。</p>
</li>
<li><p>Null：如果列含有 NULL，则含有 YES。如果没有，则该列含有 NO。</p>
</li>
<li><p>Index_type：用过的索引方法（BTREE, FULLTEXT,HASH, RTREE）。</p>
</li>
<li><p>Comment：备注。</p>
</li>
</ol>
<h3 id="3-2-删除索引"><a href="#3-2-删除索引" class="headerlink" title="3.2 删除索引"></a>3.2 删除索引</h3><p>索引在创建之后，是会占用一定的磁盘空间的，因此表内如果有不再使用的索引，从数据库性能方面考虑，最好是删除无用索引。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">删除索引的两种方式</span><br><span class="line">DROP INDEX 索引名 ON 表名; </span><br><span class="line">ALTER TABLE 表名 DROP INDEX 索引名;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop index addr_index on info2;    <span class="comment">##删除刚刚创建的全文索引</span></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show keys from info2\G;   </span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: PRIMARY</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: <span class="built_in">id</span></span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">        Table: info2</span><br><span class="line">   Non_unique: 0</span><br><span class="line">     Key_name: unique_name</span><br><span class="line"> Seq_in_index: 1</span><br><span class="line">  Column_name: name</span><br><span class="line">    Collation: A</span><br><span class="line">  Cardinality: 0</span><br><span class="line">     Sub_part: NULL</span><br><span class="line">       Packed: NULL</span><br><span class="line">         Null: </span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment: </span><br><span class="line">Index_comment: </span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">ERROR: </span><br><span class="line">No query specified</span><br></pre></td></tr></table></figure>



<h2 id="四、-索引的底层原理"><a href="#四、-索引的底层原理" class="headerlink" title="四、 索引的底层原理"></a>四、 索引的底层原理</h2><h3 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h3><p>Mysql数据库中的常见索引结构有多种，常用Hash，B+树（最常用，多路搜索树）等数据结构来进行数据存储。树的深度加深一层，意味着多一次查询，对于数据库磁盘而言，就是多一次IO操作，导致查询效率低下。</p>
<p><strong>创建一次索引就代表了创建了一个数据结构，例如B+树。</strong></p>
<p><strong>B+树的特征：</strong></p>
<ol>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。</li>
<li>更适合文件索引系统；</li>
</ol>
<p>此处讨论B+树，结合案例见4.3。</p>
<h3 id="4-2-搜索引擎"><a href="#4-2-搜索引擎" class="headerlink" title="4.2 搜索引擎"></a>4.2 搜索引擎</h3><p>常见的有InnoDB、MyASIM（不支持数据库事务）、Memory等。存储引擎和存储方式（磁盘等）见文章：<a href="https://blog.csdn.net/wangfeijiu/article/details/112454405">MySQL体系构架、存储引擎和索引结构</a></p>
<p>此处使用InnoDB来讨论索引的存储结构，见4.3。</p>
<h3 id="4-3-InnoDB-B-树存储数据结构"><a href="#4-3-InnoDB-B-树存储数据结构" class="headerlink" title="4.3 InnoDB B+树存储数据结构"></a>4.3 InnoDB B+树存储数据结构</h3><p>存储数据结构，也是索引分类的一种：物理分类（第二章讲了逻辑分类）。物理分类分为<strong>聚簇索引</strong>和非聚簇索引。存储数据结构虽然说是索引分类的一种，但是准确的来说，<strong>聚簇索引和非聚簇索引是一种数据的存储方式。</strong></p>
<p><strong>聚簇索引（clustered index）</strong>不是单独的一种索引类型，而是一种数据存储方式。这种存储方式是依靠B+树来实现的，根据表的主键构造一棵B+树且B+树叶子节点存放的都是表的行记录数据时，方可称该主键索引为聚簇索引。聚簇索引也可理解为将数据存储与索引放到了一块，找到索引也就找到了数据。</p>
<img src="%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg">

<p><strong>非聚簇索引（辅助索引或者二级索引）</strong>：数据和索引是分开的，非聚簇索引的叶子节点并不存储数据表中的完整数据记录。相反，它们存储的是指向数据表中相应行的指针，这个指针通常是数据表中主键的值。</p>
<img src="%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95.jpg">

<p>虽然InnoDB和MyISAM存储引擎都默认使用B+树结构存储索引，但是只有InnoDB的<strong>主键索引</strong>（主键索引见2.3）才是聚簇索引，InnoDB中的辅助索引以及MyISAM使用的都是非聚簇索引。</p>
<p><strong>使用聚簇索引的优缺点（面试）：</strong></p>
<p>优点：</p>
<ol>
<li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂（页分裂见4.2链接、下图，属于操作系统的知识），严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键（主键列不要选没有意义的自增列，选经常查询的条件列才好，不然无法体现其主键索引性能）</p>
</li>
<li><p>更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</p>
</li>
<li><p>二级索引（非聚簇索引）访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
</li>
</ol>
<img src="f6cd40465df212dd91614785713be6cb.gif" style="zoom:150%;">





<h3 id="4-4-回表是什么？为什么会有回表？"><a href="#4-4-回表是什么？为什么会有回表？" class="headerlink" title="4.4 回表是什么？为什么会有回表？"></a>4.4 回表是什么？为什么会有回表？</h3><p>在4.3的聚簇索引中，我们提到缺点的第三条，非聚簇索引需要两次索引查找，这个过程我们就称为回表。</p>
<p>为什么会有回表？我们刚说到，聚簇索引是将索引和数据存储放在一起的，所以找到索引了就是找到了数据。但是根据实际查询的要求，不一定只会根据主键去查询数据。我们看以下场景：</p>
<p>假如有个表T， 里面三个字段：id k name， id为主键，并且其中对k建立了单独索引。此时有两棵B+树，一个是聚簇索引（主键索引）的B+树，一个是非聚簇索引的B+树。</p>
<ol>
<li><p>如果语句是 select * from T where id&#x3D;500，即主键查询方式（聚簇索引），则只需要搜索 ID 这棵 B+ 树，查询一表即可。</p>
</li>
<li><p>如果语句是 select id, k from T where k&#x3D;5，即普通索引查询方式（非聚簇索引），则只要搜索 k 索引树，这样的话查询一表即可。</p>
</li>
<li><p>如果语句是 select id, k , name from T where k&#x3D;5，第一次通过普通索引查询方式得到 id 的值为 500，再到 id 索引树搜索一次（需要回表才能查到name这个数据）。此时这个过程就成为回表了，回表是基于聚簇索引的缺点之一。</p>
</li>
</ol>
<p>所以为了避免回表，那么可以将k和name建成联合索引（<strong>因为在非主键索引就可以查询到数据，也称为覆盖索引）。</strong></p>
<p><strong>为什么建成联合索引就可以避免回表？</strong></p>
<p>在4.3中提到，非聚簇索引的叶子结点存储的是指向数据表中相应行的指针，这个指针通常是数据表中主键的值。那么查询到K或者name后，自然的指向了对应的id，那么这个行数据自然也就拿到了。</p>
<h2 id="五、总结-面试"><a href="#五、总结-面试" class="headerlink" title="五、总结+面试"></a>五、总结+面试</h2><p>本篇文章介绍了索引的类型，底层原理。mysql的语句了解即可，需要时查起来就可以。另外，文章针对面试需要知道的内容，这样背八股文也能很快反应过来不需要记得太难。</p>
<p>面试需要掌握的知识：mysql的搜索引擎和搜索引擎的差别（4.2节）、mysql的底层存储原理（4.1节，B+树等），mysql数据库优化（4.4节，涉及索引优化），另外需要掌握：mysql锁，mysql事务、mysql数据库优化、数据库备份等。</p>
<h2 id="六、附上一篇美团讲解的索引内容"><a href="#六、附上一篇美团讲解的索引内容" class="headerlink" title="六、附上一篇美团讲解的索引内容"></a>六、附上一篇美团讲解的索引内容</h2><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">美团：MySQL索引原理及慢查询优化</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：（一）排序算法</title>
    <url>/2024/07/03/%E7%AE%97%E6%B3%95%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序必备图示网站"><a href="#排序必备图示网站" class="headerlink" title="排序必备图示网站"></a>排序必备图示网站</h1><p>一个链接看完所有排序算法的图示：<a href="https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html">排序算法图示</a></p>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>核心思想: </p>
<ol>
<li>相邻的元素两两比较，大的放右边，小的放左边。</li>
<li>第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推。</li>
<li>如果数组中有n个数据，总共我们只要执行n- 1轮的代码就可以。</li>
</ol>
<p>重点在于冒泡排序的优化：</p>
<p>第二层for循环中可以-i，进而提高效率</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoBubbleSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//-1防止索引越界</span></span><br><span class="line">            <span class="comment">///-i提高效率</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用递归实现冒泡排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort(arr, arr.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归实现冒泡排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length-<span class="number">1</span>; left++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left + <span class="number">1</span>] &lt; arr[left]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">                arr[left] = arr[left + <span class="number">1</span>];</span><br><span class="line">                arr[left + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            bubbleSort(arr, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序使用双指针法的对撞指针，定义start指针（左指针）和end指针（右指针）查找指针指向的数组元素和baseNumber的关系</p>
<p>在第一轮的排序中，通过方法会确定基准数的位置，接下来按照基准数的位置将会划分以基准数为中间的左右两个区间，再对两个区间进行递归（递归时不断的二分区间）完成排序。</p>
<p>注意点：</p>
<ol>
<li>end指针一定要先动</li>
<li>递归需要定义出口</li>
<li>baseNumber需要在出口后定义否则可能索引越界</li>
<li>递归的地方是quickSort(arr, i, start - 1)和quickSort(arr, start + 1, j);</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">doQuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 1、输入数组个数和数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[number];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、调用快速排序</span></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、打印排序结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">//1、确定基准数、左指针、右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归函数的出口</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*baseNumber应该放在判断结束之后*/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">baseNumber</span> <span class="operator">=</span> arr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、当end指针在start指针右边，或者是两个指针没有重合时都需要进行循环</span></span><br><span class="line">        <span class="keyword">while</span> (end != start) &#123;</span><br><span class="line">            <span class="comment">// 当end指针指向的数字比baseNumber小的时候，end指针停止</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[end] &lt; baseNumber || end &lt;= start) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当start指针指向的数字比baseNumber大的时候，start指针停止</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[start] &gt; baseNumber || end &lt;= start) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//此时运行到这里，两个指针指向的位置已经确定了，交换两个指针对应的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 退出最外层循环后，start,end指向同一个位置，即baseNumber的位置，基准数归位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[start];</span><br><span class="line">        arr[start] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一轮排序结束，开始递归</span></span><br><span class="line">        quickSort(arr, i, start - <span class="number">1</span>);</span><br><span class="line">        quickSort(arr, start + <span class="number">1</span>, j);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在baseNumber定义之前设置递归出口</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="1、合并有序数组"><a href="#1、合并有序数组" class="headerlink" title="1、合并有序数组"></a>1、合并有序数组</h2><p>将数组内的两个区间内的有序元素进行合并</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以将该数组看为{1,5,6}和{2,3,7,8}，合并后仍然用原来的空间存储数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>假设已知两个数组的范围，第一个是l到lEnd，第二个是rEnd到rEnd，那么合并两个的代码如下：</p>
<p>其中l和r变量不仅充当范围的作用，还是一个指针，指向当前元素的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> lEnd, <span class="type">int</span> r, <span class="type">int</span> rEnd, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l;<span class="comment">//temp数组的索引</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd &amp;&amp; r &lt;= rEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;</span><br><span class="line">                temp[k++] = arr[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = arr[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd) &#123;</span><br><span class="line">            temp[k++] = arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= rEnd) &#123;</span><br><span class="line">            temp[k++] = arr[r++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在代码中，我们使用一个中间数组temp去存储变量，k的值去记录temp的索引，比较两个区间的值，小的就放进temp数组就可以了。</p>
<p><strong>下面两个while循环的作用是什么？</strong></p>
<p>如果说第一个区间的l指针已经走到了末尾，那么第二个区间的r指针肯定没有走到结尾。又因为两个区间都是排好序的，所以第二个区间剩下的元素肯定都是比第一个区间的数字要大的，直接拼接到temp数组后面就行了。也就是说，两个while循环还可以换成以下写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (l &gt; lEnd) &#123;</span><br><span class="line">    System.arraycopy(arr, r, temp, k, rEnd - r + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r &gt; rEnd) &#123;</span><br><span class="line">    System.arraycopy(arr, l, temp, k, lEnd - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2、使用合并数组实现归并排序-递归"><a href="#2、使用合并数组实现归并排序-递归" class="headerlink" title="2、使用合并数组实现归并排序(递归)"></a>2、使用合并数组实现归并排序(递归)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoMergeSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 1、输入数组个数和数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[number];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义初始数组的区间</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、调用sort方法进行排序</span></span><br><span class="line">        mergeSort(arr, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 3、归并排序讲究分治的思想，对于拿到的一个数组，不断的进行对半拆分，直到每个区间都拆到只剩1个元素后再对两个区间合并</span></span><br><span class="line"><span class="comment">         * 合并的时候进行排序，不断的递归</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 定义临时数组存储数据，如果在split中创建的话每次递归都会创建一个数组，所以写在这里</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        split(arr, left, right, temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = Arrays.copyOfRange(arr, left, right + <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5、治：当区间中只有一个元素的时候认为数组有序（提供递归的出口）</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4、分：不断的将每一个区间进行拆分，直到拆到一个区间只有一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt;&gt; <span class="number">1</span>;<span class="comment">//算平均值</span></span><br><span class="line"></span><br><span class="line">        split(arr, left, mid, temp);<span class="comment">//递归</span></span><br><span class="line">        split(arr, mid + <span class="number">1</span>, right, temp);<span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6、合</span></span><br><span class="line">        merge(arr, left, mid, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">        System.arraycopy(temp, left, arr, left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> lEnd, <span class="type">int</span> r, <span class="type">int</span> rEnd, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l;<span class="comment">//temp数组的索引</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd &amp;&amp; r &lt;= rEnd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;</span><br><span class="line">                temp[k++] = arr[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = arr[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= lEnd) &#123;</span><br><span class="line">            temp[k++] = arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= rEnd) &#123;</span><br><span class="line">            temp[k++] = arr[r++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>比较难的地方：</strong></p>
<ol>
<li><p>split方法比较难理解，我用代码输出一下拆分的过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// split方法</span></span><br><span class="line"><span class="type">int</span>[] array = Arrays.copyOfRange(arr, left, right + <span class="number">1</span>);</span><br><span class="line">System.out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入案例</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="number">3</span> <span class="number">7</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分过程</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">9</span>]</span><br><span class="line">[<span class="number">3</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">7</span>]</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">8</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">8</span>]</span><br><span class="line">[<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">[<span class="number">4</span>]</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br></pre></td></tr></table></figure>

<p>可以看到流程是这样的（数据不一样）：<img src="%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.gif">只有拆分到最小的时候（就是区间只有一个元素的时候)，递归结束，到merge方法进行合并。而merge中就实现排序的方法逻辑。</p>
</li>
<li><p>在merge方法中，我设置了temp数组的索引k值。之前我写的是k&#x3D;0，而不是k&#x3D;l，这里是不对的。为什么不对？</p>
<p>其实在整个归并的过程中，两个子数组归并到上一级的数组的时候，temp数组是要进行覆盖之前的元素的，而上一级的数组排序的时候，应该为两个子数组的最左边的那个范围。</p>
<p>我们拿split的例子来说，得到两个子数组[9,3]和[7,2]的时候，l的值是0，那么排序的时候k应该从0开始，得到两个子数组[8,5]和[1,4]的时候，i的值应该对应8索引，然后赋值到temp索引中。所以merge方法的k索引取决于扔进去的两个区间的最左边的范围。<img src="temp%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95.png" style="zoom:80%;"></p>
</li>
<li><p>范围上都是left到mid，mid+1到right</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">split(arr, left, mid, temp);<span class="comment">//递归</span></span><br><span class="line">split(arr, mid + <span class="number">1</span>, right, temp);<span class="comment">//递归</span></span><br><span class="line">merge(arr, left, mid, mid + <span class="number">1</span>, right, temp);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>再看一个不分多个方法写的版本，其实思路都是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoMergeSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">24</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        MergeSort2(arr, left, right, temp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">MergeSort2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="comment">// 看看分治成功了没有</span></span><br><span class="line">        <span class="type">int</span>[] array = Arrays.copyOfRange(arr, left, right + <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.治</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.分</span></span><br><span class="line">        MergeSort2(arr, left, mid, temp);</span><br><span class="line">        MergeSort2(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                temp[k++] = arr[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">                temp[k++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.arraycopy(temp, left, arr, left, right - left + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p><img src="%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png"></p>
<p>首先找到排好序的部分，标记排好序的最右边的索引，然后从无序的第一个开始，和排序好的部分最右边的比较，如果无序的第一个元素比排好序的最大的元素相比要小，那么就把这个元素一直往左边移动，直到排好序的元素比这个移动的元素要小为止。</p>
<p>插入的思想在于遍历无序的部分，不断的和有序的部分比较，不断的往左边移动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">insertdemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">3</span>, <span class="number">44</span>, <span class="number">38</span>, <span class="number">5</span>, <span class="number">47</span>, <span class="number">15</span>, <span class="number">36</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">50</span>, <span class="number">48</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//1.拿到无序的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                startIndex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(startIndex);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.遍历从startIndex开始的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//提高效率，一直用i，完成一轮以后又要走空代码（while不会成立），效率低</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//交换数据</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                <span class="comment">//i要一直指向移动的那个数字</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        print(arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="面试常考排序算法"><a href="#面试常考排序算法" class="headerlink" title="面试常考排序算法"></a>面试常考排序算法</h1><p><a href="https://blog.csdn.net/qq_45792749/article/details/124410972">面试常考的排序算法</a></p>
<h1 id="acWing代码模板"><a href="#acWing代码模板" class="headerlink" title="acWing代码模板"></a>acWing代码模板</h1><p><a href="https://www.acwing.com/blog/content/31431/">【Java版本】常用代码模板1——基础算法 + 模板题参考实现 - AcWing</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：（三）数据结构——链表</title>
    <url>/2024/07/06/%E7%AE%97%E6%B3%95%EF%BC%9A%EF%BC%88%E4%B8%89%EF%BC%89%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h1><p><img src="%E9%93%BE%E8%A1%A8%E5%88%86%E7%B1%BB.png"></p>
<h1 id="1-单向链表-包含头指针"><a href="#1-单向链表-包含头指针" class="headerlink" title="1. 单向链表(包含头指针)"></a>1. 单向链表(包含头指针)</h1><h2 id="1-1-单向链表实现"><a href="#1-1-单向链表实现" class="headerlink" title="1.1 单向链表实现"></a>1.1 单向链表实现</h2><p>单向链表为一个SingleLinkedList类，里面包含Node内部类（封装，不向外暴露底层实现细节），一个节点记录下一个节点的地址值，是一个指针，在java中其实就是引用对象（一个引用数据类型记录的是地址值，所以Node类中使用Node作为变量，实际上是下一个节点的地址）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-头插法添加元素"><a href="#1-2-头插法添加元素" class="headerlink" title="1.2 头插法添加元素"></a>1.2 头插法添加元素</h2><p>链表不为空的时候，插入的节点的地址值应该指向原本链表中的第一个节点，head刚好记录的就是第一个节点的地址值，所以将head指针的值赋值给新节点node。再将创建出来的node节点赋值给head指针，代表head指向新插入的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 1.链表为空的情况</span></span><br><span class="line">          head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 2.链表不为空</span></span><br><span class="line">          <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, head);</span><br><span class="line">          head = node;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>再将头插法简化一下，其实一行的代码就搞定了。在上面的代码的else语句中，其实两行代码是冗余的，可以放idea里面让编译器提示；另外如果head是null的情况下，下面的代码也可以同时包含if-else的逻辑。不过写上面的吧，看得懂。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">     head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, head);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-遍历链表"><a href="#1-3-遍历链表" class="headerlink" title="1.3 遍历链表"></a>1.3 遍历链表</h2><h3 id="1-3-1-while循环实现遍历"><a href="#1-3-1-while循环实现遍历" class="headerlink" title="1.3.1 while循环实现遍历"></a>1.3.1 while循环实现遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//循环链表</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loopList</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head;<span class="comment">//head头指针默认就是null（引用数据类型没有初始化就是null）,除非添加元素</span></span><br><span class="line">      <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;当前链表元素的值：&quot;</span> + now.value);</span><br><span class="line">          now = now.next;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>编写测试类：在链表同一级包下创建类TestSingleLinkedList1，使用@Test注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSingleLinkedList1</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span><span class="comment">//Maven导入的测试类包</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SingleLinkedList1</span> <span class="variable">singleLinkedList1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList1</span>();</span><br><span class="line">        singleLinkedList1.addFirst(<span class="number">1</span>);</span><br><span class="line">        singleLinkedList1.addFirst(<span class="number">2</span>);</span><br><span class="line">        singleLinkedList1.addFirst(<span class="number">3</span>);</span><br><span class="line">        singleLinkedList1.addFirst(<span class="number">4</span>);</span><br><span class="line">        singleLinkedList1.loopList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//当前链表元素的值：4</span></span><br><span class="line"><span class="comment">//当前链表元素的值：3</span></span><br><span class="line"><span class="comment">//当前链表元素的值：2</span></span><br><span class="line"><span class="comment">//当前链表元素的值：1</span></span><br></pre></td></tr></table></figure>



<h3 id="1-3-2-迭代器实现遍历"><a href="#1-3-2-迭代器实现遍历" class="headerlink" title="1.3.2 迭代器实现遍历"></a>1.3.2 迭代器实现遍历</h3><p>我把其他部分代码删了，只留下迭代器的部分。</p>
<p>类实现迭代器的接口，需要重写iterator方法（神金才选择变成抽象类），接着 return new Iterator&lt;&gt;()，以匿名内部类的形式重写hasNext方法和next方法，hasNext就是判断<code>当前元素</code>（记好，是当前元素，不要因为有next命名以为是下一个）是否存在，next方法对当前元素进行自己的处理逻辑，<code>并且移动迭代器指针</code>。OK，next方法直接返回节点的值（value），直接测试类输出就行了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList1</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> node != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> node.value;</span><br><span class="line">                node = node.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SingleLinkedList1</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList1</span>();</span><br><span class="line">    list2.addFirst(<span class="number">1</span>);</span><br><span class="line">    list2.addFirst(<span class="number">2</span>);</span><br><span class="line">    list2.addFirst(<span class="number">3</span>);</span><br><span class="line">    list2.addFirst(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Integer element : list2) &#123;</span><br><span class="line">        System.out.println(element);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>



<h3 id="1-3-3-递归遍历"><a href="#1-3-3-递归遍历" class="headerlink" title="1.3.3 递归遍历"></a>1.3.3 递归遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loop2</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(node.value);</span><br><span class="line">    loop2(node.next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-4-尾插法添加元素"><a href="#1-4-尾插法添加元素" class="headerlink" title="1.4 尾插法添加元素"></a>1.4 尾插法添加元素</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加元素（尾差法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果head为空，那么直接赋值新节点后退出，否则循环链表到最后节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.遍历链表到最后一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//2.代码运行到这里的时候说明now=null，说明当前是没有值的</span></span><br><span class="line">                <span class="comment">//3.创建新对象赋值给now，使得now指针指向新节点node</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">                now.next = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SingleLinkedList1</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList1</span>();</span><br><span class="line">        list1.addFirst(<span class="number">1</span>);</span><br><span class="line">        list1.addFirst(<span class="number">2</span>);</span><br><span class="line">        list1.addFirst(<span class="number">3</span>);</span><br><span class="line">        list1.addFirst(<span class="number">4</span>);</span><br><span class="line">        list1.addLast(<span class="number">5</span>);</span><br><span class="line">        list1.loopList();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//当前链表元素的值：4</span></span><br><span class="line"><span class="comment">//当前链表元素的值：3</span></span><br><span class="line"><span class="comment">//当前链表元素的值：2</span></span><br><span class="line"><span class="comment">//当前链表元素的值：1</span></span><br><span class="line"><span class="comment">//当前链表元素的值：5</span></span><br></pre></td></tr></table></figure>



<h2 id="1-5-获取索引"><a href="#1-5-获取索引" class="headerlink" title="1.5 获取索引"></a>1.5 获取索引</h2><p>由于链表中不存在index属性，所以将在获取索引的时候（就是遍历链表的时候自己设置一个）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找链表中的第index个节点</span></span><br><span class="line"><span class="keyword">public</span> Node <span class="title function_">findIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head; now != <span class="literal">null</span>; i++,now = now.next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// now为null时退出循环，所以返回null，代表查不到这个node节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValueByFindIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SingleLinkedList1</span> <span class="variable">list4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList1</span>();</span><br><span class="line">    list4.addFirst(<span class="number">1</span>);</span><br><span class="line">    list4.addFirst(<span class="number">2</span>);</span><br><span class="line">    list4.addFirst(<span class="number">3</span>);</span><br><span class="line">    list4.addFirst(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> list4.getValueByFindIndex(<span class="number">1</span>);</span><br><span class="line">    System.out.println(index1);</span><br><span class="line">    <span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> list4.getValueByFindIndex(<span class="number">5</span>);</span><br><span class="line">    System.out.println(index2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-6-任意位置插入元素"><a href="#1-6-任意位置插入元素" class="headerlink" title="1.6 任意位置插入元素"></a>1.6 任意位置插入元素</h2><p>如果index超过索引范围，抛异常。最后两行findIndex方法的循环条件是now !&#x3D; null（1.5for循环中的条件），所以只会在链表的有效范围内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">           addFirst(value);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 插入的位置是index，那么需要让index位置上一个节点指向插入点，插入点指向上一个元素原来指向的节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);<span class="comment">//上一个节点</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//输入的index超过链表范围</span></span><br><span class="line">       <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果查到的node节点他不是空的，说明是在链表中间到末尾最后一个的位置，可以插入</span></span><br><span class="line">       node.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, node.next);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SingleLinkedList1</span> <span class="variable">list5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList1</span>();</span><br><span class="line"><span class="comment">//        list5.addFirst(1);</span></span><br><span class="line"><span class="comment">//        list5.addFirst(2);</span></span><br><span class="line"><span class="comment">//        list5.addFirst(3);</span></span><br><span class="line"><span class="comment">//        list5.addFirst(4);</span></span><br><span class="line"></span><br><span class="line">        list5.insert(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">        list5.loopList();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-删除节点"><a href="#1-7-删除节点" class="headerlink" title="1.7 删除节点"></a>1.7 删除节点</h2><p>删除节点只需要改一个节点的next，只需要把需要删除的节点的上一个节点指向需要删除的节点的下一个元素就行了，说得有些拗口，画个图</p>
<p>假设我要删除2元素，那么只需要让1元素指向3就行了，<strong>2元素指向什么元素和链表无关</strong>。ok可能会担心内存的问题，因为没有node节点2了。其实在java中存在gc机制，不会导致内存之类的问题。</p>
<p><img src="%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9.png"></p>
<p>删除的时候有三种情况</p>
<ol>
<li><p>如果删除的是索引0，findIndex(index - 1)中的参数是-1，也是null，假设索引0确实存在元素，直接使用如下代码是不合理的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//待删除的上一个节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">preNode</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span> (preNode == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>因为index-1是应该指的是head指针，而不是计算出来的-1。所以单独判断一种情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除索引0的情况</span></span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(<span class="number">0</span>);</span><br><span class="line">               head = node.next;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;索引0位置不存在元素&quot;</span>);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>如果删除的元素的上一个元素不存在，则说明超出了链表范围，抛异常</p>
</li>
<li><p>如果删除的元素不存在，和第二种情况一样，抛异常</p>
</li>
</ol>
<p>只有满足2，3情况，才能让 <code>Node next = node.next;    preNode.next = next</code>跑起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//删除索引0的情况</span></span><br><span class="line">       <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(<span class="number">0</span>);</span><br><span class="line">               head = node.next;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;索引0位置不存在元素&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//待删除的上一个节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">preNode</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span> (preNode == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//待删除的节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> preNode.next;</span><br><span class="line">       <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//待删除的下一个节点</span></span><br><span class="line">       <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line"></span><br><span class="line">       preNode.next = next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-8-整个链表的源码"><a href="#1-8-整个链表的源码" class="headerlink" title="1.8 整个链表的源码"></a>1.8 整个链表的源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SingleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList1</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> node != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> node.value;</span><br><span class="line">                node = node.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（头插法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 1.链表为空的情况</span></span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.链表不为空</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, head);</span><br><span class="line">            head = node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//while循环链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loopList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表元素的值：&quot;</span> + now.value);</span><br><span class="line">            now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（尾差法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果head为空，那么直接赋值新节点后退出，否则循环链表到最后节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.遍历链表到最后一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//2.代码运行到这里的时候说明now=null，说明当前是没有值的</span></span><br><span class="line">                <span class="comment">//3.创建新对象赋值给now，使得now指针指向新节点node</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">                now.next = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找链表中的第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head; now != <span class="literal">null</span>; i++, now = now.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">                <span class="keyword">return</span> now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValueByFindIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            addFirst(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入的位置是index，那么需要让index位置上一个节点指向插入点，插入点指向上一个元素原来指向的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);<span class="comment">//上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入的index超过链表范围</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果查到的node节点他不是空的，说明是在链表中间到末尾最后一个的位置，可以插入</span></span><br><span class="line">        node.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, node.next);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//删除索引0的情况</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(<span class="number">0</span>);</span><br><span class="line">                head = node.next;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;索引0位置不存在元素&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待删除的上一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">preNode</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (preNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//待删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> preNode.next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//待删除的下一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line"></span><br><span class="line">        preNode.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-单向链表（带哨兵）"><a href="#2-单向链表（带哨兵）" class="headerlink" title="2. 单向链表（带哨兵）"></a>2. 单向链表（带哨兵）</h1><p>在第一节中，head指向的要么是null，要么是链表的第一个元素，但是在增删查中，总是需要判断head指针指向的是不是null，或者删除中是否满足findIndex方法的逻辑等，这样判断确实有些麻烦</p>
<p>现在让链表中插入一个哨兵节点（sentinel），让head指针指向它，可以省去部分node是否为null的判断。哨兵节点的value随便是什么都可以，遍历的时候不要遍历哨兵节点就行了。</p>
<p><img src="%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> SingleLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单向链表（带哨兵）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList2</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="comment">//头指针指向哨兵节点，value是什么随便填写，因为不属于链表的元素，也不打算遍历哨兵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">114514</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> node != <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> node.value;</span><br><span class="line">                node = node.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（头插法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//哨兵后的第一个元素节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">//插入的节点指向原本哨兵后的第一个节点的同时让哨兵指向插入的节点</span></span><br><span class="line">        head.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//while循环链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loopList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历的起点变了，从head变成head.next开始，意思就是从哨兵往后的第一个节点开始，不包括哨兵</span></span><br><span class="line">        <span class="comment">// head = new node(value,node)了以后head指向哨兵，head.next就是哨兵的下一个</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;当前链表元素的值：&quot;</span> + now.value);</span><br><span class="line">            now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（尾插法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//哨兵的尾插法不需要进行非空判断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.遍历链表到最后一个节点</span></span><br><span class="line">        <span class="comment">// 遍历的起点变了，从head变成new node(value,node)哨兵节点了，因为head=new node(value,node)，所以直接写head就是哨兵</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//2.代码运行到这里的时候说明now=null，说明当前是没有值的</span></span><br><span class="line">                <span class="comment">//3.创建新对象赋值给now，使得now指针指向新节点node</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value, <span class="literal">null</span>);</span><br><span class="line">                now.next = node;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> now = now.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找链表中的第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// for循环遍历的起点变了，从head变成head.next开始，意思就是从哨兵往后的第一个节点开始，不包括哨兵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">now</span> <span class="operator">=</span> head.next; now != <span class="literal">null</span>; i++, now = now.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">                <span class="keyword">return</span> now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValueByFindIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//哨兵机制也不用改动，防止输入的index范围超出链表的长度</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//哨兵机制下上一个节点可以使用findIndex方法，不需要单独判断index=0，原本是打算直接使用findIndex方法找上一个节点的</span></span><br><span class="line">        <span class="comment">//使用方法的时候如果是0索引得到的是-1，是一种特殊情况，现在有了哨兵就不需要单独判断0了</span></span><br><span class="line"><span class="comment">//        if (index == 0) &#123;</span></span><br><span class="line"><span class="comment">//            addFirst(value);</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入的位置是index，那么需要让index位置上一个节点指向插入点，插入点指向上一个元素原来指向的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);<span class="comment">//上一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入的index超过链表范围</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果查到的node节点他不是空的，说明是在链表中间到末尾最后一个的位置，可以插入</span></span><br><span class="line">        node.next = <span class="keyword">new</span> <span class="title class_">Node</span>(value, node.next);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 哨兵机制下和insert方法的理由同理，可以不用单独判断index=0的情况</span></span><br><span class="line">        <span class="comment">//删除索引0的情况</span></span><br><span class="line"><span class="comment">//        if (index == 0) &#123;</span></span><br><span class="line"><span class="comment">//            if (head != null) &#123;</span></span><br><span class="line"><span class="comment">//                Node node = findIndex(0);</span></span><br><span class="line"><span class="comment">//                head = node.next;</span></span><br><span class="line"><span class="comment">//                return;</span></span><br><span class="line"><span class="comment">//            &#125; else throw new IllegalArgumentException(&quot;索引0位置不存在元素&quot;);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//待删除的上一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">preNode</span> <span class="operator">=</span> findIndex(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (preNode == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//待删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> preNode.next;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;参数不合法：第&quot;</span> + index + <span class="string">&quot;个元素在链表中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//待删除的下一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line"></span><br><span class="line">        preNode.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-双向链表（带哨兵）"><a href="#3-双向链表（带哨兵）" class="headerlink" title="3. 双向链表（带哨兵）"></a>3. 双向链表（带哨兵）</h1><p><img src="%E5%8F%8C%E5%90%91%E5%93%A8%E5%85%B5.png">双向链表的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表（带哨兵）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedList1</span> &#123;</span><br><span class="line">    <span class="comment">// 头哨兵</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">// 尾哨兵</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表的无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedList1</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">114514</span>, <span class="literal">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">114514</span>, <span class="literal">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 上一个节点指针</span></span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="comment">// 值</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="comment">// 下一个节点指针</span></span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各种方法都写在一块儿了，根据图来写方法就行了，增删查的方法：</p>
<p>双向链表特有的，也是优势的方法就是<code>尾插</code>和<code>尾删</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> DoublyLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向链表（带哨兵）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoublyLinkedList1</span> &#123;</span><br><span class="line">    <span class="comment">// 头哨兵</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="comment">// 尾哨兵</span></span><br><span class="line">    <span class="keyword">private</span> Node tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 双向链表的无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DoublyLinkedList1</span><span class="params">()</span> &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">114514</span>, <span class="literal">null</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, <span class="number">114514</span>, <span class="literal">null</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 上一个节点指针</span></span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="comment">// 值</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="comment">// 下一个节点指针</span></span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找链表中的第index个节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findNode</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为遍历的时候从head哨兵开始，但是实际链表中不把head哨兵算在索引内，因此index=-1开始</span></span><br><span class="line">        <span class="comment">// index=-1代表的节点是head哨兵</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> head; p != tail; p = p.next, i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//1.通过findIndex去搜索索引的位置</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 判断index是否在链表中存在，prev存在，那么就可以插入，因为findIndex不会遍历头尾哨兵</span></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;输入的index：\&quot;&quot;</span> + index + <span class="string">&quot;\&quot;不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> findNode(index);</span><br><span class="line">        <span class="comment">//2.创建插入的节点对象</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(prev, value, next);</span><br><span class="line">        <span class="comment">//3.插入的新节点的上一个节点，next指向新节点</span></span><br><span class="line">        prev.next = node;</span><br><span class="line">        <span class="comment">//4.插入的新节点的下一个节点，prev指向新节点</span></span><br><span class="line">        next.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（头插法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        insert(<span class="number">0</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">//1.通过findIndex去搜索索引的位置</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> findNode(index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;输入的index：\&quot;&quot;</span> + index + <span class="string">&quot;\&quot;不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.待删除的节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> prev.next;</span><br><span class="line">        <span class="keyword">if</span> (node == tail) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;输入的index：\&quot;&quot;</span> + index + <span class="string">&quot;\&quot;不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.待删除的下一个节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//将需要删除的节点的上一个节点指向需要删除的节点的下一个节点</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加元素（尾插法）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(tail.prev, value, tail);</span><br><span class="line">        tail.prev.next = node;</span><br><span class="line">        tail.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除元素（尾删）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        <span class="keyword">if</span> (lastNode == head) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;当前删除元素为tailSentinel，不能使用尾删法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> lastNode.prev;</span><br><span class="line">        prev.next = tail;</span><br><span class="line">        tail.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据索引获取链表元素值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValueByFindIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findNode(index);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="4-环形链表"><a href="#4-环形链表" class="headerlink" title="4. 环形链表"></a>4. 环形链表</h1><img src="%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.png" style="zoom: 120%;">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LoopDoublyLinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoopDoublyLinkedList1</span> <span class="keyword">implements</span> <span class="title class_">Iterable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node sentinel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;Integer&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p != sentinel;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> p.value;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环链表的无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LoopDoublyLinkedList1</span><span class="params">()</span> &#123;</span><br><span class="line">        sentinel = <span class="keyword">new</span> <span class="title class_">Node</span>(sentinel, <span class="number">0</span>, sentinel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">//上一个节点</span></span><br><span class="line">        Node prev;</span><br><span class="line">        <span class="comment">//节点的值</span></span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        <span class="comment">//下一个节点</span></span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//节点类的有参构造方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node prev, <span class="type">int</span> value, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.prev = prev;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(sentinel, value, sentinel.next);</span><br><span class="line">        sentinel.next = node;</span><br><span class="line">        sentinel.next.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾插法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">lastNode</span> <span class="operator">=</span> sentinel.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(lastNode, value, sentinel);</span><br><span class="line">        lastNode.next = lastNode;</span><br><span class="line">        sentinel.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头删法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeFirst</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sentinel.next == sentinel) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;头删不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">remove</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> remove.next;</span><br><span class="line">        sentinel.next = next;</span><br><span class="line">        next.prev = sentinel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尾删法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeLast</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">remove</span> <span class="operator">=</span> sentinel.prev;</span><br><span class="line">        <span class="keyword">if</span> (remove == sentinel) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;尾删不合法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> remove.prev;</span><br><span class="line">        prev.next = sentinel;</span><br><span class="line">        sentinel.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据值进行删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> findByValue(value);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">prev</span> <span class="operator">=</span> node.prev;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">findByValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> sentinel.next;</span><br><span class="line">        <span class="keyword">while</span> (p != sentinel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.value == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：（二）二分查找</title>
    <url>/2024/07/03/%E7%AE%97%E6%B3%95%EF%BC%9A%EF%BC%88%E4%BA%8C%EF%BC%89%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="一、基础二分查找"><a href="#一、基础二分查找" class="headerlink" title="一、基础二分查找"></a>一、基础二分查找</h1><p><a href="https://leetcode.cn/problems/binary-search/description/">力扣704：二分查找</a></p>
<p>左闭右闭区间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// nums[mid] &gt; target</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左闭右开区间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// nums[mid] &gt; target</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>left和right的含义（贼他妈重点，区分两个写法的区间到底怎么写）：</strong></p>
<p>作为<strong>区间</strong>[left,right]或者[left,right)；作为指针指向元素。</p>
<p>在左闭右闭区间中，left&lt;&#x3D;right，right是有可能指向target的，但是left&lt;right，<strong>right只是边界</strong>，right不可能是target。因此在左闭右闭区间的时候，right&#x3D;arr.length-1，而左闭右开区间right&#x3D;arr.length。</p>
<img src="%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E8%8D%89%E7%A8%BF.jpg" style="zoom:120%;">





<p><strong>二分查找注意点：</strong></p>
<ol>
<li><p><strong>单单只看左闭右闭区间，while循环中到底是left&lt;right还是left&lt;&#x3D;right？</strong></p>
<p>可以有一个具体的例子，当查找的数字是左边界的时候，left&lt;right会漏掉一次查询。因为left和right共同指向一个位置的时候不满足while条件，所以退出循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿草稿纸自己写一下，别只看不动笔的</span></span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">24</span>&#125;;</span><br><span class="line">target = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>int mid &#x3D; left + ((right - left) &gt;&gt; 1)是什么？为什么不是直接相加除2？</strong></p>
<p>超过int类型的范围以后会变负数。右移运算符&gt;&gt;1相当于转换成二进制除2，需要补一下原码，反码，补码的内容，懒得写了。</p>
</li>
</ol>
<h1 id="二、二分查找寻找插入点"><a href="#二、二分查找寻找插入点" class="headerlink" title="二、二分查找寻找插入点"></a>二、二分查找寻找插入点</h1><p>这个在力扣上也是有题目的：<a href="https://leetcode.cn/problems/search-insert-position/submissions/544277320/">力扣35：二分查找寻找插入点</a></p>
<p>来看一个最简单的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// target = 0 or 2 or 4 or 6</span></span><br></pre></td></tr></table></figure>

<p>其实不难看出就是4种情况，基于mid分两边，左边是target&#x3D;0,2，或者是右边target&#x3D;4,6，因为都是查不到的，那么肯定在左闭右闭的写法中，right和left指针会发生重合，无非就是在看0，2两个情况左右两个指针怎么动罢了，由稿纸一眼法得出，left指针的值就是需要插入的位置</p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (min&lt;=max) &#123;</span><br><span class="line">            mid = (max + min) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                <span class="comment">// 说明在target应该在右边</span></span><br><span class="line">                min = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                <span class="comment">// 说明target应该在左边</span></span><br><span class="line">                max = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到插入的位置</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="三、二分查找重复元素的处理"><a href="#三、二分查找重复元素的处理" class="headerlink" title="三、二分查找重复元素的处理"></a>三、二分查找重复元素的处理</h1><h3 id="3-1-重复元素LeftMost"><a href="#3-1-重复元素LeftMost" class="headerlink" title="3.1 重复元素LeftMost"></a>3.1 重复元素LeftMost</h3><p>leftMost：查找元素最左边的索引</p>
<p>无非就是找到target以后记录索引，而不是return。</p>
<p>代码：我写的是target一定在arr中存在的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// leftMost</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= arr[mid]) &#123;</span><br><span class="line">                temp = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果target不存在，这个写法得出来的是target插入的位置</p>
<h3 id="3-2-重复元素RigthMost"><a href="#3-2-重复元素RigthMost" class="headerlink" title="3.2 重复元素RigthMost"></a>3.2 重复元素RigthMost</h3><p>和上面一样，直接往右边一直找就完事儿了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">               temp = mid;</span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">               right = mid - <span class="number">1</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-3-重复元素中target不一定存在的情况返回最左边索引"><a href="#3-3-重复元素中target不一定存在的情况返回最左边索引" class="headerlink" title="3.3 重复元素中target不一定存在的情况返回最左边索引"></a>3.3 重复元素中target不一定存在的情况返回最左边索引</h3><p>其实在3.1中那样写if语句不包括target不一定在arr中的情况，因为我默认他可以找到的话，我会一直进行temp&#x3D;mid赋值，然而如果不存在target还进行赋值的话返回的不会是-1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        temp = binarySearch3(arr, left, right, target, temp);</span><br><span class="line"></span><br><span class="line">        System.out.println(temp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch4</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target, <span class="type">int</span> temp)</span> &#123;</span><br><span class="line">        <span class="comment">// leftMost</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; arr[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                temp = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (temp == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-4-重复元素中target不一定存在返回时插入位置"><a href="#3-4-重复元素中target不一定存在返回时插入位置" class="headerlink" title="3.4 重复元素中target不一定存在返回时插入位置"></a>3.4 重复元素中target不一定存在返回时插入位置</h3><p>看到3.1的代码就是了。为什么那样写可以在找到重复元素的同时（target存在）可以找到插入的位置？</p>
<p>原因是因为在找target的过程中，每次都给temp赋值，我们已经知道这段代码永远会去找最左边的值了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (target &lt;= arr[mid]) &#123;</span><br><span class="line">    temp = mid;</span><br><span class="line">    right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并且左闭右闭，left&#x3D;right最后一步的时候，mid的值取平均值后和left、right相等，temp&#x3D;mid记录的就是重复元素最左边的位置，刚好这个位置就是插入的位置了。</p>
<p>寻找插入位置我认为不需要判断leftmost或者rightmost，得到的结果都一样，我改了一下数组，看数组和输出结果就行了，用的都是leftMost的方法</p>
<img src="%E4%B8%8D%E5%AD%98%E5%9C%A8target%E8%8E%B7%E5%8F%96%E6%8F%92%E5%85%A5%E7%B4%A2%E5%BC%951.png" style="zoom:120%;">



<img src="%E4%B8%8D%E5%AD%98%E5%9C%A8target%E8%8E%B7%E5%8F%96%E6%8F%92%E5%85%A5%E7%B4%A2%E5%BC%952.png" style="zoom:80%;">



<h3 id="3-5-练习"><a href="#3-5-练习" class="headerlink" title="3.5 练习"></a>3.5 练习</h3><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">力扣34：查找排序数组中元素的第一个位置和最后一个位置</a></p>
<p>简单死了，就是查一个leftMost和rightMost，返回就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> leftMost(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> rightMost(nums, target);</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;left, right&#125;;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">leftMost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMost</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (i + j) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                leftMost = mid;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftMost == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftMost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rightMost</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMost</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (i + j) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightMost = mid;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rightMost == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rightMost;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h3><p>在第三节里面，讨论了二分时有重复元素的情况，<strong>使用方法查找重复元素最左边或者最右边的索引，以及通过leftMost的样例代码寻找不存在元素的插入索引位置。</strong></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法：（四）递归</title>
    <url>/2024/07/09/%E7%AE%97%E6%B3%95%EF%BC%9A%EF%BC%88%E5%9B%9B%EF%BC%89%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h1 id="一、递归的解决思想"><a href="#一、递归的解决思想" class="headerlink" title="一、递归的解决思想"></a>一、递归的解决思想</h1><ol>
<li>确定是否用递归求解</li>
<li>推导递归关系，是否存在父问题和子问题的关系，以及递归的结束条件</li>
</ol>
<p>深入到最底层的过程叫递，从里层往外叫归。在递归的过程中，外层函数的局部变量仍可用。</p>
<h1 id="二、递归的解题思路（重点）"><a href="#二、递归的解题思路（重点）" class="headerlink" title="二、递归的解题思路（重点）"></a>二、递归的解题思路（重点）</h1><ol>
<li><p><strong>递归函数的定义</strong></p>
<ul>
<li>明确函数的使命</li>
<li>明确原问题和子问题</li>
<li>兼顾原问题和子问题</li>
</ul>
</li>
<li><p><strong>基础情况处理</strong></p>
<ul>
<li>数据规模较小的时候直接返回答案</li>
</ul>
</li>
<li><p><strong>递归调用</strong></p>
<ul>
<li><p>超级操作</p>
</li>
<li><p>看成整体，忽略细节</p>
</li>
<li><p>相信他一定可以完成使命</p>
</li>
</ul>
</li>
<li><p><strong>递归到当前层</strong></p>
<ul>
<li>微操作，处理逻辑</li>
</ul>
</li>
</ol>
<h1 id="三、递归必看视频（重点）"><a href="#三、递归必看视频（重点）" class="headerlink" title="三、递归必看视频（重点）"></a>三、递归必看视频（重点）</h1><p><a href="https://www.bilibili.com/video/BV1C14y1V77j/?spm_id_from=333.337.search-card.all.click">【递归2】如何治疗晕递归?B站UP五点七边动态展示递归</a></p>
<h1 id="四、单路递归"><a href="#四、单路递归" class="headerlink" title="四、单路递归"></a>四、单路递归</h1><h2 id="1-求阶层"><a href="#1-求阶层" class="headerlink" title="1.求阶层"></a>1.求阶层</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * f(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递：父问题是求n的阶层，子问题则是求n-1的阶层，下一个子问题是求(n-1)-1的阶层…….，最后是求n&#x3D;1时，n的阶层</p>
<p>归：知道n&#x3D;1时的阶层，求n&#x3D;2的阶层，2*(n-1)，开始寻找规律，归回n。</p>
<p>递归方法是return n * f(n - 1);我换一个写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span>  n * f(n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归方法的上部分，包括递归方法，进行递，就是不断往深处找，直到找到条件为止，下面部分就是归，处理逻辑，处理求阶层的逻辑，然后返回。</p>
<h2 id="2-反向打印字符串"><a href="#2-反向打印字符串" class="headerlink" title="2.反向打印字符串"></a>2.反向打印字符串</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;spring spring 春天 春天&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> printInReflect(str, index);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">printInReflect</span><span class="params">(String str, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(index);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> printInReflect(str, index - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c + s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>递归方法上面，包括递归方法，char c &#x3D; str.charAt(index);printInReflect(str, index - 1);就是进行递的过程，不断的往反方向去找，直到找到这个字符串最左边的位置为止。归的过程就是找到最左边的字符以后String s &#x3D; printInReflect(str, index - 1);返回一个空的，接下来返回c字符（第一次递归方法）。return以后回到左边开始第二个字符，因为char c &#x3D; str.charAt(index);中c已经是左边第二个字符了，String s &#x3D; printInReflect(str, index - 1);中s在第一次递归方法中已经返回了左边第一个字符，所以拼接。return c + s也有讲究，s是子的问题，应该放在最右边，归的时候子的字符都在右边才能达到反向拼接的效果。</p>
<h2 id="3-递归二分查找"><a href="#3-递归二分查找" class="headerlink" title="3.递归二分查找"></a>3.递归二分查找</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">23</span>, <span class="number">24</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> binarySearch(left, right, arr, target);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左闭右闭区间，使用递归实现二分查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(mid + <span class="number">1</span>, right, arr, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; arr[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(left, mid - <span class="number">1</span>, arr, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>回顾一下二分查找：</p>
<p>在一个有序、不重复元素的数组中，通过双指针不断的进行二分数组的查找过程，查到数据返回数组索引值，否则返回-1</p>
<p>递的过程：不断进行二分。归的过程只有两个可能，要么是-1，要么是mid。mid的值，要么是过程中取平均值的时候使得arr[mid]&#x3D;target，要么就是left，right指向同一个值时（即递归的最后一步，也是二分查找的最后一步），mid取平均值使得arr[mid]&#x3D;target，如果还是不返回mid，那么就是-1了</p>
<h2 id="4-递归冒泡排序"><a href="#4-递归冒泡排序" class="headerlink" title="4.递归冒泡排序"></a>4.递归冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort(arr, arr.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归实现冒泡排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; left &lt; arr.length-<span class="number">1</span>; left++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[left + <span class="number">1</span>] &lt; arr[left]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">                arr[left] = arr[left + <span class="number">1</span>];</span><br><span class="line">                arr[left + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            bubbleSort(arr, right - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-递归插入排序"><a href="#5-递归插入排序" class="headerlink" title="5.递归插入排序"></a>5.递归插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test5</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="comment">//需要自行把有序索引边界算出来，此处省略</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">border</span> <span class="operator">=</span> <span class="number">2</span>;<span class="comment">//无序区间的第一个索引值</span></span><br><span class="line">        insertSort(arr, border);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归实现插入排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> border)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (border == arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextBorder</span> <span class="operator">=</span> border + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (border &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[border - <span class="number">1</span>] &gt; arr[border]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[border - <span class="number">1</span>];</span><br><span class="line">                arr[border - <span class="number">1</span>] = arr[border];</span><br><span class="line">                arr[border] = temp;</span><br><span class="line">                border--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        insertSort(arr, nextBorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="五、多路递归1"><a href="#五、多路递归1" class="headerlink" title="五、多路递归1"></a>五、多路递归1</h1><h2 id="1-详解斐波那契数列"><a href="#1-详解斐波那契数列" class="headerlink" title="1.详解斐波那契数列"></a>1.详解斐波那契数列</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上图说话：</p>
<p><img src="%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%9B%BE%E8%A7%A3.png"></p>
<p>求f（4）时，需要求解f（3）和f（2），从f（3）开始求解f（2）和f（1），f（2）求f（1）和f（0）…一直多路递归，其实就是<strong>二叉树的后序遍历</strong>。</p>
<p><strong>在多路递归中，拆成几个子问题就是拆成几个叉的数。</strong></p>
<h2 id="2-爬楼梯"><a href="#2-爬楼梯" class="headerlink" title="2.爬楼梯"></a>2.爬楼梯</h2><p>楼梯有n阶，爬到楼顶可以一次跳一阶，也可以一次跳两阶，只能向上走一共多少种爬法？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实是斐波那契数列题目的变种。</p>
<p>假设我要爬20阶，无非就是在18阶的时候决定我要怎么跳，19阶的时候我要怎么跳。</p>
<p>在19阶的时候，我只能跨一步，所以爬到19阶的时候只能是f（19），爬到18阶的时候，到20阶有两个选择，第一种，就是18-&gt;19-&gt;20，第二种就是18-&gt;20。但是第一种其实已经包括到19阶的爬法中了，如果18-&gt;19-&gt;20，就相当于19-&gt;20只能跨一步。所以第一种排除，只有第二种，18到20跨两步。所以取决于f(18)的爬楼梯次数。f(n)&#x3D;f(n-1)+f(n-2)。</p>
<p>再回到本篇博客最初的思想，就是从子问题开始分析，我要爬一阶，1种；二阶，2种；三阶，3种；四阶，5种，对子问题寻找规律，也会得到这个式子。</p>
<h1 id="六、优化递归斐波那契数列"><a href="#六、优化递归斐波那契数列" class="headerlink" title="六、优化递归斐波那契数列"></a>六、优化递归斐波那契数列</h1><p><img src="%E4%BC%98%E5%8C%96.png"></p>
<p>在算法中，颜色相同的地方需要重复计算，斐波那契数列本身的时间复杂度也是来到了$$O(n)&#x3D;1.618^n$$指数级别。可以在idea输入大一点的数字试一下，比如n&#x3D;70，代码跑半天结果都没出来，算法复杂度十分糟糕。</p>
<p><strong>现在有如下解决方案：</strong>在第一次需要求解的时候，例如，我在遍历的时候需要第一次计算f（2），算完f（0）和f（1）了以后，得到f（2）的值，将f（2）的值存入数组中，在f（4）需要求f（2）的值的时候，可以直接取到值，不用再让f（2）进行遍历。<strong>这个过程也称为剪枝，也叫记忆化、备忘录。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//假设爬70阶</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">70</span>;</span><br><span class="line">        <span class="comment">//数组记录已经递归过的值</span></span><br><span class="line">        <span class="type">int</span>[] cache = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//没递归过的值都是-1</span></span><br><span class="line">        Arrays.fill(cache, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//递归的出口也可以直接赋值，无所谓</span></span><br><span class="line">        cache[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        cache[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        cache[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用递归算结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> f(n, cache);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] cache)</span> &#123;</span><br><span class="line"><span class="comment">//        if (n == 0) &#123;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (n == 1) &#123;</span></span><br><span class="line"><span class="comment">//            return 1;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        if (n == 2) &#123;</span></span><br><span class="line"><span class="comment">//            return 2;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//取：cache[index]的值不是-1的时候取</span></span><br><span class="line">        <span class="keyword">if</span> (cache[n] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> f(n - <span class="number">1</span>, cache);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> f(n - <span class="number">2</span>, cache);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存：cache[index]的值是-1的时候存；第一次计算出结果的时候存</span></span><br><span class="line">        <span class="keyword">if</span> (cache[n] == -<span class="number">1</span>) &#123;</span><br><span class="line">            cache[n] = x + y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果在数组中，cache[n]是-1，那么说明没有递归过，存进cache数组；如果不是-1，说明递归过这个值了，数组中存过了，直接取数组中的值返回就可以了，不要递归。由于在数组中也存了n&#x3D;0，1,2的值了，也不需要进行if判断了，因为在取的时候可以返回回去</p>
<p>刚刚跑不出来的70阶也跑出来了，$$f（70）&#x3D; 696897233$$</p>
<p>另外，为什么在代码中我们选择使用数组作为缓存的数据结构而不是map集合？那自然是因为cpu的三级缓存和数组存储空间连续性的原因让我们查数组查得比集合要快。可以看主页的另一篇操作系统cpu的文章。</p>
<h1 id="七、优化爆栈"><a href="#七、优化爆栈" class="headerlink" title="七、优化爆栈"></a>七、优化爆栈</h1><h2 id="1-尾调用"><a href="#1-尾调用" class="headerlink" title="1.尾调用"></a>1.尾调用</h2><p>如果函数的最后一步是调用一个函数，则称为尾调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">function <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="%E5%B0%BE%E8%B0%83%E7%94%A82.png"></p>
<p>在Java中，方法的调用都是在栈里面的，一个方法执行完毕后，释放内存，出栈。但是连续的尾调用会导致栈中的方法越来越多的同时不能释放内存，最后导致爆栈，也就是<code>stackoverflowError</code>。</p>
<p>在一些语言中，可以对尾调用进行优化：将代码变成同级关系就可以避免爆栈</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a();</span><br><span class="line">b();</span><br><span class="line">c();</span><br></pre></td></tr></table></figure>

<p>再来思考为什么对函数进行操作比如b()+1不行？</p>
<p>因为必须要等b返回以后才能进行+1，仍然是a嵌套b的关系，但是如果不存在的话，a只管a的逻辑处理，b也只管b的逻辑处理，可以优化尾调用</p>
<h2 id="2-尾递归"><a href="#2-尾递归" class="headerlink" title="2.尾递归"></a>2.尾递归</h2><p>尾递归是尾调用的一种特殊情况。无非就是方法调用的是自己。在java中，不存在尾调用的优化（就是不能把方法从嵌套改为并列关系），所以只能使用其他语言。能实现的语言有：c++、scala。在idea中可以安装scala的插件使用scala的语法。</p>
<p>由于在java中会存在爆栈问题，因此解决的方案就是将递归改为循环。</p>
<h1 id="八、多路递归2"><a href="#八、多路递归2" class="headerlink" title="八、多路递归2"></a>八、多路递归2</h1><h2 id="1-汉诺塔"><a href="#1-汉诺塔" class="headerlink" title="1.汉诺塔"></a>1.汉诺塔</h2><p><img src="%E6%B1%89%E8%AF%BA%E5%A1%94.png"></p>
<h3 id="1-1-图解："><a href="#1-1-图解：" class="headerlink" title="1.1 图解："></a>1.1 图解：</h3><p><img src="%E6%B1%89%E8%AF%BA%E5%A1%941.png"></p>
<p><img src="%E6%B1%89%E8%AF%BA%E5%A1%942.png"></p>
<p><img src="%E6%B1%89%E8%AF%BA%E5%A1%943.png"></p>
<h3 id="1-2多叉树："><a href="#1-2多叉树：" class="headerlink" title="1.2多叉树："></a>1.2多叉树：</h3><p><img src="%E6%B1%89%E8%AF%BA%E5%A1%944.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Demo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//三根柱子</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;Integer&gt; list3 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//圆盘个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> number; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            list1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">        remove(number, list1, list2, list3);</span><br><span class="line">        System.out.println(<span class="string">&quot;=================================&quot;</span>);</span><br><span class="line">        System.out.println(list3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> n, LinkedList&lt;Integer&gt; list1, LinkedList&lt;Integer&gt; list2, LinkedList&lt;Integer&gt; list3)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 当只剩下一个圆盘时，直接从list1移动到list3</span></span><br><span class="line">            list3.add(list1.removeLast());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 递归地将n-1个圆盘从list1移动到list2，使用list3作为辅助</span></span><br><span class="line">            remove(n - <span class="number">1</span>, list1, list3, list2);</span><br><span class="line">            print(list1, list2, list3);</span><br><span class="line">            <span class="comment">// 将list1上剩下的最大圆盘移动到list3</span></span><br><span class="line">            list3.add(list1.removeLast());</span><br><span class="line">            print(list1, list2, list3);</span><br><span class="line">            <span class="comment">// 递归地将list2上的n-1个圆盘移动到list3</span></span><br><span class="line">            remove(n - <span class="number">1</span>, list2, list1, list3);</span><br><span class="line">            print(list1, list2, list3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(LinkedList&lt;Integer&gt; list1, LinkedList&lt;Integer&gt; list2, LinkedList&lt;Integer&gt; list3)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------------------------------------&quot;</span>);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line">        System.out.println(list2);</span><br><span class="line">        System.out.println(list3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-杨辉三角"><a href="#2-杨辉三角" class="headerlink" title="2.杨辉三角"></a>2.杨辉三角</h2><p>来</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
